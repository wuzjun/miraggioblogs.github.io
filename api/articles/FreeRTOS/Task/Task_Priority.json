{"title":"设置任务优先级思路，初始化顺序","uid":"fe0f1e831ccdde158001439cb8e6d513","slug":"FreeRTOS/Task/Task_Priority","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:49.813Z","comments":true,"path":"api/articles/FreeRTOS/Task/Task_Priority.json","keywords":null,"cover":"https://s2.loli.net/2022/01/27/2MSkCZnBDz1oYJi.jpg","content":"<p>在实际调车时，pid 参数的确定是一个很重要的一环，导致 pid 参数确定的难度除了自身调参水平，代码合理性，代码逻辑，数据刷新频率，还有优先级等问题。</p>\n<p>如何初始化机器人也是代码稳定性一个很重要的一环，至少要保证机器人在你不希望动的时候不要动，该动的时候才开始启动。</p>\n<p>现在只讲优先级和初始化顺序的问题。</p>\n<h1 id=\"1-我的Freertos创建的任务如下\"><a href=\"#1-我的Freertos创建的任务如下\" class=\"headerlink\" title=\"1.我的Freertos创建的任务如下\"></a><strong>1.我的Freertos创建的任务如下</strong></h1><p><img src=\"/post/FreeRTOS/Task/Task_Priority/Untitled.png\" alt=\"Untitled.png\"></p>\n<hr>\n<h1 id=\"2-优先级思路\"><a href=\"#2-优先级思路\" class=\"headerlink\" title=\"2.优先级思路\"></a><strong>2.优先级思路</strong></h1><p>CM 里优先级是封装好的，只有 7 种优先级</p>\n<p>从 osPriorityRealtime~osPriorityldle 依次递减</p>\n<p>一开始 CAN 接收任务的优先级高于主控制任务优先级（Task_CanMsgRece Priority&gt;Task_Control Priority）,但是我发现在调云台电机的时候参数非常难确定，猜想是不是 CAN 接收的任务把我主控制函数打断了。</p>\n<p>我接下来把主控制的优先级调最高后，发现参数正常了起来</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">osThreadDef(Task_Control, RobotControl, osPriorityRealtime, 0, 600);\nTask_ControlHandle &#x3D; osThreadCreate(osThread(Task_Control), NULL);</code></pre>\n\n<h1 id=\"3-初始化顺序\"><a href=\"#3-初始化顺序\" class=\"headerlink\" title=\"3.初始化顺序\"></a><strong>3.初始化顺序</strong></h1><p>机器人在没初始化前是禁止启动的，主要原因是在创建全局变量的时候，默认值是为 0。但机器人上电后的真实值不一定为 0，会导致机器人突然动一下。为了解决这个问题，就要在启动前把机器人真实值赋值给用户定义的全局变量。解决这个问题的原理是在机器人启动前开启机器人必要的通讯，把机器人各种真实值读取进来，等待稳定过后，再把真实值赋值给用户定义的全局变量（上电记住当前位置）</p>\n<p>在标准库的模板中，任务的创建是可以由用户自由配置的，所以通过在一个任务里创建别的任务来解决这个问题。但是在使用 HAL 库创建任务时，任务都是独立的，而且顺序没法由用户修改。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">osThreadDef(Task_Vision, Vision_Sampling, osPriorityHigh, 0, 128);\nTask_VisionHandle &#x3D; osThreadCreate(osThread(Task_Vision), NULL);\n\n&#x2F;* definition and creation of Task_USART *&#x2F;\nosThreadDef(Task_USART, Test, osPriorityBelowNormal, 0, 256);\nTask_USARTHandle &#x3D; osThreadCreate(osThread(Task_USART), NULL);\n\n&#x2F;* definition and creation of Task_WorldTime *&#x2F;\nosThreadDef(Task_WorldTime, WorldTime, osPriorityAboveNormal, 0, 128);\nTask_WorldTimeHandle &#x3D; osThreadCreate(osThread(Task_WorldTime), NULL);\n\n&#x2F;* definition and creation of Task_CanMsgRece *&#x2F;\nosThreadDef(Task_CanMsgRece, CanReceives, osPriorityHigh, 0, 256);\nTask_CanMsgReceHandle &#x3D; osThreadCreate(osThread(Task_CanMsgRece), NULL);\n\n&#x2F;* definition and creation of Task_Init *&#x2F;\nosThreadDef(Task_Init, All_Init, osPriorityNormal, 0, 128);\nTask_InitHandle &#x3D; osThreadCreate(osThread(Task_Init), NULL);</code></pre>\n\n<p>创建的任务都是并列式的，这就造成一个问题，CAN 的优先级低了，初始化任务都执行完了都还没运行，高了又会打断主控制函数的运行。其中一个解决办法可以参考下面优先级排列：</p>\n<p>主控制任务 &gt; 接收任务 &gt; 初始化任务 &gt; 调试任务</p>\n<p>按照这种逻辑，主控制任务就只能放在初始化任务里创建，于是就不能使用 HAL 自动生成，但也仅此一个，其他任务依然可以由HAL生成。</p>\n<p>在这种优先级下，单片机上电必然会先运行接收任务，但是由于使用了<strong>队列</strong>，任务会被堵塞。接着便会运行初始化任务，初始化任务会开启一系列外设，由于接收任务优先级高于初始化优先级，接收任务开始接收电机等信息。延时2秒后，数据逐渐稳定，便可以进入<strong>临界区</strong>，保证初始化变量的时候不被打断。接着就可以创建控制任务了，机器人就可以使能了。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void All_Init(void const * argument)\n&#123;\n  &#x2F;* USER CODE BEGIN All_Init *&#x2F;\n\t  &#x2F;* Infinite loop *&#x2F;\n\tRobot.WorkStatus &#x3D; WorkStatus_Disable;\n\tHAL_TIM_PWM_Start(&amp;htim5, TIM_CHANNEL_1);\n\tHAL_TIM_PWM_Start(&amp;htim5, TIM_CHANNEL_2);\n\tHAL_TIM_PWM_Start(&amp;htim5, TIM_CHANNEL_3);\n\t&#x2F;* C615捕获初始化及使能 *&#x2F;\n\tHAL_TIM_IC_Start_IT(&amp;htim4, TIM_CHANNEL_1);\n\tHAL_TIM_IC_Start_IT(&amp;htim4, TIM_CHANNEL_2);\n\tHAL_TIM_IC_Start_IT(&amp;htim4, TIM_CHANNEL_3);\n\tHAL_TIM_IC_Start_IT(&amp;htim4, TIM_CHANNEL_4);\n\tDevicesMonitor_Init();\n\tCAN1_IT_Init();\n\tCAN2_IT_Init();\n\tJudgeSystem_Init();\n\tDR16_USART1_IT_Init();\n\tUSART6_IT_Init();\n\tVision_USART7_IT_Init();     &#x2F;&#x2F;各种外设启动\n\tHAL_Delay(2000);\n\n\ttaskENTER_CRITICAL();&#x2F;&#x2F;进入临界区\n\tRobot_init();\n\tGY6050_Init();\n\tChassis_Init();\n\tCloud_Init();\n\tVision_Init();\n\tShoot_Init();        &#x2F;&#x2F;各种变量初始化\n\n\tosThreadDef(Task_Control, RobotControl, osPriorityRealtime, 0, 600);\n\tTask_ControlHandle &#x3D; osThreadCreate(osThread(Task_Control), NULL);\n\n\tRobot.WorkStatus &#x3D; WorkStatus_Normal;&#x2F;&#x2F;初始化完成，机器人从这里之后才能动。\n\tvTaskDelete(NULL);&#x2F;&#x2F;删除当前任务。\n\ttaskEXIT_CRITICAL();            &#x2F;&#x2F;退出临界区\n  &#x2F;* USER CODE END All_Init *&#x2F;\n&#125;</code></pre>","text":"在实际调车时，pid 参数的确定是一个很重要的一环，导致 pid 参数确定的难度除了自身调参水平，代码合理性，代码逻辑，数据刷新频率，还有优先级等问题。 如何初始化机器人也是代码稳定性一个很重要的一环，至少要保证机器人在你不希望动的时候不要动，该动的时候才开始启动。 现在只讲优先...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"HAL","slug":"HAL","count":14,"path":"api/tags/HAL.json"},{"name":"FreeRTOS","slug":"FreeRTOS","count":1,"path":"api/tags/FreeRTOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E6%88%91%E7%9A%84Freertos%E5%88%9B%E5%BB%BA%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%A6%82%E4%B8%8B\"><span class=\"toc-text\">1.我的Freertos创建的任务如下</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E4%BC%98%E5%85%88%E7%BA%A7%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">2.优先级思路</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">3.初始化顺序</span></a></li></ol>","author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"PWR 电源管理系统","uid":"56bfdee5a1538a86dab7c1c2d98d1f03","slug":"cubeMX/cubeMX-PWR","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.161Z","comments":true,"path":"api/articles/cubeMX/cubeMX-PWR.json","keywords":null,"cover":"https://s2.loli.net/2022/02/07/dWHnFjbumQfo7sY.jpg","text":"1.PVD-电源监控功能1.1.初始化 PWRPWR_PVDTypeDef pvd_config; &#x2F;&#x2F;定义句柄 void PVD_Config(void) &#x2F;&#x2F;初始化 &#123; __HAL_RCC_PWR_CLK_ENABLE(); ...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"},{"name":"PWR","slug":"PWR","count":1,"path":"api/tags/PWR.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CM中CAN的配置，使用，以及启动方法","uid":"4c5c9d96b89531a94360a8185952acf2","slug":"cubeMX/cubeMX-AllCAN/CAN","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.084Z","comments":true,"path":"api/articles/cubeMX/cubeMX-AllCAN/CAN.json","keywords":null,"cover":"https://s2.loli.net/2022/01/27/B6WkKzXE13Stnqi.jpg","text":"1.CAN基础配置1.1.CubeMX里的配置CAN 无论是在 RM 的赛场上，还是在 STM32 的使用中，都是比较重要的功能。 在 RM 中，基本上所有的RM电机都需要使用 CAN 通讯来进行通信。 在平常使用上，大部分模块都需要使用 CAN。 而且 CAN 本身也是一种比较...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"HAL","slug":"HAL","count":14,"path":"api/tags/HAL.json"},{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}