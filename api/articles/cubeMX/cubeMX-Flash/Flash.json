{"title":"Flash使用","uid":"183e6b77bf2e73e194c62a98ae96b0fa","slug":"cubeMX/cubeMX-Flash/Flash","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.154Z","comments":true,"path":"api/articles/cubeMX/cubeMX-Flash/Flash.json","keywords":null,"cover":"https://s2.loli.net/2022/02/07/feLI8AMyJNxb3S9.jpg","content":"<h1 id=\"1-Flash-的上锁解锁\"><a href=\"#1-Flash-的上锁解锁\" class=\"headerlink\" title=\"1.Flash 的上锁解锁\"></a><strong>1.Flash 的上锁解锁</strong></h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;**\n * @brief Flash解锁 \n * \n *&#x2F;\nvoid MEM_If_Init_FS(void)\n&#123;\n    HAL_FLASH_Unlock();\n    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\n                           FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\n&#125;\n\n&#x2F;**\n * @brief Flash上锁\n * \n *&#x2F;\nvoid MEM_If_DeInit_FS(void)\n&#123;\n    HAL_FLASH_Lock();\n&#125;</code></pre>\n\n<h1 id=\"2-Flash-的读取\"><a href=\"#2-Flash-的读取\" class=\"headerlink\" title=\"2.Flash 的读取\"></a><strong>2.Flash 的读取</strong></h1><h2 id=\"2-1-Flash-读取配置\"><a href=\"#2-1-Flash-读取配置\" class=\"headerlink\" title=\"2.1.Flash 读取配置\"></a>2.1.Flash 读取配置</h2><p>从需要读取的地址开始，一直到结束的地方为止。读取的流程大致如下：</p>\n<ul>\n<li>对扇区解锁</li>\n<li>读取</li>\n<li>对扇区上锁</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;**\n * @brief 读取一个4字节的数据\n * \n * @param faddr \n * @return  \n *&#x2F;\nuint32_t STMFLASH_ReadWord(uint32_t faddr)\n&#123;\n    return *(__IO uint32_t *)faddr;\n&#125;\n\n&#x2F;**\n * @brief Flash的读取\n * \n * @param ReadAddr 开头地址\n * @param pBuffer 需要读取的数据\n * @param size 需要读取数据的大小\n * @return  \n *&#x2F;\nvoid MEM_If_Read_FS(uint32_t ReadAddr, uint32_t *pBuffer, uint32_t size)\n&#123;\n    MEM_If_Init_FS();\n    for (uint32_t i &#x3D; 0; i &lt; size; i++)\n    &#123;\n        pBuffer[i] &#x3D; STMFLASH_ReadWord(ReadAddr); &#x2F;&#x2F;读取4个字节.\n        ReadAddr +&#x3D; 4;                            &#x2F;&#x2F;偏移4个字节.\n    &#125;\n    MEM_If_DeInit_FS(); &#x2F;&#x2F;上锁\n&#125;</code></pre>\n\n<h2 id=\"2-2-Flash-读取调用\"><a href=\"#2-2-Flash-读取调用\" class=\"headerlink\" title=\"2.2.Flash 读取调用\"></a>2.2.Flash 读取调用</h2><p>我目前需要写入陀螺仪校准后的零漂数据，于是可以这样调用：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void DJI_IMUReadOffset(uint32_t *pBuffer, uint32_t num)\n&#123;\n    MEM_If_Read_FS(STM32_FLASH_BASE, pBuffer, sizeof(uint32_t[num]));\n&#125;</code></pre>\n\n<h1 id=\"3-Flash-的写入\"><a href=\"#3-Flash-的写入\" class=\"headerlink\" title=\"3.Flash 的写入\"></a><strong>3.Flash 的写入</strong></h1><h2 id=\"3-1-Flash-写入配置\"><a href=\"#3-1-Flash-写入配置\" class=\"headerlink\" title=\"3.1.Flash 写入配置\"></a>3.1.Flash 写入配置</h2><p>生成 bin 文件之后，可以看见自己代码大小，根据 F4 的扇区，可以选择一块不影响正常代码运行的扇区进行写入。写入流程大致如下：</p>\n<ul>\n<li>判断需要写入扇区地址是否正确</li>\n<li>对扇区解锁</li>\n<li>获取扇区地址数据，若不是 0XFFFFFFFF 就进行扇区擦除</li>\n<li>重新写入数据</li>\n<li>对扇区上锁</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;**\n  * @brief  Gets the sector of a given address\n  * @param  Address: Flash address\n  * @retval The sector of a given address\n  *&#x2F;\nstatic uint32_t GetSector(uint32_t Address)\n&#123;\n    uint32_t sector &#x3D; 0;\n\n    if ((Address &lt; ADDR_FLASH_SECTOR_1) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_0))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_0;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_2) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_1))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_1;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_3) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_2))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_2;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_4) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_3))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_3;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_5) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_4))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_4;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_6) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_5))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_5;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_7) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_6))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_6;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_8) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_7))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_7;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_9) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_8))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_8;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_10) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_9))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_9;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_11) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_10))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_10;\n    &#125;\n    else\n    &#123;\n        sector &#x3D; FLASH_SECTOR_11;\n    &#125;\n\n    return sector;\n&#125;\n\n&#x2F;**\n * @brief Flash的写入\n * \n * @param WriteAddr 开头地址\n * @param pBuffer 需要写入的数组\n * @param Num 需要写入数组元素数量\n * @return  \n *&#x2F;\nvoid MEM_If_Write_FS(uint32_t WriteAddr, uint32_t *pBuffer, uint32_t Num)\n&#123;\n    FLASH_EraseInitTypeDef FlashEraseInit;\n    HAL_StatusTypeDef FlashStatus &#x3D; HAL_OK;\n    uint32_t SectorError &#x3D; 0;\n    uint32_t addrx &#x3D; 0;\n    uint32_t endaddr &#x3D; 0;\n    if (WriteAddr &lt; STM32_FLASH_BASE || WriteAddr % 4)\n        return; &#x2F;&#x2F;非法地址\n\n    MEM_If_Init_FS();\n    addrx &#x3D; WriteAddr;             &#x2F;&#x2F;写入的起始地址\n    endaddr &#x3D; WriteAddr + Num * 4; &#x2F;&#x2F;写入的结束地址\n\n    if (addrx &lt; 0x080E1000)\n    &#123;\n        while (addrx &lt; endaddr)\n        &#123;\n            if (STMFLASH_ReadWord(addrx) !&#x3D; 0XFFFFFFFF)\n            &#123;\n                FlashEraseInit.TypeErase &#x3D; FLASH_TYPEERASE_SECTORS;  &#x2F;&#x2F;擦除类型，扇区擦除\n                FlashEraseInit.Sector &#x3D; GetSector(addrx);            &#x2F;&#x2F;要擦除的扇区\n                FlashEraseInit.NbSectors &#x3D; 1;                        &#x2F;&#x2F;一次只擦除一个扇区\n                FlashEraseInit.VoltageRange &#x3D; FLASH_VOLTAGE_RANGE_3; &#x2F;&#x2F;电压范围，VCC&#x3D;2.7~3.6V之间!!\n                if (HAL_FLASHEx_Erase(&amp;FlashEraseInit, &amp;SectorError) !&#x3D; HAL_OK)\n                &#123;\n                    break; &#x2F;&#x2F;发生错误了\n                &#125;\n            &#125;\n            else\n                addrx +&#x3D; 4;\n            FLASH_WaitForLastOperation(FLASH_WAITETIME); &#x2F;&#x2F;等待上次操作完成\n        &#125;\n    &#125;\n    FlashStatus &#x3D; FLASH_WaitForLastOperation(FLASH_WAITETIME); &#x2F;&#x2F;等待上次操作完成\n    if (FlashStatus &#x3D;&#x3D; HAL_OK)\n    &#123;\n        while (WriteAddr &lt; endaddr) &#x2F;&#x2F;写数据\n        &#123;\n            if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, WriteAddr, *pBuffer) !&#x3D; HAL_OK) &#x2F;&#x2F;写入数据\n            &#123;\n                break; &#x2F;&#x2F;写入异常\n            &#125;\n            WriteAddr +&#x3D; 4;\n            pBuffer++;\n        &#125;\n    &#125;\n    MEM_If_DeInit_FS(); &#x2F;&#x2F;上锁\n&#125;</code></pre>\n\n<h2 id=\"3-2-Flash-的写入调用\"><a href=\"#3-2-Flash-的写入调用\" class=\"headerlink\" title=\"3.2.Flash 的写入调用\"></a>3.2.Flash 的写入调用</h2><p>我目前需要写入陀螺仪校准后的零漂数据，于是可以这样调用：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void DJI_IMUWriteOffset(uint32_t *pBuffer, uint32_t num)\n&#123;\n    MEM_If_Write_FS(STM32_FLASH_BASE, pBuffer, num);\n&#125;</code></pre>\n\n<h1 id=\"4-Flash-配置头文件\"><a href=\"#4-Flash-配置头文件\" class=\"headerlink\" title=\"4.Flash 配置头文件\"></a><strong>4.Flash 配置头文件</strong></h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n#include &quot;main.h&quot;\n\n#define STM32_FLASH_BASE 0x080D0000 &#x2F;&#x2F;STM32 FLASH的起始地址\n#define FLASH_WAITETIME 50000       &#x2F;&#x2F;FLASH等待超时时间\n\n#define ADDR_FLASH_SECTOR_0 ((uint32_t)0x08000000)  &#x2F;* Base @ of Sector 0, 16 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_1 ((uint32_t)0x08004000)  &#x2F;* Base @ of Sector 1, 16 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_2 ((uint32_t)0x08008000)  &#x2F;* Base @ of Sector 2, 16 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_3 ((uint32_t)0x0800C000)  &#x2F;* Base @ of Sector 3, 16 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_4 ((uint32_t)0x08010000)  &#x2F;* Base @ of Sector 4, 64 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_5 ((uint32_t)0x08020000)  &#x2F;* Base @ of Sector 5, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_6 ((uint32_t)0x08040000)  &#x2F;* Base @ of Sector 6, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_7 ((uint32_t)0x08060000)  &#x2F;* Base @ of Sector 7, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_8 ((uint32_t)0x08080000)  &#x2F;* Base @ of Sector 8, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_9 ((uint32_t)0x080A0000)  &#x2F;* Base @ of Sector 9, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_10 ((uint32_t)0x080C0000) &#x2F;* Base @ of Sector 10, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_11 ((uint32_t)0x080E0000) &#x2F;* Base @ of Sector 11, 128 Kbyte *&#x2F;</code></pre>\n\n<h1 id=\"参考与致谢\"><a href=\"#参考与致谢\" class=\"headerlink\" title=\"参考与致谢\"></a><strong>参考与致谢</strong></h1><ul>\n<li><a href=\"https://www.cnblogs.com/xingboy/p/10818813.html\">生成bin文件（查看代码大小）</a></li>\n</ul>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_40147893/article/details/107423621?utm_term=flash%E8%AF%BB%E5%8F%96stm32&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-107423621&spm=3001.4430\">STM32内部Flash读写问题</a></li>\n</ul>\n<ul>\n<li><a href=\"https://www.csdn.net/tags/OtDaAg1sMTcwLWJsb2cO0O0O.html\">stm32f4flash</a></li>\n</ul>\n<ul>\n<li><a href=\"https://strongerhuang.blog.csdn.net/article/details/99827002\">STM32片上Flash读写的一些重要知识</a></li>\n</ul>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_44099973/article/details/114640965\">hal库-芯片内部flash读写</a></li>\n</ul>\n","text":"1.Flash 的上锁解锁&#x2F;** * @brief Flash解锁 * *&#x2F; void MEM_If_Init_FS(void) &#123; HAL_FLASH_Unlock(); __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP ...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"},{"name":"Flash","slug":"Flash","count":1,"path":"api/tags/Flash.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-Flash-%E7%9A%84%E4%B8%8A%E9%94%81%E8%A7%A3%E9%94%81\"><span class=\"toc-text\">1.Flash 的上锁解锁</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-Flash-%E7%9A%84%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">2.Flash 的读取</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-Flash-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">2.1.Flash 读取配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-Flash-%E8%AF%BB%E5%8F%96%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">2.2.Flash 读取调用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-Flash-%E7%9A%84%E5%86%99%E5%85%A5\"><span class=\"toc-text\">3.Flash 的写入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Flash-%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">3.1.Flash 写入配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-Flash-%E7%9A%84%E5%86%99%E5%85%A5%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">3.2.Flash 的写入调用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-Flash-%E9%85%8D%E7%BD%AE%E5%A4%B4%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">4.Flash 配置头文件</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E4%B8%8E%E8%87%B4%E8%B0%A2\"><span class=\"toc-text\">参考与致谢</span></a></li></ol>","author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"移植官方DSP库","uid":"953874cd19baad4a77313739111b0aad","slug":"cubeMX/cubeMX-DSP/DSP","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.146Z","comments":true,"path":"api/articles/cubeMX/cubeMX-DSP/DSP.json","keywords":null,"cover":"https://s2.loli.net/2022/01/28/OhwXALQNsKrtxTn.jpg","text":"1.这里一定要勾选所有库 2.debug里引入该路径 3.然后在工程里引入这四个库 4.HAL库在生成的时候已经赋值过来了，在自己工程的这个位置 5.然后在魔术棒里添加下面的宏定义 宏定义如下 __TARGET_FPU_VFP=1,ARM_MATH_CM4,__CC_ARM 5....","link":"","photos":[],"count_time":{"symbolsCount":378,"symbolsTime":"1 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"},{"name":"DSP","slug":"DSP","count":1,"path":"api/tags/DSP.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"看门狗","uid":"e72a37ec3a778e7788cfedf767ec8c28","slug":"cubeMX/cubeMX-IWDG/看门狗","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.156Z","comments":true,"path":"api/articles/cubeMX/cubeMX-IWDG/看门狗.json","keywords":null,"cover":"https://s2.loli.net/2022/02/07/CXd4avci6nZgLEY.jpg","text":"1.CubeMX配置这次用的是独立看门狗，在 CubeMX 里可以这样配置： 这里按照公式配置需要的时间。 2.程序喂狗经过上面配置后，开机后自动会运行看门狗，要是不进行代码上喂狗的话，是会不断重启的，喂狗如下： HAL_IWDG_Refresh(&amp;hiwdg); &#x...","link":"","photos":[],"count_time":{"symbolsCount":328,"symbolsTime":"1 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"},{"name":"IWDG","slug":"IWDG","count":1,"path":"api/tags/IWDG.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}