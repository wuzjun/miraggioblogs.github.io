{"title":"CM中USART和DMA的实际关系（DR16为例）","uid":"20f9345191bccef7afe482693ca5ca5c","slug":"cubeMX/cubeMX-AllUD/USART_DMA","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.141Z","comments":true,"path":"api/articles/cubeMX/cubeMX-AllUD/USART_DMA.json","keywords":null,"cover":"https://s2.loli.net/2022/01/27/yBF9AXLxECZgwG3.jpg","content":"<p>第一是因为 USART 和 DMA 在 RM 比赛中属于比较常用的模块，需要详细的了解清楚对应的方法。</p>\n<p>第二是因为 USART 和 DMA 的配置实在是太坑了，我自己在这里也磨了将近 1 个星期的时间，这一个星期的时间我收集和分析网上各种各样的例子，以及对 HAL 的程序进行了阅读。</p>\n<p>第三是因为 “DMA” 不是 USART 的 DMA，这句话是啥意思呢？先卖个关子好了。</p>\n<p>为了让你们比较详细的了解，我将基于 DR16遥控器的代码调试，结合我的试错过程一步一步的对 DMA 中各种各样的坑进行解释：</p>\n<h1 id=\"1-第一次尝试：（失败）\"><a href=\"#1-第一次尝试：（失败）\" class=\"headerlink\" title=\"1.第一次尝试：（失败）\"></a><strong>1.第一次尝试：（失败）</strong></h1><p>在 HAL 中进行最基础的配置，在配置好 USART1 的基础上配置了 DMA_RX 的接收（USART1 的 IDLE 中断功能已经通过测试没有问题）</p>\n<p><img src=\"/post/cubeMX/cubeMX-AllUD/USART_DMA/Untitled.png\" alt=\"7%20CM%E4%B8%ADUSART%E5%92%8CDMA%E7%9A%84%E5%AE%9E%E9%99%85%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BB%A5%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%A7%BF%E5%8A%BF%E4%BD%BF%E7%94%A8DMA%EF%BC%88DR16%E4%B8%BA%E4%BE%8B%EF%BC%89%209aacd6ea630f4210ad6c1ec24b8f9a92/Untitled.png\"></p>\n<p>生成对应的代码，在 main 处写下对应的 USART1 和 DMA 的启动函数：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">__HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_IDLE);\nHAL_DMA_Start(huart1,(uint32_t)&amp;USART1-&gt;DR,(uint32_t)DR16Buffer,DR16BufferNumber)；</code></pre>\n\n<p>在中断中加入了对应的 DR16 遥控器的解码解析。</p>\n<p>烧录，启动仿真。</p>\n<p>USART1 中断正常</p>\n<p>USART1-&gt;DR 没有接收到数据，异常</p>\n<p>DMA 的 NDTR 位置没有减少，也就是没有发送数据出去，异常</p>\n<h1 id=\"2-第二次尝试：（失败）\"><a href=\"#2-第二次尝试：（失败）\" class=\"headerlink\" title=\"2.第二次尝试：（失败）\"></a><strong>2.第二次尝试：（失败）</strong></h1><p>由于 USART1 启动中断的时候有概率会因为没有清空或者其他问题导致标志位没有清除，所以在启动 USART1 中断前写入另外一行函数：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">__HAL_UART_CLEAR_IDLEFLAG(&amp;huart1);</code></pre>\n\n<p>同时发现了 HAL 系统默认配置的 IO 口是错误的，需要自己手动选择对应的 IO 口来进行配置，更改回正确的 IO 口。</p>\n<p>清除了在中断中的 DR16 遥控器的解码解析。</p>\n<p>烧录，启动仿真。</p>\n<p>USART1 中断正常</p>\n<p>USART1-&gt;DR 接收到了数据，正常</p>\n<p>DMA 的 NDTR 位置没有减少，也就是没有发送数据出去，异常</p>\n<h2 id=\"2-1-发现问题\"><a href=\"#2-1-发现问题\" class=\"headerlink\" title=\"2.1.发现问题\"></a>2.1.发现问题</h2><p>到这里的时候我已经对 DMA 的内部配置和 USART 内部的配置的不同性产生了怀疑，通过百度之后我发现了惊人的事实！那就是 DMA 的 HAL 结构体和 USART 的 HAL 库结构体有着本质上的不同。结合自己的理解我对下面进行解释。</p>\n<p>为了方便理解，我先对USART的HAL结构体进行了解析：通过打开 stm32f4xx_hal_uart.h，找到对应的 __UART_HandleTypeDef 结构体。</p>\n<details class=\"custom-details\">\n<summary>__UART_HandleTypeDef 结构体</summary>\n<p><pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct __UART_HandleTypeDef\n&#123;\n  USART_TypeDef                 *Instance;        &#x2F;*!&lt; UART registers base address        *&#x2F;\n\n  UART_InitTypeDef              Init;             &#x2F;*!&lt; UART communication parameters      *&#x2F;\n\n  uint8_t                       *pTxBuffPtr;      &#x2F;*!&lt; Pointer to UART Tx transfer Buffer *&#x2F;\n\n  uint16_t                      TxXferSize;       &#x2F;*!&lt; UART Tx Transfer size              *&#x2F;\n\n  __IO uint16_t                 TxXferCount;      &#x2F;*!&lt; UART Tx Transfer Counter           *&#x2F;\n\n  uint8_t                       *pRxBuffPtr;      &#x2F;*!&lt; Pointer to UART Rx transfer Buffer *&#x2F;\n\n  uint16_t                      RxXferSize;       &#x2F;*!&lt; UART Rx Transfer size              *&#x2F;\n\n  __IO uint16_t                 RxXferCount;      &#x2F;*!&lt; UART Rx Transfer Counter           *&#x2F;\n\n  DMA_HandleTypeDef             *hdmatx;          &#x2F;*!&lt; UART Tx DMA Handle parameters      *&#x2F;\n\n  DMA_HandleTypeDef             *hdmarx;          &#x2F;*!&lt; UART Rx DMA Handle parameters      *&#x2F;\n\n  HAL_LockTypeDef               Lock;             &#x2F;*!&lt; Locking object                     *&#x2F;\n\n  __IO HAL_UART_StateTypeDef    gState;           &#x2F;*!&lt; UART state information related to global Handle management\n                                                       and also related to Tx operations.\n                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef *&#x2F;\n\n  __IO HAL_UART_StateTypeDef    RxState;          &#x2F;*!&lt; UART state information related to Rx operations.\n                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef *&#x2F;\n\n  __IO uint32_t                 ErrorCode;        &#x2F;*!&lt; UART Error code                    *&#x2F;</code></pre>\n</code></pre>\n</p>\n</details>\n<p>很明显可以看出，在 USART 的结构体中，提供了 USART_Tx 发送和 USAT_Rx 接收的 DMA 结构体接口、一些地址和数字的设置的项，以及一些错误返回的选项，通过百度我知道为了使得错误选项不影响结构体在正常运行时候的判断（由于 Error 返回为 1 的时候可能会使得 USART 的整体功能运行受到阻断）。</p>\n<hr>\n<p>这个时候我在想，既然 USART 里面提供了对应的 Rx 和 Tx 的地址接口、数据大小和其他各种的状态位置，那么如果我用 DMA 初始化的话，按道理来说这里应该会被填上对应的地址、数据大小和对应的信息，以及对应的 DMA 接口的信息也会被填上去。</p>\n<p>为了验证这个假设，我在 main 函数中使能</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">HAL_DMA_Start(huart1,(uint32_t)&amp;USART1-&gt;DR,(uint32_t)DR16Buffer,DR16BufferNumber)；</code></pre>\n\n<p>烧录，仿真，观看对应的 DMA 接口，也就是 *hdmarx 中有没有填上对应的相关信息。</p>\n<p>结果我发现没有！！没有！！！！那个该死的 DMA 接口里面的数据空空如也！！</p>\n<p>再观看对应的 DMA 结构体，DMA 结构体的 Instance 里面虽然有对应的信息，但是无法和 USART 连接起来，因为他是 DMA 专用的对应于 DMA 内部的结构体。</p>\n<details class=\"custom-details\">\n<summary>__DMA_HandleTypeDef 结构体</summary>\n<p><pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct __DMA_HandleTypeDef\n&#123;\n  DMA_Stream_TypeDef         *Instance;                                                        &#x2F;*!&lt; Register base address                  *&#x2F;\n\n  DMA_InitTypeDef            Init;                                                             &#x2F;*!&lt; DMA communication parameters           *&#x2F; \n\n  HAL_LockTypeDef            Lock;                                                             &#x2F;*!&lt; DMA locking object                     *&#x2F;  \n\n  __IO HAL_DMA_StateTypeDef  State;                                                            &#x2F;*!&lt; DMA transfer state                     *&#x2F;\n\n  void                       *Parent;                                                          &#x2F;*!&lt; Parent object state                    *&#x2F; \n\n  void                       (* XferCpltCallback)( struct __DMA_HandleTypeDef * hdma);         &#x2F;*!&lt; DMA transfer complete callback         *&#x2F;\n\n  void                       (* XferHalfCpltCallback)( struct __DMA_HandleTypeDef * hdma);     &#x2F;*!&lt; DMA Half transfer complete callback    *&#x2F;\n\n  void                       (* XferM1CpltCallback)( struct __DMA_HandleTypeDef * hdma);       &#x2F;*!&lt; DMA transfer complete Memory1 callback *&#x2F;\n  \n  void                       (* XferM1HalfCpltCallback)( struct __DMA_HandleTypeDef * hdma);   &#x2F;*!&lt; DMA transfer Half complete Memory1 callback *&#x2F;\n  \n  void                       (* XferErrorCallback)( struct __DMA_HandleTypeDef * hdma);        &#x2F;*!&lt; DMA transfer error callback            *&#x2F;\n  \n  void                       (* XferAbortCallback)( struct __DMA_HandleTypeDef * hdma);        &#x2F;*!&lt; DMA transfer Abort callback            *&#x2F;  \n\n  __IO uint32_t              ErrorCode;                                                        &#x2F;*!&lt; DMA Error code                          *&#x2F;\n  \n  uint32_t                   StreamBaseAddress;                                                &#x2F;*!&lt; DMA Stream Base Address                *&#x2F;\n\n  uint32_t                   StreamIndex;                                                      &#x2F;*!&lt; DMA Stream Index                       *&#x2F;\n \n&#125;DMA_HandleTypeDef;</code></pre>\n</code></pre>\n</p>\n</details>\n<details class=\"custom-details\">\n<summary>再详细阅读官方库给用户的定义的函数</summary>\n<p><pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;*UART以DMA方式接收指定长度数据到指定缓冲区*&#x2F;\nHAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\n&#123;\n  uint32_t *tmp;\n \n  &#x2F;* Check that a Rx process is not already ongoing *&#x2F;\n  &#x2F;* 检查huart-&gt;RxState是否处于接收空闲 状态。\n  当这一状态标志非READY时，会跳过DMA接收参数设置，直接返回HAL_BUSY。\n  其它的UART接收函数也会检查这个状态，所以，哪个先调用就执行哪个。*&#x2F;\n  if(huart-&gt;RxState &#x3D;&#x3D; HAL_UART_STATE_READY)  \n  &#123;\n    if((pData &#x3D;&#x3D; NULL) || (Size &#x3D;&#x3D; 0U))\n    &#123;\n      return HAL_ERROR;\n    &#125;\n \n    &#x2F;* Process Locked *&#x2F;\n    __HAL_LOCK(huart);\n \n    huart-&gt;pRxBuffPtr &#x3D; pData;\n    huart-&gt;RxXferSize &#x3D; Size;\n \n    huart-&gt;ErrorCode &#x3D; HAL_UART_ERROR_NONE;\n    huart-&gt;RxState &#x3D; HAL_UART_STATE_BUSY_RX;\n \n    &#x2F;* Set the UART DMA transfer complete callback *&#x2F;\n\t&#x2F;*设置DMA传输完成的回调函数。当DMA以循环方式传输时会调用UART接收完成中断的回调函数；\n\t以Normal方式传输时会关闭UART的DMA通道，并使能UART传输完成中断，触发UART传输完成中断，\n\t设置huart-&gt;RxState为READY，并调用UART接收完成中断的回调函数。\n\t所以，不管DMA按循环或正常模式传输，到最后都会调用UART接收完成中断的回调函数*&#x2F;\n    huart-&gt;hdmarx-&gt;XferCpltCallback &#x3D; UART_DMAReceiveCplt; \n    &#x2F;* Set the UART DMA Half transfer complete callback *&#x2F;\n    huart-&gt;hdmarx-&gt;XferHalfCpltCallback &#x3D; UART_DMARxHalfCplt;\n \n    &#x2F;* Set the DMA error callback *&#x2F;\n    huart-&gt;hdmarx-&gt;XferErrorCallback &#x3D; UART_DMAError;\n \n    &#x2F;* Set the DMA abort callback *&#x2F;\n    huart-&gt;hdmarx-&gt;XferAbortCallback &#x3D; NULL;\n \n    &#x2F;* Enable the DMA channel *&#x2F;\n\t&#x2F;*以中断方式打开DMA传输。所以CubeMx中DMA中断默认是打开的切不可更改*&#x2F;\n    tmp &#x3D; (uint32_t*)&amp;pData;\n    HAL_DMA_Start_IT(huart-&gt;hdmarx, (uint32_t)&amp;huart-&gt;Instance-&gt;DR, *(uint32_t*)tmp, Size);\n    &#x2F;* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer *&#x2F;\n    __HAL_UART_CLEAR_OREFLAG(huart);\n \n    &#x2F;* Process Unlocked *&#x2F;\n    __HAL_UNLOCK(huart);\n \n    &#x2F;* Enable the UART Parity Error Interrupt *&#x2F;\n    SET_BIT(huart-&gt;Instance-&gt;CR1, USART_CR1_PEIE);\n \n    &#x2F;* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) *&#x2F;\n    SET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_EIE);\n \n    &#x2F;* Enable the DMA transfer for the receiver request by setting the DMAR bit\n    in the UART CR3 register *&#x2F;\n    SET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAR);\n \n    return HAL_OK;\n  &#125;\n  else\n  &#123;\n    return HAL_BUSY;\n  &#125;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<p>可见官方库是一定要你开启 DMA 中断，而且要对 USART1 结构体上面的 Rx 地址和 Rx 数据大小重新定向。</p>\n<h2 id=\"2-2-推断方法：\"><a href=\"#2-2-推断方法：\" class=\"headerlink\" title=\"2.2.推断方法：\"></a>2.2.推断方法：</h2><p>通过上面的分析，我得出了当下的两个情况：</p>\n<ol>\n<li>我开启的 DMA 并不是挂载在 USART1 上面的 DMA ，对应的 DMA 数据也没有挂载到 USART1 上发挥作用</li>\n<li>USART1 上面不管是挂载着的 DMA 的结构体，还是里面对应的 Rx 地址，Rx 数据大小都没有任何的值</li>\n<li>ErrorCode 这个错误返回的标志位最好使能掉比较好，省的阻断我程序的运行流程</li>\n</ol>\n<p>那么，首先我要做的事情就是先给 USART1 结构体上面的 Rx 地址和 Rx 数据大小重新定向，同时关闭我的 ErrorCoude 的响应。</p>\n<p>参考 stm32f427xx_hal.h 和 DevelopmentBoard_Example 中通过 CR3 位置直接打开对应挂载 DMA 传输的方法。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;*检测当前huart状态*&#x2F;\n\t\tif(huart-&gt;RxState &#x3D;&#x3D; HAL_UART_STATE_READY)\n\t\t&#123;\n\t\t\t&#x2F;*输入的地址或者数据有问题的话*&#x2F;\n\t\t\tif((pData &#x3D;&#x3D; NULL) || (Size &#x3D;&#x3D; 0))\n\t\t\t&#123;\n\t\t\t\t\treturn HAL_ERROR;\n\t\t\t&#125;\n\t\t\t\n\t\t\t&#x2F;*huart里面对应的Rx变量重定向*&#x2F;\n\t\t\thuart-&gt;pRxBuffPtr &#x3D; pData;\n\t\t\thuart-&gt;RxXferSize &#x3D; Size;\n\t\t\thuart-&gt;ErrorCode &#x3D; HAL_UART_ERROR_NONE;\n\t\t\t\n\t\t\t&#x2F;*开启huart1上的RX_DMA*&#x2F;\n\t\t\tHAL_DMA_Start(huart-&gt;hdmarx,(uint32_t)&amp;huart-&gt;Instance-&gt;DR,(uint32_t)pData,Size);\n\t\t\t\n\t\t\t&#x2F;*只开启对应DMA上面的Rx功能（如果是开启Tx的话就是USART_CR3_DMAT）*&#x2F;\n\t\t\tSET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAR);\n\t\t\t\n\t\t\t\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn HAL_BUSY;\n\t\t&#125;</code></pre>\n\n<h1 id=\"3-第三次尝试：（成功）\"><a href=\"#3-第三次尝试：（成功）\" class=\"headerlink\" title=\"3.第三次尝试：（成功）\"></a><strong>3.第三次尝试：（成功）</strong></h1><p>上述的方法，生成代码，编译烧录</p>\n<p>USART1 中断正常</p>\n<p>USART1-&gt;DR 接收到了数据，正常</p>\n<p>DMA 的 NDTR 位置成功减少，正常</p>\n<p>DR16Buffer 位置成功减少，正常</p>\n<p>解码，正常</p>\n<p>回看到中断里面的回调函数：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void DR16_Handler(UART_HandleTypeDef *huart)\n&#123;\n\n\tif (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) &amp;&amp;\n\t\t__HAL_UART_GET_IT_SOURCE(huart, UART_IT_IDLE))\n\t&#123;\n\t\t__HAL_UART_CLEAR_IDLEFLAG(huart);\n\t\t__HAL_DMA_DISABLE(huart-&gt;hdmarx);\n\n\t\t&#x2F;&#x2F;if(DR16BufferNumber - DMA_GET_COUNTER(huart-&gt;hdmarx-&gt;Instance) &#x3D;&#x3D; DR16BufferTruthNumber)\n\t\tif (__HAL_DMA_GET_COUNTER(huart-&gt;hdmarx) &#x3D;&#x3D; DR16BufferLastNumber)\n\t\t&#123;\n\t\t\tDR16.DR16_Process(DR16Buffer);\n\t\t&#125;\n\n\t\t__HAL_DMA_SET_COUNTER(huart-&gt;hdmarx, DR16BufferNumber);\n\t\t__HAL_DMA_ENABLE(huart-&gt;hdmarx);\n\t&#125;\n&#125;</code></pre>\n\n<p>对于上述对应空闲标志位的判断，我们下一个笔记再解释。</p>\n","text":"第一是因为 USART 和 DMA 在 RM 比赛中属于比较常用的模块，需要详细的了解清楚对应的方法。 第二是因为 USART 和 DMA 的配置实在是太坑了，我自己在这里也磨了将近 1 个星期的时间，这一个星期的时间我收集和分析网上各种各样的例子，以及对 HAL 的程序进行了阅...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"HAL","slug":"HAL","count":14,"path":"api/tags/HAL.json"},{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%EF%BC%9A%EF%BC%88%E5%A4%B1%E8%B4%A5%EF%BC%89\"><span class=\"toc-text\">1.第一次尝试：（失败）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B0%9D%E8%AF%95%EF%BC%9A%EF%BC%88%E5%A4%B1%E8%B4%A5%EF%BC%89\"><span class=\"toc-text\">2.第二次尝试：（失败）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2.1.发现问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E6%8E%A8%E6%96%AD%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">2.2.推断方法：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%B0%9D%E8%AF%95%EF%BC%9A%EF%BC%88%E6%88%90%E5%8A%9F%EF%BC%89\"><span class=\"toc-text\">3.第三次尝试：（成功）</span></a></li></ol>","author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CM中TIM定时器的配置，以及启动方法","uid":"4db5497cbecd2cc278cbb61ec8b5e452","slug":"cubeMX/cubeMX-AllTIM/TIM","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.121Z","comments":true,"path":"api/articles/cubeMX/cubeMX-AllTIM/TIM.json","keywords":null,"cover":"https://s2.loli.net/2022/01/27/X1xTAqOvDfNa7oE.jpg","text":"1.用HAL配置TIM的选项设置接着上一个工程继续进行编辑，由于 TIM 的高级定时器和低级定时器的界面是不同的，所以改动的方法和方式也是不同的，先由高级定时器开始理解。 这里直接使用一张图来理解高级定时器的作用： 低级定时器就比较的简单，可以直接使能一个按键的的方法来进行配置：...","link":"","photos":[],"count_time":{"symbolsCount":"8.7k","symbolsTime":"8 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"HAL","slug":"HAL","count":14,"path":"api/tags/HAL.json"},{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CM中USART的配置，以及启动方法","uid":"dea130efefdf0c7df84d0658a83a4131","slug":"cubeMX/cubeMX-AllUSART/USART","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.142Z","comments":true,"path":"api/articles/cubeMX/cubeMX-AllUSART/USART.json","keywords":null,"cover":"https://s2.loli.net/2022/01/27/176AIpMQUOKfNFt.jpg","text":"1.USART 配置USART 的配置部分比较的难搞，但是其实大部分如果注意一下的话，问题其实并不太大。 以下是 USART 中一些比较常用的通讯方式（其实实际上用的多的也就异步） 以及下面还有 RS232 的通信模式 这里涵盖了大部分的串口的通信模式，同时也可以说是涵盖了大部分...","link":"","photos":[],"count_time":{"symbolsCount":808,"symbolsTime":"1 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"HAL","slug":"HAL","count":14,"path":"api/tags/HAL.json"},{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}