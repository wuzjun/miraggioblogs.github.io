{"title":"CM中CAN的配置，使用，以及启动方法","uid":"4c5c9d96b89531a94360a8185952acf2","slug":"cubeMX/cubeMX-AllCAN/CAN","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.084Z","comments":true,"path":"api/articles/cubeMX/cubeMX-AllCAN/CAN.json","keywords":null,"cover":"https://s2.loli.net/2022/01/27/B6WkKzXE13Stnqi.jpg","content":"<h1 id=\"1-CAN基础配置\"><a href=\"#1-CAN基础配置\" class=\"headerlink\" title=\"1.CAN基础配置\"></a><strong>1.CAN基础配置</strong></h1><h2 id=\"1-1-CubeMX里的配置\"><a href=\"#1-1-CubeMX里的配置\" class=\"headerlink\" title=\"1.1.CubeMX里的配置\"></a>1.1.CubeMX里的配置</h2><p>CAN 无论是在 RM 的赛场上，还是在 STM32 的使用中，都是比较重要的功能。</p>\n<p>在 RM 中，基本上所有的RM电机都需要使用 CAN 通讯来进行通信。</p>\n<p>在平常使用上，大部分模块都需要使用 CAN。</p>\n<p>而且 CAN 本身也是一种比较重要的通信方式，原因大家也知道，因为他的泛用性比较的广而且模式多，性能好。下面来说明一下如何配置基础的 CAN 通信系统。</p>\n<p>这里我们以 CAN1 的使用为基础，基于上述程序对应的板子进行配置，先点开对应的 CAN1 配置页面</p>\n<p><img src=\"/post/cubeMX/cubeMX-AllCAN/CAN/Untitled.png\" alt=\"Untitled.png\"></p>\n<h2 id=\"1-2-手动配置Filter功能\"><a href=\"#1-2-手动配置Filter功能\" class=\"headerlink\" title=\"1.2.手动配置Filter功能\"></a>1.2.手动配置Filter功能</h2><p>配置好对应的 CAN1 内存后可以使能对应的 CAN 功能，但是 CAN 的配置有一个很大的问题，就是他只会为你配置 CAN 的最基本的功能，对应剩下的过滤器，也就是 CAN_Filter 的功能需要你自行配置。</p>\n<p>我们可以在 stm32f4xx_hal_can.h 中找到对应的滤波结构体，他分别对应着不同的参数。</p>\n<details class=\"custom-details\">\n<summary>CAN_FilterTypeDef 结构体</summary>\n<p><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct\n&#123;\n  uint32_t FilterIdHigh;          &#x2F;*!&lt; Specifies the filter identification number (MSBs for a 32-bit\n                                       configuration, first one for a 16-bit configuration).\n                                       This parameter must be a number between Min_Data &#x3D; 0x0000 and Max_Data &#x3D; 0xFFFF. *&#x2F;\n\n  uint32_t FilterIdLow;           &#x2F;*!&lt; Specifies the filter identification number (LSBs for a 32-bit\n                                       configuration, second one for a 16-bit configuration).\n                                       This parameter must be a number between Min_Data &#x3D; 0x0000 and Max_Data &#x3D; 0xFFFF. *&#x2F;\n\n  uint32_t FilterMaskIdHigh;      &#x2F;*!&lt; Specifies the filter mask number or identification number,\n                                       according to the mode (MSBs for a 32-bit configuration,\n                                       first one for a 16-bit configuration).\n                                       This parameter must be a number between Min_Data &#x3D; 0x0000 and Max_Data &#x3D; 0xFFFF. *&#x2F;\n\n  uint32_t FilterMaskIdLow;       &#x2F;*!&lt; Specifies the filter mask number or identification number,\n                                       according to the mode (LSBs for a 32-bit configuration,\n                                       second one for a 16-bit configuration).\n                                       This parameter must be a number between Min_Data &#x3D; 0x0000 and Max_Data &#x3D; 0xFFFF. *&#x2F;\n\n  uint32_t FilterFIFOAssignment;  &#x2F;*!&lt; Specifies the FIFO (0 or 1U) which will be assigned to the filter.\n                                       This parameter can be a value of @ref CAN_filter_FIFO *&#x2F;\n\n  uint32_t FilterBank;            &#x2F;*!&lt; Specifies the filter bank which will be initialized.\n                                       For single CAN instance(14 dedicated filter banks),\n                                       this parameter must be a number between Min_Data &#x3D; 0 and Max_Data &#x3D; 13.\n                                       For dual CAN instances(28 filter banks shared),\n                                       this parameter must be a number between Min_Data &#x3D; 0 and Max_Data &#x3D; 27. *&#x2F;\n\n  uint32_t FilterMode;            &#x2F;*!&lt; Specifies the filter mode to be initialized.\n                                       This parameter can be a value of @ref CAN_filter_mode *&#x2F;\n\n  uint32_t FilterScale;           &#x2F;*!&lt; Specifies the filter scale.\n                                       This parameter can be a value of @ref CAN_filter_scale *&#x2F;\n\n  uint32_t FilterActivation;      &#x2F;*!&lt; Enable or disable the filter.\n                                       This parameter can be a value of @ref CAN_filter_activation *&#x2F;\n\n  uint32_t SlaveStartFilterBank;  &#x2F;*!&lt; Select the start filter bank for the slave CAN instance.\n                                       For single CAN instances, this parameter is meaningless.\n                                       For dual CAN instances, all filter banks with lower index are assigned to master\n                                       CAN instance, whereas all filter banks with greater index are assigned to slave\n                                       CAN instance.\n                                       This parameter must be a number between Min_Data &#x3D; 0 and Max_Data &#x3D; 27. *&#x2F;\n\n&#125; CAN_FilterTypeDef;</code></pre>\n</p>\n</details>\n<p>这些参数和基本库的结构体是一一对应的。在学习 HAL 库的时候，其实也可以借机巩固一下基本库的知识，强化基本库到 HAL 库上面的代码层的使用。下面是配置 CAN_Filter 其中一个例子：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void CAN1_FILTER_Init(CAN_FilterTypeDef CAN1_Filter)\n&#123;\n\tCAN1_Filter.FilterFIFOAssignment &#x3D; CAN_FILTER_FIFO0;         &#x2F;&#x2F;筛选器被关联到FIFO0\n\tCAN1_Filter.FilterBank &#x3D; 0;                                                              &#x2F;&#x2F;筛选器组0\n\tCAN1_Filter.SlaveStartFilterBank &#x3D; 0;\n\tCAN1_Filter.FilterMode &#x3D; CAN_FILTERMODE_IDMASK;           &#x2F;&#x2F;工作在ID掩码模式\n\tCAN1_Filter.FilterScale &#x3D; CAN_FILTERSCALE_32BIT;                 &#x2F;&#x2F;筛选器位宽为单个32位。\n\tCAN1_Filter.FilterActivation &#x3D; CAN_FILTER_ENABLE;               &#x2F;&#x2F;使能筛选器\n\t\t&#x2F;* 使能筛选器，按照标志的内容进行比对筛选，扩展ID不是如下的就抛弃掉，是的话，会存入FIFO0。 *&#x2F;\n\tCAN1_Filter.FilterIdHigh &#x3D; 0x0000;                                                &#x2F;&#x2F;要筛选的ID高位 \n\tCAN1_Filter.FilterIdLow &#x3D; 0x0000;                                                &#x2F;&#x2F;要筛选的ID低位 \n\tCAN1_Filter.FilterMaskIdHigh &#x3D; 0x0000;                                     &#x2F;&#x2F;筛选器高16位每位不须匹配\n\tCAN1_Filter.FilterMaskIdLow &#x3D; 0x0000;                                      &#x2F;&#x2F;筛选器低16位每位不须匹配\n\tHAL_CAN_ConfigFilter(&amp;hcan1, &amp;CAN1_Filter);\n&#125;</code></pre>\n\n<p>在成功的配置 CAN_Filter 之后，就可以进行初始化：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void CAN1_IT_Init(void)\n&#123;\n\t&#x2F;*使能滤波器*&#x2F;\n\tCAN1_FILTER_Init(CAN1_Filter);\n\t&#x2F;*启用CAN*&#x2F;\n\tHAL_CAN_Start(&amp;hcan1);\n\t&#x2F;*使能CAN的IT中断*&#x2F;\n\t__HAL_CAN_ENABLE_IT(&amp;hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);         &#x2F;&#x2F;  CAN_IT_FMP0\n\n&#125;</code></pre>\n\n<h1 id=\"2-CAN接收\"><a href=\"#2-CAN接收\" class=\"headerlink\" title=\"2.CAN接收\"></a><strong>2.CAN接收</strong></h1><p>初始化 CAN 结束后，当有数据来时会进入 CAN 中断，于是可以在 CAN 中断中接收数据：</p>\n<ul>\n<li>先判断指定的 CAN 中断源是启用还是禁用。</li>\n<li>把接收数据发给接收队列</li>\n<li>再把接收 CAN 的数据到对应解析结构体中。</li>\n<li>清除 CAN 的挂起标志</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void CAN1_RX0_IRQHandler(void)\n&#123;\n  &#x2F;* USER CODE BEGIN CAN1_RX0_IRQn 0 *&#x2F;\n\tCAN_RxTypedef CAN_RxMessage;\n\tif (__HAL_CAN_GET_IT_SOURCE(&amp;hcan1, CAN_IT_RX_FIFO0_MSG_PENDING))\n\t&#123;\n\t\t&#x2F;*接收CAN的数据到对应解析结构体中*&#x2F;\n\t\tCAN_RxMessage.CANx &#x3D; 1;\n\t\tHAL_CAN_GetRxMessage(&amp;hcan1, CAN_RX_FIFO0,\n\t\t\t&amp;CAN_RxMessage.CAN_RxHeader,\n\t\t\tCAN_RxMessage.CAN_RxMessage);\n\t\t\n    xQueueSendToBackFromISR(xQueueCanReceive,&amp;CAN_RxMessage,0);&#x2F;&#x2F;把接收数据发给接收队列\n\n\t\t__HAL_CAN_CLEAR_FLAG(&amp;hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);\n\t&#125;\n  &#x2F;* USER CODE END CAN1_RX0_IRQn 0 *&#x2F;\n  HAL_CAN_IRQHandler(&amp;hcan1);\n  &#x2F;* USER CODE BEGIN CAN1_RX0_IRQn 1 *&#x2F;\n\n  &#x2F;* USER CODE END CAN1_RX0_IRQn 1 *&#x2F;\n&#125;</code></pre>\n\n<p>这时便完成一次 CAN 数据的接收。</p>\n<h1 id=\"3-CAN发送\"><a href=\"#3-CAN发送\" class=\"headerlink\" title=\"3.CAN发送\"></a><strong>3.CAN发送</strong></h1><h2 id=\"3-1-自定义发送函数\"><a href=\"#3-1-自定义发送函数\" class=\"headerlink\" title=\"3.1.自定义发送函数\"></a>3.1.自定义发送函数</h2><p>通过调用HAL库的函数来发送</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;**\n  * @brief  Add a message to the first free Tx mailbox and activate the\n  *         corresponding transmission request.\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\n  *         the configuration information for the specified CAN.\n  * @param  pHeader pointer to a CAN_TxHeaderTypeDef structure.\n  * @param  aData array containing the payload of the Tx frame.\n  * @param  pTxMailbox pointer to a variable where the function will return\n  *         the TxMailbox used to store the Tx message.\n  *         This parameter can be a value of @arg CAN_Tx_Mailboxes.\n  * @retval HAL status\n  *&#x2F;\nHAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, CAN_TxHeaderTypeDef *pHeader, uint8_t aData[], uint32_t *pTxMailbox)</code></pre>\n\n<p>函数作用：向第一个空闲的Tx邮箱添加一条消息，并激活*相应的传输请求。</p>\n<ul>\n<li>The first parameter：can指针指向一个CAN_HandleTypeDef结构，该结构包含*指定CAN的配置信息。（一般是调用CM生成的句柄：&amp;hcanx）</li>\n<li>Second parameter：指向CAN_TxHeader TypeDef结构的pHeader指针。（设置发送的ID，ID类型，数据长度等）</li>\n<li>The third parameter：包含Tx帧有效载荷的aData数组。（需要发送的数据）</li>\n<li>The fourth parameter：pTxMailbox指向变量的指针，函数将在其中返回*用于存储Tx消息的TxMailbox。<pre><code>                                此参数可以是@arg CAN_Tx_Mailboxes的值。（返回发送邮箱的序号）\n</code></pre>\n</li>\n</ul>\n<p>于是可以自定义一个函数方便我们调用该函数执行</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void CAN_SendData(CAN_HandleTypeDef* CANx, uint8_t id_type, uint32_t id, uint8_t data[8])  \n&#123;\t  \n\tCAN_TxHeaderTypeDef TxMessage;\n\t\n\tif(id_type &#x3D;&#x3D; CAN_ID_STD)&#123;\n\t\tTxMessage.StdId &#x3D; id;\t\t\t\t\t\t \n\t&#125;\n\telse&#123;\n\t\tTxMessage.ExtId &#x3D; id;\t\t\t\t\t &#x2F;&#x2F;ID号\n\t&#125;\n\t\n\tTxMessage.IDE &#x3D; id_type;\t\t\t\t\t &#x2F;&#x2F;ID类型\n\tTxMessage.RTR &#x3D; CAN_RTR_DATA;\t\t\t\t &#x2F;&#x2F;发送的为数据\n\tTxMessage.DLC &#x3D; 0x08;\t\t\t\t\t\t &#x2F;&#x2F;数据长度为8字节\n\tTxMessage.TransmitGlobalTime &#x3D; DISABLE;\n\t\n\tHAL_CAN_AddTxMessage(CANx,&amp;TxMessage,data,(uint32_t*)CAN_TX_MAILBOX0);\n&#125;</code></pre>\n\n<h2 id=\"3-2-发送例子\"><a href=\"#3-2-发送例子\" class=\"headerlink\" title=\"3.2.发送例子\"></a>3.2.发送例子</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;*************************************\n* Method:    CAN_0x200_SendData\n* Returns:   void\n* Parameter: int16_t iq1，参数值。\n* 说明：0x200报文的统一发送函数—— 控制3508的ID：1-4电机，2006的1-4\n************************************&#x2F;\nvoid CAN_0x200_SendData(CAN_HandleTypeDef* CAN_Num,int16_t iq1, int16_t iq2, int16_t iq3, int16_t iq4) &#123;\n\n\tuint8_t data[8];\n\n\t&#x2F;&#x2F;数据格式详见说明书P32\n\tdata[0] &#x3D; iq1 &gt;&gt; 8;\n\tdata[1] &#x3D; iq1;\n\tdata[2] &#x3D; iq2 &gt;&gt; 8;\n\tdata[3] &#x3D; iq2;\n\tdata[4] &#x3D; iq3 &gt;&gt; 8;\n\tdata[5] &#x3D; iq3;\n\tdata[6] &#x3D; iq4 &gt;&gt; 8;\n\tdata[7] &#x3D; iq4;\n\n\tCAN_SendData(CAN_Num, CAN_ID_STD, 0x200, data);\n\n&#125;</code></pre>\n\n<p>发送函数调用</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">CAN_0x200_SendData(&amp;hcan1, M3508s[0].outCurrent, M3508s[1].outCurrent, M3508s[2].outCurrent, M3508s[3].outCurrent);&#x2F;&#x2F;底盘电机(3508)</code></pre>","text":"1.CAN基础配置1.1.CubeMX里的配置CAN 无论是在 RM 的赛场上，还是在 STM32 的使用中，都是比较重要的功能。 在 RM 中，基本上所有的RM电机都需要使用 CAN 通讯来进行通信。 在平常使用上，大部分模块都需要使用 CAN。 而且 CAN 本身也是一种比较...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"HAL","slug":"HAL","count":14,"path":"api/tags/HAL.json"},{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-CAN%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1.CAN基础配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-CubeMX%E9%87%8C%E7%9A%84%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1.1.CubeMX里的配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AEFilter%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">1.2.手动配置Filter功能</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-CAN%E6%8E%A5%E6%94%B6\"><span class=\"toc-text\">2.CAN接收</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-CAN%E5%8F%91%E9%80%81\"><span class=\"toc-text\">3.CAN发送</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%91%E9%80%81%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.1.自定义发送函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E5%8F%91%E9%80%81%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">3.2.发送例子</span></a></li></ol></li></ol>","author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"设置任务优先级思路，初始化顺序","uid":"fe0f1e831ccdde158001439cb8e6d513","slug":"FreeRTOS/Task/Task_Priority","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:49.813Z","comments":true,"path":"api/articles/FreeRTOS/Task/Task_Priority.json","keywords":null,"cover":"https://s2.loli.net/2022/01/27/2MSkCZnBDz1oYJi.jpg","text":"在实际调车时，pid 参数的确定是一个很重要的一环，导致 pid 参数确定的难度除了自身调参水平，代码合理性，代码逻辑，数据刷新频率，还有优先级等问题。 如何初始化机器人也是代码稳定性一个很重要的一环，至少要保证机器人在你不希望动的时候不要动，该动的时候才开始启动。 现在只讲优先...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"HAL","slug":"HAL","count":14,"path":"api/tags/HAL.json"},{"name":"FreeRTOS","slug":"FreeRTOS","count":1,"path":"api/tags/FreeRTOS.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CM中的DMA配置简述","uid":"ba66d244f8bb441b69f53a62936b94c6","slug":"cubeMX/cubeMX-AllDMA/DMA","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.086Z","comments":true,"path":"api/articles/cubeMX/cubeMX-AllDMA/DMA.json","keywords":null,"cover":"https://s2.loli.net/2022/01/27/6kRxNAZvpIhBcfX.jpg","text":"DMA 一般是和 USART 一起使用的，但是由于 DMA 中各种奇奇怪怪的坑，导致在实际上使用的时候会出现这里不行，那里不行，各种各样的问题和 BUG。其实 DMA 这部分是比较难以解释的，在写这个笔记之前我看过网上很多的对于 DMA 配置和相关内容的解释，都讲的很笼统，或者说...","link":"","photos":[],"count_time":{"symbolsCount":570,"symbolsTime":"1 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"HAL","slug":"HAL","count":14,"path":"api/tags/HAL.json"},{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}