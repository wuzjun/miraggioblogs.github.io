{"title":"Freertos中队列的使用","uid":"d375d028bb2ac4562b320ed8e131081e","slug":"cubeMX/cubeMX-Freertos队列","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.155Z","comments":true,"path":"api/articles/cubeMX/cubeMX-Freertos队列.json","keywords":null,"cover":"https://s2.loli.net/2022/01/27/B6WkKzXE13Stnqi.jpg","content":"<h1 id=\"1-队列基础学习\"><a href=\"#1-队列基础学习\" class=\"headerlink\" title=\"1.队列基础学习\"></a><strong>1.队列基础学习</strong></h1><p>可自行搜索。</p>\n<h1 id=\"2-队列的创建\"><a href=\"#2-队列的创建\" class=\"headerlink\" title=\"2.队列的创建\"></a><strong>2.队列的创建</strong></h1><p>HAL库可以生成队列的，但是生成完之后不怎么方便使用，而且是有点BUG，于是我还是使用标准库的形式写。（创建队列必须放在HAL库规定的位置上，不然下次GENERATE时会删掉）</p>\n<p>函数原型：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize );\n\nuxQueueLength\n\n&gt; 队列能够存储的最大单元数目，即队列深度。\n\nuxItemSize\n\n&gt; 队列中数据单元的长度，以字节为单位。\n\n返回值 NULL\n\n&gt; 表示没有足够的堆空间分配给队列而导致创建失败。非NULL 值表示队列创建成功。此返回值应当保存下来，以作为操作此队列的句柄。</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;* USER CODE BEGIN RTOS_QUEUES *&#x2F;\n\t  &#x2F;* add queues, ... *&#x2F;\n\t\t&#x2F;&#x2F;创建Can发送队列\n\txQueueCanReceive &#x3D; xQueueCreate(10, sizeof(CAN_RxTypedef));\n\txQueueCanReceive_2 &#x3D; xQueueCreate(10, sizeof(CAN_RxTypedef));\n  &#x2F;* USER CODE END RTOS_QUEUES *&#x2F;</code></pre>\n\n<p>CAN_RxTypedef是用户自定义的一个结构体：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct\n&#123;\n\tuint8_t     CANx;                  &#x2F;&#x2F;CAN编号     1 CAN1      2 CAN2\n\tuint8_t CAN_RxMessage[8];          &#x2F;&#x2F;CAN接收\n\tCAN_RxHeaderTypeDef CAN_RxHeader;  &#x2F;&#x2F;CAN库结构体\n&#125;CAN_RxTypedef;</code></pre>\n\n<p>xQueueCanReceive / xQueueCanReceive_2是队列句柄，保存创建队列后的返回值；</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">osMessageQId \txQueueCanReceive;\nosMessageQId \txQueueCanReceive_2;</code></pre>\n\n<h1 id=\"3-队列的中断接收\"><a href=\"#3-队列的中断接收\" class=\"headerlink\" title=\"3.队列的中断接收\"></a><strong>3.队列的中断接收</strong></h1><p>该函数是放在CAN中断接收里使用，当CAN中断来数据时，会把数据复制到队列里。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )\n\n&gt;xQueueSendFromISR()完全等同于 xQueueSendToBackFromISR()\n\nxQueue\n\n&gt;目标队列的句柄。这个句柄即是调用 xQueueCreate()创建该队列时的返回值。\n\npvItemToQueue\n\n&gt;发送数据的指针。其指向将要复制到目标队列中的数据单元。由于在创建队列时设置了队列中数据单元的长度，所以会从该指针指向的空间复制对应长度的数据到队列的存储区域。pxHigherPriorityTaskWoken 对某个队列而言，可能有不止一个任务处于阻塞态在等待其数据有效。调用 xQueueSendToFrontFromISR()或 xQueueSendToBackFromISR()会使得队列数据变为有效，所以会让其中一个等待任务切出阻塞态。如果调用这两个 API 函数使得一个任务解除阻塞，并且这个任务的优先级高于当前任务(也就是被中断的任务)，那么 API 会在函数内部将*pxHigherPriorityTaskWoken 设为 pdTRUE。如果这两个 API 函数将此值设为 pdTRUE，则在中断退出前应当进行一次上下文切换。这样才能保证中断直接返回到就绪态任务中优先级最高的任务中。\n\n1. pdPASS返回 pdPASS 只会有一种情况， 那就是数据被成功发送到队列中。\n\n2. errQUEUE_FULL如 果 由 于 队 列 已 满 而 无 法 将 数 据 写 入 ， 则 将 返 回errQUEUE_FULL\n</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">xQueueSendToBackFromISR(xQueueCanReceive,&amp;CAN_RxMessage,0);&#x2F;&#x2F;把接收数据发给接收队列</code></pre>\n\n<h1 id=\"4-队列的数据提取\"><a href=\"#4-队列的数据提取\" class=\"headerlink\" title=\"4.队列的数据提取\"></a><strong>4.队列的数据提取</strong></h1><p>在CM里创建一个CAN接收任务，在任务里放入xQueueReceive函数</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xQueueReceive( QueueHandle_t xQueue,\n                          void * const pvBuffer,\n                          TickType_t xTicksToWait );\n\nxQueue\n\n&gt;队列创建时候的句柄，用于表示向哪个队列写入数据；\n\npvBuffer\n\n&gt;从队列读出来的数据指针；\n\nxTicksToWait\n\n&gt;如果队列为空，则为阻塞的最大时间；当被设置为 0 的时候，不阻塞，如果队列为空，则直接返回；如果设置为 portMAX_DELAY 的话，意味着如果队列为空，则会挂起这个任务；\n\nReturn\n\n&gt;当成功读出队列的数据，返回 pdTRUE；否则返回 errQUEUE_EMPTY；</code></pre>\n\n<p>在任务里执行了这个函数后，就可以读取通过该函数copy出来的数据包进行解码。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void CanReceives(void const * argument)\n&#123;\n  &#x2F;* USER CODE BEGIN CanReceives *&#x2F;\n\t  &#x2F;* Infinite loop *&#x2F;\n\tCAN_RxTypedef CanReceiveData;\n\tuint32_t ID;\n\tfor (;;)\n\t&#123;\n\t\t&#x2F;&#x2F;等待队列不为空\n\t\txQueueReceive(xQueueCanReceive, &amp;CanReceiveData, portMAX_DELAY);\n\t\tID &#x3D; CanReceiveData.CAN_RxHeader.StdId;\n\n\t\tif (CanReceiveData.CANx &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tif (ID &gt;&#x3D; M3508_READID_START &amp;&amp; ID &lt;&#x3D; M3508_READID_END)&#x2F;&#x2F;底盘电机\n\t\t\t&#123;\n\t\t\t\tM3508_getInfo(CanReceiveData);\n\t\t\t&#125;\n\t\t\telse if (ID &#x3D;&#x3D; Chassis_IMU_READID)\n\t\t\t&#123;\n\t\t\t\tGY6050_getChassisInfo(CanReceiveData);\n\t\t\t&#125;\n\t\t\telse if (ID &#x3D;&#x3D; M6020_READID_START)\n\t\t\t&#123;\n\t\t\t\tM6020_getInfo(CanReceiveData);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n  &#x2F;* USER CODE END CanReceives *&#x2F;\n&#125;</code></pre>","text":"1.队列基础学习可自行搜索。 2.队列的创建HAL库可以生成队列的，但是生成完之后不怎么方便使用，而且是有点BUG，于是我还是使用标准库的形式写。（创建队列必须放在HAL库规定的位置上，不然下次GENERATE时会删掉） 函数原型： xQueueHandle xQueueCrea...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"HAL","slug":"HAL","count":14,"path":"api/tags/HAL.json"},{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0\"><span class=\"toc-text\">1.队列基础学习</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">2.队列的创建</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%AD%E6%96%AD%E6%8E%A5%E6%94%B6\"><span class=\"toc-text\">3.队列的中断接收</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E9%98%9F%E5%88%97%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96\"><span class=\"toc-text\">4.队列的数据提取</span></a></li></ol>","author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"HAL_UART中断代码的理解","uid":"5f63062ce45d7aec6b36bb6e5eaebe8a","slug":"cubeMX/HAL_UART中断函数","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.084Z","comments":true,"path":"api/articles/cubeMX/HAL_UART中断函数.json","keywords":null,"cover":"https://s2.loli.net/2022/01/27/jHbGcYUgRyxr9kt.jpg","text":"这其实是对上一节 USART 和 DMA 方面的补充。 一方面是为了加深对中断代码的了解程度，另一方面是为了补充上一节没有写完的东西。 我们先重新来看看中断函数的具体结构。 void DR16_Handler(UART_HandleTypeDef *huart) &#123; i...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"HAL","slug":"HAL","count":14,"path":"api/tags/HAL.json"},{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"PWR 电源管理系统","uid":"56bfdee5a1538a86dab7c1c2d98d1f03","slug":"cubeMX/cubeMX-PWR","date":"2022-01-27T10:49:36.000Z","updated":"2022-02-08T15:35:50.161Z","comments":true,"path":"api/articles/cubeMX/cubeMX-PWR.json","keywords":null,"cover":"https://s2.loli.net/2022/02/07/dWHnFjbumQfo7sY.jpg","text":"1.PVD-电源监控功能1.1.初始化 PWRPWR_PVDTypeDef pvd_config; &#x2F;&#x2F;定义句柄 void PVD_Config(void) &#x2F;&#x2F;初始化 &#123; __HAL_RCC_PWR_CLK_ENABLE(); ...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"Embedded","slug":"Embedded","count":19,"path":"api/categories/Embedded.json"}],"tags":[{"name":"cubeMX","slug":"cubeMX","count":18,"path":"api/tags/cubeMX.json"},{"name":"PWR","slug":"PWR","count":1,"path":"api/tags/PWR.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}