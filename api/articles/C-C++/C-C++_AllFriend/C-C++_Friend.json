{"title":"C++ 友元与运算符","uid":"bf1ca1b83272793e4c3d135bd1c7f7c7","slug":"C-C++/C-C++_AllFriend/C-C++_Friend","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.792Z","comments":true,"path":"api/articles/C-C++/C-C++_AllFriend/C-C++_Friend.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/6be4hEBZS9xPn5A.jpg","content":"<h1 id=\"1-友元\"><a href=\"#1-友元\" class=\"headerlink\" title=\"1.友元\"></a><strong>1.友元</strong></h1><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>\n<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>\n<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>\n<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>\n<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>\n<p>友元的关键字为 <strong>friend</strong></p>\n<p>友元的三种实现</p>\n<ul>\n<li>全局函数做友元</li>\n<li>类做友元</li>\n<li>成员函数做友元</li>\n</ul>\n<h2 id=\"1-1-全局函数做友元\"><a href=\"#1-1-全局函数做友元\" class=\"headerlink\" title=\"1.1.全局函数做友元\"></a>1.1.全局函数做友元</h2><details class=\"custom-details\">\n<summary>若成员属于私人空间，但想被某个全局函数调用，可以在类里加上 <code>friend 函数</code></summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\n\tfriend void test01(void);\npublic:\n\tPerson() : m_age(0) &#123;&#125;\n\nprivate:\n\tint m_age;\n\n\tvoid Showlll(void)\n\t&#123;\n\t\tcout &lt;&lt; &quot;fdsfsadfa&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nvoid test01(void)\n&#123;\n\tPerson p;\n\tp.m_age &#x3D; 10;\n\tcout &lt;&lt; p.m_age &lt;&lt; endl;\n\tp.Showlll();\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li>运行结果：  <img src=\"/post/C-C++/C-C++_AllFriend/C-C++_Friend/Untitled%2021.png\" alt=\"Untitled%2021.png\"></li>\n</ul>\n<h2 id=\"1-2-类做友元\"><a href=\"#1-2-类做友元\" class=\"headerlink\" title=\"1.2.类做友元\"></a>1.2.类做友元</h2><details class=\"custom-details\">\n<summary>在 A 类里添加 B 类并要访问其私人空间成员，可以在 B 类里添加 <code>friend class 类名</code></summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Room;\nclass Building\n&#123;\npublic:\n\tBuilding();\n\tvoid Showroom(void);\n\nprivate:\n\tRoom *room;\n&#125;;\n&#x2F;************************************&#x2F;\nclass Room\n&#123;\n\tfriend class Building;\npublic:\n\tRoom();\n\nprivate:\n\tint m_a;\n\tint m_b;\n\tvoid Showlll(void)\n\t&#123;\n\t\tcout &lt;&lt; &quot;fdsfsadfa&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n&#x2F;************************************&#x2F;\n&#x2F;&#x2F;创建 Room 对象时初始化成员\nRoom ::Room()\n&#123;\n\tm_a &#x3D; 50;\n\tm_b &#x3D; 100;\n&#125;\n&#x2F;&#x2F;在 Building 初始化构造函数里创建 Room 类型对象\nBuilding ::Building()\n&#123;\n\troom &#x3D; new Room;\n&#125;\n&#x2F;&#x2F;可以在类内访问私人空间成员\nvoid Building::Showroom(void)\n&#123;\n\tcout &lt;&lt; room-&gt;m_a &lt;&lt; endl;\n\tcout &lt;&lt; room-&gt;m_b &lt;&lt; endl;\n\troom-&gt;Showlll();\n&#125;\n\ntest01(void)\n&#123;\n\tBuilding building;\n\tbuilding.Showroom();\n&#125;\n\nint main()\n&#123;\n\ttest01();\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h2 id=\"1-3-成员函数做友元\"><a href=\"#1-3-成员函数做友元\" class=\"headerlink\" title=\"1.3.成员函数做友元\"></a>1.3.成员函数做友元</h2><details class=\"custom-details\">\n<summary>与类做友元原理一致，只是换成该类作用域下某个成员函数。<code>friend 返回值 作用域::成员函数</code></summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Room;\nclass Building\n&#123;\npublic:\n\tBuilding();\n\tvoid Showroom(void);\n\nprivate:\n\tRoom *room;\n&#125;;\n\nclass Room\n&#123;\n\tfriend void Building::Showroom(void);\n\npublic:\n\tRoom();\n\nprivate:\n\tint m_a;\n\tint m_b;\n\tvoid Showlll(void)\n\t&#123;\n\t\tcout &lt;&lt; &quot;fdsfsadfa&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;创建 Room 对象时初始化成员\nRoom ::Room()\n&#123;\n\tm_a &#x3D; 50;\n\tm_b &#x3D; 100;\n&#125;\n&#x2F;&#x2F;在 Building 初始化构造函数里创建 Room 类型对象\nBuilding ::Building()\n&#123;\n\troom &#x3D; new Room;\n&#125;\n&#x2F;&#x2F;可以在类内访问私人空间成员\nvoid Building::Showroom(void)\n&#123;\n\tcout &lt;&lt; room-&gt;m_a &lt;&lt; endl;\n\tcout &lt;&lt; room-&gt;m_b &lt;&lt; endl;\n\troom-&gt;Showlll();\n&#125;\n\ntest01(void)\n&#123;\n\tBuilding building;\n\tbuilding.Showroom();\n&#125;\n\nint main()\n&#123;\n\ttest01();\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h1 id=\"2-运算符重载\"><a href=\"#2-运算符重载\" class=\"headerlink\" title=\"2.运算符重载\"></a><strong>2.运算符重载</strong></h1><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>\n<h2 id=\"2-1-加号运算符重载\"><a href=\"#2-1-加号运算符重载\" class=\"headerlink\" title=\"2.1.加号运算符重载\"></a>2.1.加号运算符重载</h2><p>作用：实现两个自定义数据类型相加的运算</p>\n<details class=\"custom-details\">\n<summary>用系统带的<code>operator+</code>进行重载</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\n\tint m_a;\n\tint m_b;\n\n\tPerson() : m_a(60), m_b(20) &#123;&#125;\n\n\t&#x2F;&#x2F;成员函数重载加号运算符\n\tPerson operator+(const Person &amp;p2)\n\t&#123;\n\t\tPerson temp;\n\t\ttemp.m_a &#x3D; this-&gt;m_a + p2.m_a;\n\t\ttemp.m_b &#x3D; this-&gt;m_b + p2.m_b;\n\t\treturn temp;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;全局函数重载加号运算符\n&#x2F;&#x2F; Person operator+(Person p1, Person p2)\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F; \tPerson temp;\n&#x2F;&#x2F; \ttemp.m_a &#x3D; p1.m_a + p2.m_a;\n&#x2F;&#x2F; \ttemp.m_b &#x3D; p1.m_b + p2.m_b;\n&#x2F;&#x2F; \treturn temp;\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F;运算符重载也可以发生函数重载\nPerson operator+(Person p1, int num)\n&#123;\n\tPerson temp;\n\ttemp.m_a &#x3D; p1.m_a + num;\n\ttemp.m_b &#x3D; p1.m_b + num;\n\treturn temp;\n&#125;\n\ntest01(void)\n&#123;\n\tPerson p1;\n\tPerson p2;\n\n\t&#x2F;&#x2F;成员函数方式：相当于 p1.operaor+(p2)\n\t&#x2F;&#x2F;全局函数方式：相当于 operator+(p1,p2)\n\tPerson p3 &#x3D; p1 + p2;\n\tPerson p4 &#x3D; p3 + 50;\n\n\t&#x2F;&#x2F;重载后不影响本来的运算符\n\tint i &#x3D; 0;\n\ti &#x3D; 50 + 60;\n\tcout &lt;&lt; &quot;i &#x3D; &quot; &lt;&lt; i &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;p3.m_a &#x3D; &quot; &lt;&lt; p3.m_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;p3.m_b &#x3D; &quot; &lt;&lt; p3.m_b &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;p4.m_a &#x3D; &quot; &lt;&lt; p4.m_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;p4.m_b &#x3D; &quot; &lt;&lt; p4.m_b &lt;&lt; endl;\n\n&#125;\n\nint main()\n&#123;\n\ttest01();\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><p>运行结果：</p>\n<p>  <img src=\"/post/C-C++/C-C++_AllFriend/C-C++_Friend/Untitled%2022.png\" alt=\"Untitled%2022.png\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总结2：不要滥用运算符重载</p></blockquote>\n</li>\n</ul>\n<h2 id=\"2-2-左移运算符重载\"><a href=\"#2-2-左移运算符重载\" class=\"headerlink\" title=\"2.2.左移运算符重载\"></a>2.2.左移运算符重载</h2><p>作用：可以输出自定义数据类型</p>\n<details class=\"custom-details\">\n<summary>用系统带的<code>operator&lt;&lt;</code>进行重载</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person &#123;\n\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);\n\npublic:\n\n\tPerson(int a, int b)\n\t&#123;\n\t\tthis-&gt;m_A &#x3D; a;\n\t\tthis-&gt;m_B &#x3D; b;\n\t&#125;\n\n\t&#x2F;&#x2F;成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果\n\t&#x2F;&#x2F;void operator&lt;&lt;(Person&amp; p)&#123;\n\t&#x2F;&#x2F;&#125;\n\nprivate:\n\tint m_A;\n\tint m_B;\n&#125;;\n\n&#x2F;&#x2F;全局函数实现左移重载\n&#x2F;&#x2F;ostream对象只能有一个\nostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;\n\tout &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;\n\treturn out;\n&#125;\n\nvoid test() &#123;\n\n\tPerson p1(10, 20);\n\n\tcout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#x2F;&#x2F;链式编程\n&#125;\n\nint main() &#123;\n\n\ttest();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<pre><code>&gt; 总结：重载左移运算符配合友元可以实现输出自定义数据类型\n</code></pre>\n","text":"1.友元生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">1.友元</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">1.1.全局函数做友元</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">1.2.类做友元</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">1.3.成员函数做友元</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">2.运算符重载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">2.1.加号运算符重载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">2.2.左移运算符重载</span></a></li></ol></li></ol>","author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C++ 进阶知识","uid":"c4064ddb260b54731c75e982795ee11a","slug":"C-C++/C-C++_AllCore/C++_Core","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.781Z","comments":true,"path":"api/articles/C-C++/C-C++_AllCore/C++_Core.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/ACDGgxRZ8ot9BdF.jpg","text":"1.内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"C++ 类和对象（下）","uid":"930e385e7065f8662e317e6f8991f017","slug":"C-C++/C-C++_AllObject_2/C-C++_Object_2","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.803Z","comments":true,"path":"api/articles/C-C++/C-C++_AllObject_2/C-C++_Object_2.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/prXdeDCKqoYwUtR.jpg","text":"9.静态对象9.1.静态成员变量 类中静态成员变量对同一个类不同对象都是共用的，而且只能通过类外这种方法进行初始化 class Person &#123; &#x2F;&#x2F;静态成员变量特点： &#x2F;&#x2F;1 在编译阶段分配内存 &#x2F;&#x2F;2 类内...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}