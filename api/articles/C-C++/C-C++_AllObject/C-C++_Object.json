{"title":"C++ 类和对象（上）","uid":"2e64fdde2898213a1b1e2c6c7baa0826","slug":"C-C++/C-C++_AllObject/C-C++_Object","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.794Z","comments":true,"path":"api/articles/C-C++/C-C++_AllObject/C-C++_Object.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/wRh46NboxvGfuVk.jpg","content":"<h1 id=\"1-对象\"><a href=\"#1-对象\" class=\"headerlink\" title=\"1.对象\"></a>1.对象</h1><p>C++面向对象的三大特性为：封装、继承、多态</p>\n<p>C++认为万事万物都皆为对象，对象上有其属性和行为</p>\n<p>示例<strong>：</strong></p>\n<p> 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>\n<p> 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>\n<p> 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类</p>\n<h1 id=\"2-构造函数和析构函数\"><a href=\"#2-构造函数和析构函数\" class=\"headerlink\" title=\"2.构造函数和析构函数\"></a>2.构造函数和析构函数</h1><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>\n<p> 一个对象或者变量没有初始状态，对其使用后果是未知</p>\n<p> 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>\n<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>\n<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>\n<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>\n<ul>\n<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>\n<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>\n</ul>\n<hr>\n<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>\n<ol>\n<li><p>构造函数，没有返回值也不写void</p>\n</li>\n<li><p>函数名称与类名相同</p>\n</li>\n<li><p>构造函数可以有参数，因此可以发生重载</p>\n</li>\n</ol>\n<p>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</p>\n<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>\n<ol>\n<li><p>析构函数，没有返回值也不写void</p>\n</li>\n<li><p>函数名称与类名相同,在名称前加上符号 ~</p>\n</li>\n<li><p>析构函数不可以有参数，因此不可以发生重载</p>\n</li>\n<li><p>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</p>\n</li>\n</ol>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\n\t&#x2F;&#x2F;构造函数\n\tPerson()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;析构函数\n\t~Person()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson p;\n&#125;\n\nint main() &#123;\n\t\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h1 id=\"3-构造函数的分类及调用\"><a href=\"#3-构造函数的分类及调用\" class=\"headerlink\" title=\"3.构造函数的分类及调用\"></a>3.构造函数的分类及调用</h1><p>两种分类方式：</p>\n<p> 按参数分为： 有参构造和无参构造</p>\n<p> 按类型分为： 普通构造和拷贝构造</p>\n<details class=\"custom-details\">\n<summary>有参构造和无参构造</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\nint Age;\n\n\tPerson()\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用无参构造函数&quot; &lt;&lt; endl;\n\t&#125;\n\n\tPerson(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用有参构造函数&quot; &lt;&lt; endl;\n\t\tAge &#x3D; a;\n\t&#125;\n&#125;;</code></pre>\n</code></pre>\n</p>\n</details>\n<details class=\"custom-details\">\n<summary>普通构造和拷贝构造</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\n\tint Age;\n\n\tPerson(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用有参构造函数&quot; &lt;&lt; endl;\n\t\tAge &#x3D; a;\n\t&#125;\n\n\tPerson(const Person &amp;p)\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl;\n\t\tAge &#x3D; p.Age;\n\t&#125;\n\n&#125;;\n</code></pre>\n</code></pre>\n</p>\n</details>\n<p>三种调用方式：</p>\n<details class=\"custom-details\">\n<summary>1. 括号法</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Person p(50); &#x2F;&#x2F;调用有参构造函数\nPerson p1(p); &#x2F;&#x2F;调用拷贝构造函数</code></pre>\n</code></pre>\n</p>\n</details>\n<details class=\"custom-details\">\n<summary>2. 显示法</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Person p2 &#x3D; Person(60); &#x2F;&#x2F;调用有参构造函数\nPerson p3 &#x3D; Person(p2); &#x2F;&#x2F;调用拷贝构造函数</code></pre>\n</code></pre>\n</p>\n</details>\n<details class=\"custom-details\">\n<summary>3. 隐式转换法</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Person p4 &#x3D; 70;\nPerson p5 &#x3D; p4;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li>注意事项：<ol>\n<li>无参构造函数不能加括号 <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n&#x2F;&#x2F;Person p2();</code></pre>\n</li>\n<li>创建匿名对象 特点：当前行执行结束后，系统会立刻回收掉匿名对象 <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Person(60);\ncout &lt;&lt; &quot;aaaaa&quot; &lt;&lt; endl;</code></pre>\n 编译后结果：可以看见与正常创建对象不一样，正常创建对象调用析构函数是在函数结束是才会调用，但是创建匿名对象调用完构造函数就马上调用析构函数了 <img src=\"/post/C-C++/C-C++_AllObject/C-C++_Object/Untitled%204.png\" alt=\"Untitled%204.png\"></li>\n<li>拷贝构造函数 <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明:Person (p4) &#x3D;&#x3D;&#x3D; Person p4;\n&#x2F;&#x2F;Person(p4);</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"4-拷贝构造函数调用时机\"><a href=\"#4-拷贝构造函数调用时机\" class=\"headerlink\" title=\"4.拷贝构造函数调用时机\"></a>4.拷贝构造函数调用时机</h1><p>C++中拷贝构造函数调用时机通常有三种情况</p>\n<ol>\n<li><p><strong>使用一个已经创建完毕的对象来初始化一个新对象</strong></p>\n <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Person p(50); &#x2F;&#x2F;调用有参构造函数\nPerson p1(p); &#x2F;&#x2F;调用拷贝构造函数</code></pre>\n</li>\n<li><p><strong>值传递的方式给函数参数传值</strong></p>\n <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void test01(Person p)\n&#123;\n\tcout &lt;&lt; &quot;aaaaaa&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n\tPerson p;\n\ttest01(p);\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n<p> <strong>运行后结果如下：</strong></p>\n<ul>\n<li>首先执行创建 Person p，就会调用构造函数</li>\n<li>接着进入值传递函数里，会自动执行拷贝函数，也就是说 test01() 中对形参 p 进行修改对实际传入的对象成员不会有影响</li>\n<li>第一次调用析构函数是 test01() 函数结束而调用，第二次是在main函数里创建的对象调用</li>\n</ul>\n<p> <img src=\"/post/C-C++/C-C++_AllObject/C-C++_Object/Untitled%205.png\" alt=\"Untitled%205.png\"></p>\n</li>\n<li><p><strong>以值方式返回局部对象（与编译器有关，不绝对）</strong></p>\n<p>在教程里，当函数的返回值为类类型时，return 语句会返回一个对象，不过为了防止局部对象被销毁，也为了防止通过返回值修改原来的局部对象，编译器并不会直接返回这个对象，而是根据这个对象先创建出一个临时对象（匿名对象），再将这个临时对象返回。</p>\n<ul>\n<li><p>而创建临时对象的过程，就是以拷贝的方式进行的，会调用拷贝构造函数。</p>\n<p><img src=\"/post/C-C++/C-C++_AllObject/C-C++_Object/Untitled%206.png\" alt=\"Untitled%206.png\"></p>\n</li>\n<li><p>但是我的编译器不会调用拷贝函数来创建匿名对象，而是直接把局部创建对象返回</p>\n<p><img src=\"/post/C-C++/C-C++_AllObject/C-C++_Object/Untitled%207.png\" alt=\"Untitled%207.png\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"5-构造函数调用规则\"><a href=\"#5-构造函数调用规则\" class=\"headerlink\" title=\"5.构造函数调用规则\"></a>5.构造函数调用规则</h1><p>默认情况下，c++编译器至少给一个类添加3个函数</p>\n<p>1．默认构造函数(无参，函数体为空)</p>\n<p>2．默认析构函数(无参，函数体为空)</p>\n<p>3．默认拷贝构造函数，对属性进行值拷贝</p>\n<p>构造函数调用规则如下：</p>\n<ul>\n<li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li>\n<li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li>\n<li><strong>快速记忆</strong>：有高级的就不会提供低级：  <aside>\n  💡 拷贝构造函数→有参构造函数→无参/默认构造函数\n  \n  </aside>\n  </li>\n</ul>\n<h1 id=\"6-深拷贝与浅拷贝\"><a href=\"#6-深拷贝与浅拷贝\" class=\"headerlink\" title=\"6.深拷贝与浅拷贝\"></a>6.深拷贝与浅拷贝</h1><p><strong>深浅拷贝是面试经典问题，也是常见的一个坑</strong></p>\n<h2 id=\"6-1-浅拷贝\"><a href=\"#6-1-浅拷贝\" class=\"headerlink\" title=\"6.1.浅拷贝\"></a>6.1.浅拷贝</h2><details class=\"custom-details\">\n<summary>简单的赋值拷贝操作</summary>\n<p><pre><code>使用系统默认拷贝构造函数时，它是将一个对象上的内容原封不动的拷贝到另一个对象上。\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\n\tPerson()\n\t&#123;\n\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; 0;\n\t&#125;\n\tPerson(int age, int hight)\n\t&#123;\n\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; age;\n\t\tm_Hight &#x3D; new int(hight);\n\t&#125;\n\n\t~Person()\n\t&#123;\n\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n\t&#125;\n\npublic:\n\tint mAge;\n\tint *m_Hight;\n&#125;;</code></pre>\n</code></pre>\n<hr>\n<pre><code>在 main 函数上执行拷贝并打印 m_Hight 地址\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Person p(10, 160);\nPerson p1(p);\n\ncout &lt;&lt; p1.m_Hight &lt;&lt; endl;\ncout &lt;&lt; p.m_Hight &lt;&lt; endl;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><strong>运行结果：</strong><img src=\"/post/C-C++/C-C++_AllObject/C-C++_Object/Untitled%208.png\" alt=\"Untitled%208.png\">可以发现地址是一样的，那是因为在创建对象 p 时，进行的是用户在堆区申请内存空间操作，这时候 m_Hight 地址是指向堆区那个内存，接着进行拷贝时，p1 的 m_Hight 也是完全拷贝 p 的 m_Hight，于是地址都是一致，都是指向同一个内存，这种叫浅拷贝。</li>\n</ul>\n<h2 id=\"6-2深拷贝\"><a href=\"#6-2深拷贝\" class=\"headerlink\" title=\"6.2深拷贝\"></a>6.2深拷贝</h2><details class=\"custom-details\">\n<summary>在堆区重新申请空间，进行拷贝操作</summary>\n<p><pre><code>在上诉的类里添加用户自定义拷贝构造函数\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Person(const Person &amp;p)\n\t&#123;\n\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; p.mAge;\n\t\tm_Hight &#x3D; new int(*p.m_Hight);\n\t&#125;</code></pre>\n</code></pre>\n<hr>\n<pre><code>在 main 函数上执行拷贝并打印 m_Hight 地址\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Person p(10, 160);\nPerson p1(p);\n\ncout &lt;&lt; p1.m_Hight &lt;&lt; endl;\ncout &lt;&lt; p.m_Hight &lt;&lt; endl;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><strong>运行结果：</strong><img src=\"/post/C-C++/C-C++_AllObject/C-C++_Object/Untitled%209.png\" alt=\"Untitled%209.png\">可以发现地址不一样了，因为执行了我们定义的拷贝构造函数，给 p1 也申请了一个内存，于是就没有指向同一个内存了，这种叫深拷贝。</li>\n</ul>\n<h2 id=\"6-3-总结\"><a href=\"#6-3-总结\" class=\"headerlink\" title=\"6.3.总结\"></a>6.3.总结</h2><p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>\n<h1 id=\"7-初始化列表\"><a href=\"#7-初始化列表\" class=\"headerlink\" title=\"7.初始化列表\"></a>7.初始化列表</h1><p><strong>作用：</strong><br>C++提供了初始化列表语法，用来初始化属性</p>\n<details class=\"custom-details\">\n<summary><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\n\tPerson(int a, int b, int c) : mAge(a), m_Hight(b), llll(c)\n  &#123;\n     cout &lt;&lt; &quot;Person属性初始化成功&quot; &lt;&lt; endl;\n  &#125;\n\npublic:\n\tconst int mAge;\n\tint m_Hight;\n\tint llll;\n&#125;;\n\nint main()\n&#123;\n\tPerson p(10,20,30);\n\n\tcout &lt;&lt; p.mAge &lt;&lt; endl;\n\tcout &lt;&lt; p.m_Hight &lt;&lt; endl;\n\tcout &lt;&lt; p.llll &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<p>这种方式也可以初始化常量的属性</p>\n<hr>\n<details class=\"custom-details\">\n<summary>我的编译器还支持一种方法</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\n\t&#x2F;&#x2F; Person(int a, int b, int c) : mAge(a), m_Hight(b), llll(c)&#123;&#125;\n\npublic:\n\tconst int mAge;\n\tint m_Hight;\n\tint llll;\n&#125;;\n\nint main()\n&#123;\n\tPerson p(&#123;10,20,30&#125;);\n\n\tcout &lt;&lt; p.mAge &lt;&lt; endl;\n\tcout &lt;&lt; p.m_Hight &lt;&lt; endl;\n\tcout &lt;&lt; p.llll &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<p>这种方法也可以对常量进行初始化</p>\n<h1 id=\"8-类对象作为类成员\"><a href=\"#8-类对象作为类成员\" class=\"headerlink\" title=\"8.类对象作为类成员\"></a>8.类对象作为类成员</h1><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class A &#123;&#125;\nclass B\n&#123;\n    A a；\n&#125;</code></pre>\n\n<p>在这种情况下，构造对象时会先构造 A类对象，之后在构造 B类对象；而析构时先析构 B类对象，之后在析构 A类对象。</p>\n<h1 id=\"参考与致谢\"><a href=\"#参考与致谢\" class=\"headerlink\" title=\"参考与致谢\"></a>参考与致谢</h1><ul>\n<li><p><a href=\"http://c.biancheng.net/cpp/biancheng/view/2968.html\">C++类和对象的概念</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/ay-a/p/10415808.html\">C++拷贝构造函数的调用时机</a></p>\n</li>\n</ul>\n","text":"1.对象C++面向对象的三大特性为：封装、继承、多态 C++认为万事万物都皆为对象，对象上有其属性和行为 示例： 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌… 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调… 具有相同性...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1.对象</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">2.构造函数和析构函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">3.构造函数的分类及调用</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">4.拷贝构造函数调用时机</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99\"><span class=\"toc-text\">5.构造函数调用规则</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">6.深拷贝与浅拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-%E6%B5%85%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">6.1.浅拷贝</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">6.2深拷贝</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">6.3.总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">7.初始化列表</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98\"><span class=\"toc-text\">8.类对象作为类成员</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E4%B8%8E%E8%87%B4%E8%B0%A2\"><span class=\"toc-text\">参考与致谢</span></a></li></ol>","author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C++ 类和对象（下）","uid":"930e385e7065f8662e317e6f8991f017","slug":"C-C++/C-C++_AllObject_2/C-C++_Object_2","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.803Z","comments":true,"path":"api/articles/C-C++/C-C++_AllObject_2/C-C++_Object_2.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/prXdeDCKqoYwUtR.jpg","text":"9.静态对象9.1.静态成员变量 类中静态成员变量对同一个类不同对象都是共用的，而且只能通过类外这种方法进行初始化 class Person &#123; &#x2F;&#x2F;静态成员变量特点： &#x2F;&#x2F;1 在编译阶段分配内存 &#x2F;&#x2F;2 类内...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}