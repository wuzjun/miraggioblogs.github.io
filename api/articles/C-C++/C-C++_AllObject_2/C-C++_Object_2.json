{"title":"C++ 类和对象（下）","uid":"930e385e7065f8662e317e6f8991f017","slug":"C-C++/C-C++_AllObject_2/C-C++_Object_2","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.803Z","comments":true,"path":"api/articles/C-C++/C-C++_AllObject_2/C-C++_Object_2.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/prXdeDCKqoYwUtR.jpg","content":"<h1 id=\"9-静态对象\"><a href=\"#9-静态对象\" class=\"headerlink\" title=\"9.静态对象\"></a>9.静态对象</h1><h2 id=\"9-1-静态成员变量\"><a href=\"#9-1-静态成员变量\" class=\"headerlink\" title=\"9.1.静态成员变量\"></a>9.1.静态成员变量</h2><details class=\"custom-details\">\n<summary>类中静态成员变量对同一个类不同对象都是共用的，而且只能通过类外这种方法进行初始化</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\n\t&#x2F;&#x2F;静态成员变量特点：\n\t&#x2F;&#x2F;1 在编译阶段分配内存\n\t&#x2F;&#x2F;2 类内声明，类外初始化\n\t&#x2F;&#x2F;3 所有对象共享同一份数据\n\npublic:\n\tstatic int a;\n  &#x2F;&#x2F;初始化也不行\n\t&#x2F;&#x2F; Person() : a(10) &#123;&#125;  \n&#125;;\n\nint Person ::a &#x3D; 10;</code></pre>\n</code></pre>\n</p>\n</details>\n<ol>\n<li><p>通过对象访问静态变量（必须先对其类外初始化才可以尽享访问）</p>\n<ul>\n<li><p>先创建一个对象，之后在对其赋值。</p>\n</li>\n<li><p>但是由于静态成员变量是所有对象共享同一份数据，因此创建另一个对象在修改变量，会影响其他对象的变量。</p>\n  <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int main()\n&#123;\n\t&#x2F;&#x2F;创建一个对象 p\n\tPerson p;\n\t&#x2F;&#x2F;对其静态成员变量进行赋值\n\tp.a &#x3D; 100;\n\t&#x2F;&#x2F;打印静态成员变量\n\tcout &lt;&lt; p.a &lt;&lt; endl;\n\n\t&#x2F;&#x2F;创建一个对象 p1\n\tPerson p1;\n\t&#x2F;&#x2F;对其静态成员变量进行赋值\n\tp1.a &#x3D; 1000;\n\t&#x2F;&#x2F;打印静态成员变量\n\tcout &lt;&lt; p.a &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre></li>\n<li><p><strong>运行结果：</strong></p>\n<p> <img src=\"/post/C-C++/C-C++_AllObject_2/C-C++_Object_2/Untitled%2010.png\" alt=\"Untitled%2010.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>通过类名访问静态变量（必须先对其类外初始化才可以尽享访问）</p>\n<ul>\n<li>在静态成员变量初始化后，可以不创建对象，直接通过类名来访问到变量，但是不能进行赋值操作。  <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int main()\n&#123;\n\t\n\tcout &lt;&lt; Person ::a &lt;&lt; endl;\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</li>\n<li><strong>运行结果（我初始化给了10）：</strong> <img src=\"/post/C-C++/C-C++_AllObject_2/C-C++_Object_2/Untitled%2011.png\" alt=\"Untitled%2011.png\"></li>\n</ul>\n</li>\n<li><p>静态成员变量也可以有私有权限</p>\n<ul>\n<li>若静态成员变量为私有权限，则外部一样没有访问权限，只有类外初始化能运行。于是想赋值和打印只能通过自定义函数再由外部调用。  <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\n\t&#x2F;&#x2F;静态成员变量特点：\n\t&#x2F;&#x2F;1 在编译阶段分配内存\n\t&#x2F;&#x2F;2 类内声明，类外初始化\n\t&#x2F;&#x2F;3 所有对象共享同一份数据\n\npublic:\n\tvoid lll(int Get_a)\n\t&#123;\n\t\ta &#x3D; Get_a;           &#x2F;&#x2F;赋值操作\n\t\tcout &lt;&lt; a &lt;&lt; endl;   &#x2F;&#x2F;打印变量\n\t&#125;\n\nprivate:\n\tstatic int a;\n&#125;;\n\nint Person ::a &#x3D; 10;  &#x2F;&#x2F;必须初始化操作！！！！！\n\nint main()\n&#123;\n\tPerson p;\n\tp.lll(100);\n\n\tPerson p1;\n\tp1.lll(1000);\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</li>\n<li><strong>运行结果：</strong> <img src=\"/post/C-C++/C-C++_AllObject_2/C-C++_Object_2/Untitled%2012.png\" alt=\"Untitled%2012.png\"></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"9-2-静态成员函数\"><a href=\"#9-2-静态成员函数\" class=\"headerlink\" title=\"9.2.静态成员函数\"></a>9.2.静态成员函数</h2><details class=\"custom-details\">\n<summary>与静态成员变量有点类似，程序共享一个函数，而且函数内只能访问静态变量</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\n\t&#x2F;&#x2F;静态成员函数特点：\n\t&#x2F;&#x2F;1 程序共享一个函数\n\t&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量\n\npublic:\n\tstatic void fun()\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用fun&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;</code></pre>\n</code></pre>\n</p>\n</details>\n<ol>\n<li><p>通过对象访问静态函数</p>\n<ul>\n<li>创建一个对象，直接调用。  <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int main()\n&#123;\n\tPerson p;\n\tp.fun();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</li>\n<li><strong>运行结果：</strong> <img src=\"/post/C-C++/C-C++_AllObject_2/C-C++_Object_2/Untitled%2013.png\" alt=\"Untitled%2013.png\"></li>\n</ul>\n</li>\n<li><p>通过类名访问静态函数</p>\n<ul>\n<li>从这里可以验证程序共享一个函数的特点  <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int main()\n&#123;\n\tPerson::fun();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</li>\n<li><strong>运行结果：</strong> <img src=\"/post/C-C++/C-C++_AllObject_2/C-C++_Object_2/Untitled%2014.png\" alt=\"Untitled%2014.png\"></li>\n</ul>\n</li>\n<li><p>函数内只能访问静态变量</p>\n<ul>\n<li>上诉说了，静态函数有程序共享一个函数的特点。假如要访问非静态变量，它无法知道该变量具体在哪个对象里。  <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\n\t&#x2F;&#x2F;静态成员函数特点：\n\t&#x2F;&#x2F;1 程序共享一个函数\n\t&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量\n\npublic:\n\tstatic void fun()\n\t&#123;\n\t\tcout &lt;&lt; a &lt;&lt; endl;\n\t\t&#x2F;&#x2F;无法知道 b 属于什么对象\n\t\t&#x2F;&#x2F; cout &lt;&lt; b &lt;&lt; endl;\n\t\tcout &lt;&lt; &quot;调用fun&quot; &lt;&lt; endl;\n\t&#125;\n\nprivate:\n\tstatic int a;\n\tint b;\n&#125;;\n\nint Person ::a &#x3D; 10;\n\nint main()\n&#123;\n\tPerson::fun();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</li>\n</ul>\n</li>\n<li><p>静态成员函数也可以有私有权限</p>\n<ul>\n<li>若静态成员函数为私有权限，则外部一样没有访问权限。  <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\n\t&#x2F;&#x2F;静态成员函数特点：\n\t&#x2F;&#x2F;1 程序共享一个函数\n\t&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量\n\nprivate:\n\tstatic void fun()\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用fun&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\nint main()\n&#123;\n\t&#x2F;&#x2F;访问不到\n\t&#x2F;&#x2F;Person::fun();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"10-成员变量和成员函数分开存储\"><a href=\"#10-成员变量和成员函数分开存储\" class=\"headerlink\" title=\"10.成员变量和成员函数分开存储\"></a>10.成员变量和成员函数分开存储</h1><ul>\n<li>在C++中，类内的成员变量和成员函数分开存储</li>\n<li>只有非静态成员变量才属于类的对象上</li>\n</ul>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person &#123;\npublic:\n\tPerson() &#123;\n\t\tmA &#x3D; 0;\n\t&#125;\n\t&#x2F;&#x2F;非静态成员变量占对象空间\n\tint mA;\n\t&#x2F;&#x2F;静态成员变量不占对象空间\n\tstatic int mB; \n\t&#x2F;&#x2F;函数也不占对象空间，所有函数共享一个函数实例\n\tvoid func() &#123;\n\t&#125;\n\t&#x2F;&#x2F;静态成员函数也不占对象空间\n\tstatic void sfunc() &#123;\n\t&#125;\n&#125;;\n\nint main() &#123;\n\n\tcout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><strong>运行结果：</strong>  <img src=\"/post/C-C++/C-C++_AllObject_2/C-C++_Object_2/Untitled%2015.png\" alt=\"Untitled%2015.png\"></li>\n</ul>\n<details class=\"custom-details\">\n<summary>需要特别注意的是：C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置。每个空对象也应该有一个独一无二的内存地址。</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person &#123;\n\n&#125;;\n\nint main() &#123;\n\n\tcout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><strong>运行结果：</strong>  <img src=\"/post/C-C++/C-C++_AllObject_2/C-C++_Object_2/Untitled%2016.png\" alt=\"Untitled%2016.png\"></li>\n</ul>\n<h1 id=\"11-this指针概念\"><a href=\"#11-this指针概念\" class=\"headerlink\" title=\"11.this指针概念\"></a>11.this指针概念</h1><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>\n<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>\n<hr>\n<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>\n<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>\n<hr>\n<ul>\n<li>this指针是隐含每一个非静态成员函数内的一种指针</li>\n<li>this指针不需要定义，直接使用即可</li>\n<li>this指针的本质是指针常量，指针的指向是不可修改的</li>\n</ul>\n<p>this指针的用途：</p>\n<ul>\n<li>当形参和成员变量同名时，可用this指针来区分</li>\n</ul>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\n\tint Age;\n  \n  &#x2F;&#x2F;此时形参名与变量名重名了，不用 this 指针编译器无法区分\n\tvoid GetData(int Age)\n\t&#123;\n\t\tthis-&gt;Age &#x3D; Age;\n\t&#125;\n\n&#125;;\n\nint main()\n&#123;\n\tPerson p1;\n\n\tp1.GetData(10);\n\n\tcout &lt;&lt; p1.m_Age &lt;&lt; endl;\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>\n</ul>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\n\tint Age;\n\n\tvoid GetData(int Age)\n\t&#123;\n\t\tthis-&gt;Age &#x3D; Age;\n\t&#125;\n\n  &#x2F;&#x2F;这里返回值用到了引用语法\n\tPerson &amp;PersonAddData(int Data)\n\t&#123;\n\t\tm_Age +&#x3D; Data;\n\t\treturn *this;  &#x2F;&#x2F;实际返回的是当前对象\n\t&#125;\n&#125;;\n\nint main()\n&#123;\n\tPerson p2;\n\n\tp2.GetData(10);\n\n\tp2.PersonAddData(10).PersonAddData(10).PersonAddData(10);\n\n\tcout &lt;&lt; p2.m_Age &lt;&lt; endl;\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<details class=\"custom-details\">\n<summary>如果返回值也可以写成下面这种形式：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Person PersonAddData(int Data)\n\t&#123;\n\t\tm_Age +&#x3D; Data;\n\t\treturn *this;\n\t&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><strong>运行的结果:</strong>  <img src=\"/post/C-C++/C-C++_AllObject_2/C-C++_Object_2/Untitled%2017.png\" alt=\"Untitled%2017.png\"></li>\n</ul>\n<p>正常运行结果应该是40，在这里只有20。原因是没有了引用，编译器会在下一次调用的时候创建一个新的对象，而不是返回我们要的对象</p>\n<pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;这里其实只调用过一次 p2，后面两次都是创建了新的对象 \np2.PersonAddData(10).PersonAddData(10).PersonAddData(10);</code></pre>\n</code></pre>\n<h1 id=\"12-空指针访问成员函数\"><a href=\"#12-空指针访问成员函数\" class=\"headerlink\" title=\"12.空指针访问成员函数\"></a>12.空指针访问成员函数</h1><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>\n<details class=\"custom-details\">\n<summary>如果用到this指针，需要加以判断保证代码的健壮性</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;空指针访问成员函数\nclass Person\n&#123;\npublic:\n\tvoid ShowClassName()\n\t&#123;\n\t\tcout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid ShowPerson()\n\t&#123;\n\t\tif (this &#x3D;&#x3D; NULL) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tcout &lt;&lt; mAge &lt;&lt; endl;\n\t&#125;\n\npublic:\n\tint mAge;\n&#125;;\n\nint main()\n&#123;\n\tPerson *p1 &#x3D; NULL;\n\n  p1-&gt;ShowClassName(); &#x2F;&#x2F;空指针，可以调用成员函数\n\tp1-&gt;ShowPerson();  &#x2F;&#x2F;但是如果成员函数中用到了this指针，就不可以了\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><strong>运行结果：</strong>  <img src=\"/post/C-C++/C-C++_AllObject_2/C-C++_Object_2/Untitled%2018.png\" alt=\"Untitled%2018.png\"></li>\n</ul>\n<p>可以看到字符串可以被打印出来，但是由于是空指针，成员变量为空。</p>\n<h1 id=\"13-const修饰成员函数\"><a href=\"#13-const修饰成员函数\" class=\"headerlink\" title=\"13.const修饰成员函数\"></a>13.const修饰成员函数</h1><h2 id=\"13-1-常函数：\"><a href=\"#13-1-常函数：\" class=\"headerlink\" title=\"13.1.常函数：\"></a>13.1.常函数：</h2><ul>\n<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>\n<li>常函数内不可以修改成员属性</li>\n<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>\n</ul>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\n\tint m_age;\n\tmutable int m_b;\n\n\tvoid ShowDataConst() const\n\t&#123;\n\t\t&#x2F;&#x2F;m_age 在常函数里无法被修改，但是能被访问\n\t\t&#x2F;&#x2F; m_age &#x3D; 10;\n\n\t\t&#x2F;&#x2F;m_b 加上了 mutable 关键字，在常函数里可以被修改\n\t\tm_b &#x3D; 5;\n\t\tcout &lt;&lt; m_age &lt;&lt; endl;\n\t\tcout &lt;&lt; m_b &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nint main()\n&#123;\n\tPerson p;\n\n\tp.ShowData();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><strong>运行结果（m_age 没有进行赋值，默认是16）：</strong>  <img src=\"/post/C-C++/C-C++_AllObject_2/C-C++_Object_2/Untitled%2019.png\" alt=\"Untitled%2019.png\"></li>\n</ul>\n<h2 id=\"13-2-常对象：\"><a href=\"#13-2-常对象：\" class=\"headerlink\" title=\"13.2.常对象：\"></a>13.2.常对象：</h2><ul>\n<li>声明对象前加const称该对象为常对象</li>\n<li>常对象只能调用常函数</li>\n<li>若类里有成员变量，则需要构造函数初始化才不会报错</li>\n</ul>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\n\t&#x2F;&#x2F;m_age只能在常函数里访问,不能被修改\n\tint m_age;\n\tmutable int m_b;\n\n\t&#x2F;&#x2F;成员变量必须使用构造函数初始化，否则会报错\n\tPerson()\n\t&#123;\n\t\tm_age &#x3D; 0;\n\t\tm_b &#x3D; 0;\n\t&#125;\n\n\tvoid ShowDataConst() const\n\t&#123;\n\t\tcout &lt;&lt; &quot;nfujksdgbhjk,s&quot; &lt;&lt; endl;\n\t\tcout &lt;&lt; m_age &lt;&lt; endl;\n\n\t&#125;\n\n\t&#x2F;&#x2F;在常对象里无法被调用\n\tvoid ShowData()\n\t&#123;\n\t\tcout &lt;&lt; &quot;nfujksdg&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nint main()\n&#123;\n\tconst Person p;\n\n\tp.ShowDataConst();\n\t&#x2F;&#x2F;无法调用\n\t&#x2F;&#x2F; p.ShowData();\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><strong>运行结果：</strong>  <img src=\"/post/C-C++/C-C++_AllObject_2/C-C++_Object_2/Untitled%2020.png\" alt=\"Untitled%2020.png\"></li>\n</ul>\n","text":"9.静态对象9.1.静态成员变量 类中静态成员变量对同一个类不同对象都是共用的，而且只能通过类外这种方法进行初始化 class Person &#123; &#x2F;&#x2F;静态成员变量特点： &#x2F;&#x2F;1 在编译阶段分配内存 &#x2F;&#x2F;2 类内...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#9-%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">9.静态对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-1-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">9.1.静态成员变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-2-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">9.2.静态成员函数</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#10-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">10.成员变量和成员函数分开存储</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#11-this%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">11.this指针概念</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#12-%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">12.空指针访问成员函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#13-const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">13.const修饰成员函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-1-%E5%B8%B8%E5%87%BD%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">13.1.常函数：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-2-%E5%B8%B8%E5%AF%B9%E8%B1%A1%EF%BC%9A\"><span class=\"toc-text\">13.2.常对象：</span></a></li></ol></li></ol>","author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C++ 友元与运算符","uid":"bf1ca1b83272793e4c3d135bd1c7f7c7","slug":"C-C++/C-C++_AllFriend/C-C++_Friend","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.792Z","comments":true,"path":"api/articles/C-C++/C-C++_AllFriend/C-C++_Friend.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/6be4hEBZS9xPn5A.jpg","text":"1.友元生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}