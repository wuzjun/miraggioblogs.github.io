{"title":"C++ 进阶知识","uid":"c4064ddb260b54731c75e982795ee11a","slug":"C-C++/C-C++_AllCore/C++_Core","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.781Z","comments":true,"path":"api/articles/C-C++/C-C++_AllCore/C++_Core.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/ACDGgxRZ8ot9BdF.jpg","content":"<h1 id=\"1-内存分区模型\"><a href=\"#1-内存分区模型\" class=\"headerlink\" title=\"1.内存分区模型\"></a><strong>1.内存分区模型</strong></h1><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>\n<ul>\n<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>\n<li>全局区：存放全局变量和静态变量以及常量</li>\n<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>\n<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>\n</ul>\n<p>其中代码区和全局区是在程序编译之前，栈区和堆区是在程序编译之后。</p>\n<h2 id=\"1-1-程序运行前\"><a href=\"#1-1-程序运行前\" class=\"headerlink\" title=\"1.1.程序运行前\"></a>1.1.程序运行前</h2><p>在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>\n<h3 id=\"1-1-1-代码区：\"><a href=\"#1-1-1-代码区：\" class=\"headerlink\" title=\"1.1.1.代码区：\"></a>1.1.1.代码区：</h3><ul>\n<li>存放 CPU 执行的机器指令</li>\n<li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li>\n<li>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</li>\n</ul>\n<h3 id=\"1-1-2-全局区：\"><a href=\"#1-1-2-全局区：\" class=\"headerlink\" title=\"1.1.2.全局区：\"></a>1.1.2.全局区：</h3><ul>\n<li>全局变量和静态变量存放在此</li>\n<li>全局区还包含了常量区, 字符串常量和其他常量也存放在此</li>\n<li>该区域的数据在程序结束后由操作系统释放</li>\n</ul>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code>一.字符串常量\n\n直接打印 &quot;hello world&quot; 就是一个字符串常量，存储在全局区中。\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;</code></pre>\n\n二.静态变量\n\n一般来说，只要是局部变量（在函数里创建的变量）就不是放在全局区内，但是静态变量除外，它既可以在函数外，也可以在函数内创建，而且都属于全局区。\n</code></pre>\n</p>\n</details>\n<p>总结：</p>\n<ul>\n<li>C++中在程序运行前分为全局区和代码区</li>\n<li>代码区特点是共享和只读</li>\n<li>全局区中存放全局变量、静态变量、常量</li>\n<li>常量区中存放 const修饰的全局常量 和 字符串常量</li>\n</ul>\n<h2 id=\"1-2-程序运行后\"><a href=\"#1-2-程序运行后\" class=\"headerlink\" title=\"1.2.程序运行后\"></a>1.2.程序运行后</h2><h3 id=\"1-2-1-栈区：\"><a href=\"#1-2-1-栈区：\" class=\"headerlink\" title=\"1.2.1.栈区：\"></a>1.2.1.栈区：</h3><p> 由编译器自动分配释放, 存放函数的参数值,局部变量等</p>\n<p> 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int * func()\n&#123;\n\tint a &#x3D; 10; \n\treturn &amp;a;  &#x2F;&#x2F;返回了局部变量的地址，此操作是属于违法操作\n&#125;\n\nint main() &#123;\n\n\tint *p &#x3D; func();\n  &#x2F;&#x2F;函数结束后系统会自动释放局部变量，这是 *p 已经不是我们要的了\n\n\tcout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;第一次是正常的，是因为编译器自动保存了一次值\n\tcout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;第二次就出现乱码了\n  &#x2F;&#x2F;总体来说，就不要返回局部变量的地址\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h3 id=\"1-2-2-堆区\"><a href=\"#1-2-2-堆区\" class=\"headerlink\" title=\"1.2.2.堆区\"></a>1.2.2.堆区</h3><p>由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>\n<p> 在C++中主要利用new在堆区开辟内存</p>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int* func()\n&#123;\n\tint* a &#x3D; new int(10);  &#x2F;&#x2F;C++ 内通过 new 创建堆区的内存（C 一般用 malloc）\n\treturn a;              &#x2F;&#x2F;返回的其实是创建堆区的地址，而不是上诉栈区的地址\n&#125;\n\nint main() &#123;\n\n\tint *p &#x3D; func();\n\n\tcout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;第一次正常\n\tcout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;第二次也是正常\n    \n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<p><strong>总结：</strong></p>\n<p>堆区数据由程序员管理开辟和释放</p>\n<p>堆区数据利用new关键字进行开辟内存</p>\n<h2 id=\"1-3-new-操作符\"><a href=\"#1-3-new-操作符\" class=\"headerlink\" title=\"1.3.new 操作符\"></a>1.3.new 操作符</h2><details class=\"custom-details\">\n<summary>new 会向堆区申请内存</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int *func(void)\n&#123;\n\tint *a &#x3D; new int(-1000);  &#x2F;&#x2F;创建一个值为 -1000 的 int 类型变量的内存\n\treturn a;\n&#125;\n\nint *func1(void)\n&#123;\n\tint *arr &#x3D; new int[10];   &#x2F;&#x2F;创建一个元素为 10 的 int 类型数组的内存\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tarr[i] &#x3D; 100 + i;       &#x2F;&#x2F;给每一个元素赋值\n\t&#125;\n\treturn arr;\n&#125;\n\nint main()\n&#123;\n\n\tint *p &#x3D; func();\n\tint *arr1 &#x3D; func1();\n\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tcout &lt;&lt; arr1[i] &lt;&lt; endl;\n\t&#125;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h1 id=\"2-引用\"><a href=\"#2-引用\" class=\"headerlink\" title=\"2.引用\"></a><strong>2.引用</strong></h1><h2 id=\"2-1-引用的基本使用\"><a href=\"#2-1-引用的基本使用\" class=\"headerlink\" title=\"2.1.引用的基本使用\"></a>2.1.引用的基本使用</h2><p><strong>作用：</strong> 给变量起别名</p>\n<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>\n<p><img src=\"/post/C-C++/C-C++_AllCore/C++_Core/Untitled.png\" alt=\"Untitled.png\"></p>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int main() &#123;\n\n\tint a &#x3D; 10;\n\tint &amp;b &#x3D; a;\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\n\tb &#x3D; 100;\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li>运行结果：  <img src=\"/post/C-C++/C-C++_AllCore/C++_Core/Untitled%201.png\" alt=\"Untitled%201.png\"></li>\n</ul>\n<h2 id=\"2-2-引用注意事项\"><a href=\"#2-2-引用注意事项\" class=\"headerlink\" title=\"2.2.引用注意事项\"></a>2.2.引用注意事项</h2><ul>\n<li>引用必须初始化</li>\n<li>引用在初始化后，不可以改变</li>\n</ul>\n<p><img src=\"/post/C-C++/C-C++_AllCore/C++_Core/Untitled%202.png\" alt=\"Untitled%202.png\"></p>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">\tint main() &#123;\n\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\t&#x2F;&#x2F;int &amp;c; &#x2F;&#x2F;错误，引用必须初始化\n\tint &amp;c &#x3D; a; &#x2F;&#x2F;一旦初始化后，就不可以更改\n\tc &#x3D; b; &#x2F;&#x2F;这是赋值操作，不是更改引用\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\tcout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;结果都是20</code></pre>\n</code></pre>\n</p>\n</details>\n<h2 id=\"2-3-引用做函数参数\"><a href=\"#2-3-引用做函数参数\" class=\"headerlink\" title=\"2.3.引用做函数参数\"></a>2.3.引用做函数参数</h2><ul>\n<li><strong>作用：</strong><br>  函数传参时，可以利用引用的技术让形参修饰实参</li>\n<li><strong>优点：</strong><br>  可以简化指针修改实参</li>\n</ul>\n<details class=\"custom-details\">\n<summary>引用做函数参数的话更改是会直接改变输入变量，与传地址产生的效果是一样的。</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void mySwap03(int&amp; a, int&amp; b) &#123;\n\tint temp &#x3D; a;\n\ta &#x3D; b;\n\tb &#x3D; temp;\n&#125;\n\nint main() &#123;\n\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\n\tmySwap03(a, b);\n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h2 id=\"2-4-引用做函数返回值\"><a href=\"#2-4-引用做函数返回值\" class=\"headerlink\" title=\"2.4.引用做函数返回值\"></a>2.4.引用做函数返回值</h2><p>作用：引用是可以作为函数的返回值存在的</p>\n<p>注意：<strong>不要返回局部变量引用</strong></p>\n<details class=\"custom-details\">\n<summary>用法：函数调用作为左值</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;返回局部变量引用\nint&amp; test01() &#123;\n\tint a &#x3D; 10; &#x2F;&#x2F;局部变量\n\treturn a;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;不能返回局部变量的引用\n\tint&amp; ref &#x3D; test01();\n\tcout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;同上诉原理是一样的，返回局部变量的引用操作是属于非法操作的</code></pre>\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;返回静态变量引用\nint&amp; test02() &#123;\n\tstatic int a &#x3D; 20;  &#x2F;&#x2F;属于全局区的内存\n\treturn a;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;如果函数做左值，那么必须返回引用\n\tint&amp; ref2 &#x3D; test02();\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\n\ttest02() &#x3D; 1000;  &#x2F;&#x2F;相当于 a &#x3D; 1000\n\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li>运行结果：  <img src=\"/post/C-C++/C-C++_AllCore/C++_Core/Untitled%203.png\" alt=\"Untitled%203.png\">  可以看出确实是成功改变了变量值。</li>\n</ul>\n<h2 id=\"2-5-引用的本质\"><a href=\"#2-5-引用的本质\" class=\"headerlink\" title=\"2.5.引用的本质\"></a>2.5.引用的本质</h2><details class=\"custom-details\">\n<summary>本质：引用的本质在 C++ 内部实现是一个指针常量.</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;发现是引用，转换为 int* const ref &#x3D; &amp;a;\nvoid func(int&amp; ref)&#123;\n\tref &#x3D; 100; &#x2F;&#x2F; ref是引用，转换为*ref &#x3D; 100\n&#125;\nint main()&#123;\n\tint a &#x3D; 10;\n    \n    &#x2F;&#x2F;自动转换为 int* const ref &#x3D; &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n\tint&amp; ref &#x3D; a; \n\tref &#x3D; 20; &#x2F;&#x2F;内部发现ref是引用，自动帮我们转换为: *ref &#x3D; 20;\n    \n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\n    \n\tfunc(a);\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>\n<h2 id=\"2-6-常量引用\"><a href=\"#2-6-常量引用\" class=\"headerlink\" title=\"2.6.常量引用\"></a>2.6.常量引用</h2><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>\n<details class=\"custom-details\">\n<summary>在函数形参列表中，可以加const修饰形参，防止形参改变实参</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;引用使用的场景，通常用来修饰形参\nvoid showValue(const int&amp; v)     &#x2F;&#x2F;加了 const 之后，该函数不能再对传进去的变量进行赋值，否则就会出现误操作\n&#123;\n\t&#x2F;&#x2F;v +&#x3D; 10;\n\tcout &lt;&lt; v &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;int&amp; ref &#x3D; 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t&#x2F;&#x2F;加入const就可以了，编译器优化代码，int temp &#x3D; 10; const int&amp; ref &#x3D; temp;\n\tconst int&amp; ref &#x3D; 10;\n\n\t&#x2F;&#x2F;ref &#x3D; 100;  &#x2F;&#x2F;加入const后不可以修改变量\n\tcout &lt;&lt; ref &lt;&lt; endl;\n\n\t&#x2F;&#x2F;函数中利用常量引用防止误操作修改实参\n\tint a &#x3D; 10;\n\tshowValue(a);\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h1 id=\"3-函数提高\"><a href=\"#3-函数提高\" class=\"headerlink\" title=\"3.函数提高\"></a><strong>3.函数提高</strong></h1><h2 id=\"3-1-函数默认参数\"><a href=\"#3-1-函数默认参数\" class=\"headerlink\" title=\"3.1.函数默认参数\"></a>3.1.函数默认参数</h2><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>\n<details class=\"custom-details\">\n<summary>语法：<code>返回值类型 函数名 （参数= 默认值）&#123;&#125;</code></summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int func(int a, int b &#x3D; 10, int c &#x3D; 10) &#123;\n\treturn a + b + c;\n&#125;\n\n&#x2F;&#x2F;1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\n&#x2F;&#x2F;2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\n&#x2F;&#x2F;声明和定义只能有一个是形参有默认值，不然编译器报错\nint func2(int a &#x3D; 10, int b &#x3D; 10);\nint func2(int a, int b) &#123;\n\treturn a + b;\n&#125;\n\nint main() &#123;\n\n\tcout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(100) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h2 id=\"3-2-函数占位参数\"><a href=\"#3-2-函数占位参数\" class=\"headerlink\" title=\"3.2.函数占位参数\"></a>3.2.函数占位参数</h2><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>\n<p>占位参数也可以添加默认参数</p>\n<details class=\"custom-details\">\n<summary><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;函数占位参数 ，占位参数也可以有默认参数\nvoid func(int a, int) &#123;\n\tcout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\tfunc(10,10); &#x2F;&#x2F;占位参数必须填补\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h2 id=\"3-3-函数重载\"><a href=\"#3-3-函数重载\" class=\"headerlink\" title=\"3.3.函数重载\"></a>3.3.函数重载</h2><ul>\n<li><strong>作用：</strong> 函数名可以相同，提高复用性</li>\n</ul>\n<p><strong>函数重载满足条件：</strong></p>\n<ul>\n<li>同一个作用域下（例如目前函数都写在 main 函数外面，属于全局函数，就在同一个作用域下）</li>\n<li>函数名称相同</li>\n<li>函数参数<strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>\n</ul>\n<p><strong>注意:</strong> 函数的返回值不可以作为函数重载的条件</p>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void func()\n&#123;\n\tcout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int a)\n&#123;\n\tcout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int a ,double b)\n&#123;\n\tcout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(double a ,int b)\n&#123;\n\tcout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n  &#x2F;&#x2F;这些都可以被调用，只要参数不一样，或者参数顺序不一样就没问题\n\tfunc();  \n\tfunc(10);\n\tfunc(10, 3.14);\n\tfunc(3.14, 10);\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h2 id=\"3-4-函数重载注意事项\"><a href=\"#3-4-函数重载注意事项\" class=\"headerlink\" title=\"3.4.函数重载注意事项\"></a>3.4.函数重载注意事项</h2><ul>\n<li>引用作为重载条件</li>\n<li>函数重载碰到函数默认参数</li>\n</ul>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;1、引用作为重载条件\n\nvoid func(int &amp;a)\n&#123;\n\tcout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;\n&#125;\n\nvoid func(const int &amp;a)\n&#123;\n\tcout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;2、函数重载碰到函数默认参数\n\nvoid func2(int a, int b &#x3D; 10)\n&#123;\n\tcout &lt;&lt; &quot;func2(int a, int b &#x3D; 10) 调用&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2(int a)\n&#123;\n\tcout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\t\n\tint a &#x3D; 10;\n\tfunc(a); &#x2F;&#x2F;调用无const\n\tfunc(10);&#x2F;&#x2F;调用有const\n\n\t&#x2F;&#x2F;func2(10); &#x2F;&#x2F;碰到默认参数产生歧义，需要避免\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h1 id=\"参考与致谢\"><a href=\"#参考与致谢\" class=\"headerlink\" title=\"参考与致谢\"></a>参考与致谢</h1><ul>\n<li><a href=\"https://www.cnblogs.com/gaochaooo/archive/2009/09/03/1559764.html\">C++内存分配秘籍</a></li>\n</ul>\n","text":"1.内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">1.内存分区模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%89%8D\"><span class=\"toc-text\">1.1.程序运行前</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-1-%E4%BB%A3%E7%A0%81%E5%8C%BA%EF%BC%9A\"><span class=\"toc-text\">1.1.1.代码区：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-2-%E5%85%A8%E5%B1%80%E5%8C%BA%EF%BC%9A\"><span class=\"toc-text\">1.1.2.全局区：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%90%8E\"><span class=\"toc-text\">1.2.程序运行后</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-1-%E6%A0%88%E5%8C%BA%EF%BC%9A\"><span class=\"toc-text\">1.2.1.栈区：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-2-%E5%A0%86%E5%8C%BA\"><span class=\"toc-text\">1.2.2.堆区</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-new-%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">1.3.new 操作符</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">2.引用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.1.引用的基本使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%BC%95%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">2.2.引用注意事项</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2.3.引用做函数参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">2.4.引用做函数返回值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">2.5.引用的本质</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">2.6.常量引用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98\"><span class=\"toc-text\">3.函数提高</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">3.1.函数默认参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E5%87%BD%E6%95%B0%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">3.2.函数占位参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">3.3.函数重载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">3.4.函数重载注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E4%B8%8E%E8%87%B4%E8%B0%A2\"><span class=\"toc-text\">参考与致谢</span></a></li></ol>","author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C++ 面向对象三大特征","uid":"685a5f7f3a39655d238f8071cde76eaf","slug":"C-C++/C-C++_AllFeature/C-C++_Feature","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.785Z","comments":true,"path":"api/articles/C-C++/C-C++_AllFeature/C-C++_Feature.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/tXfKMiY9yCQpqB4.jpg","text":"1.封装1.1.封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装意义一： 在设计类的时候，属性和行为写在一起，表现事物 语法： class 类名&#123; 访问权限： 属性 / 行为 &#125...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"C++ 友元与运算符","uid":"bf1ca1b83272793e4c3d135bd1c7f7c7","slug":"C-C++/C-C++_AllFriend/C-C++_Friend","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.792Z","comments":true,"path":"api/articles/C-C++/C-C++_AllFriend/C-C++_Friend.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/6be4hEBZS9xPn5A.jpg","text":"1.友元生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}