{"title":"C++ 面向对象三大特征","uid":"685a5f7f3a39655d238f8071cde76eaf","slug":"C-C++/C-C++_AllFeature/C-C++_Feature","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.785Z","comments":true,"path":"api/articles/C-C++/C-C++_AllFeature/C-C++_Feature.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/tXfKMiY9yCQpqB4.jpg","content":"<h1 id=\"1-封装\"><a href=\"#1-封装\" class=\"headerlink\" title=\"1.封装\"></a><strong>1.封装</strong></h1><h2 id=\"1-1-封装的意义\"><a href=\"#1-1-封装的意义\" class=\"headerlink\" title=\"1.1.封装的意义\"></a>1.1.封装的意义</h2><p>封装是C++面向对象三大特性之一</p>\n<p>封装的意义：</p>\n<ul>\n<li>将属性和行为作为一个整体，表现生活中的事物</li>\n<li>将属性和行为加以权限控制</li>\n</ul>\n<details class=\"custom-details\">\n<summary>封装意义一：</summary>\n<p>在设计类的时候，属性和行为写在一起，表现事物</p>\n<p><strong>语法：</strong><br>    <code>class 类名&#123; 访问权限： 属性 / 行为 &#125;;</code></p>\n<ul>\n<li><p>*示例1：**设计一个圆类，求圆的周长</p>\n  <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#define PI 3.14159\n\n&#x2F;&#x2F;创建一个类\nclass Circle\n&#123;\npublic: &#x2F;&#x2F;访问权限  公共的权限\n\t&#x2F;&#x2F;属性\n\tint m_r;\n\n\t&#x2F;&#x2F;行为\n\t&#x2F;&#x2F;计算圆的周长\n\tdouble calculateZC()\n\t&#123;\n\t\treturn 2 * PI * m_r;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;创建对象\nCircle c1;\n\nint main()\n&#123;\n\tc1.m_r &#x3D; 10;\n\n\tcout &lt;&lt; c1.calculateZC() &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</li>\n<li><p>其中：</p>\n<ul>\n<li>所有属性和行为都属于成员</li>\n<li>属性的别名：成员属性 成员变量</li>\n<li>行为的别名：成员函数 成员方法</li>\n</ul>\n</li>\n</ul>\n<p>而且行为里都是正常的函数的写法，既可以像上诉一样，也可以有函数参数。\n</details>\n<details class=\"custom-details\">\n<summary>封装意义二：</summary>\n<p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>\n<p>访问权限有三种：</p>\n<ol>\n<li><p>public 公共权限（成员在类内和类外都可以被访问）</p>\n</li>\n<li><p>protected 保护权限（成员数据在类内可以被访问，类外不可以；儿子可以访问父亲中的保护内容）</p>\n</li>\n<li><p>private 私有权限（成员数据在类内可以被访问，类外不可以；儿子不可以访问父亲中的保护内容）</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>示例：</strong></p>\n  <pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class CAN\n&#123;\nprivate: &#x2F;&#x2F;访问权限 私人权限\n&#x2F;&#x2F;属性\n\n&#x2F;&#x2F;行为\nprotected: &#x2F;&#x2F;访问权限 保护权限\n&#x2F;&#x2F;属性\nint Can_Receive;\n\npublic: &#x2F;&#x2F;访问权限  公共的权限\n&#x2F;&#x2F;属性\nint Can_Data;\n\n&#x2F;&#x2F;行为\nvoid Can_ReceiveData(int Can_ReceiveDatas)\n&#123;\n\tCan_Receive &#x3D; Can_ReceiveDatas;\n\tCan_Data &#x3D; Can_Receive;\n&#125;\n&#125;;\n\n&#x2F;&#x2F;创建对象\nCAN c1;\n\nint main()\n&#123;\n\tc1.Can_ReceiveData(10);\n\n\tcout &lt;&lt; c1.Can_Data &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</p>\n</details>\n</li>\n</ul>\n<h2 id=\"1-2-struct-和-class-区别\"><a href=\"#1-2-struct-和-class-区别\" class=\"headerlink\" title=\"1.2.struct 和 class 区别\"></a>1.2.struct 和 class 区别</h2><p>在C++中 struct和class唯一的区别就在于 默认的访问权限不同</p>\n<p>区别：</p>\n<ul>\n<li>struct 默认权限为公共</li>\n<li>class 默认权限为私有</li>\n</ul>\n<h2 id=\"1-3-成员属性设置为私有\"><a href=\"#1-3-成员属性设置为私有\" class=\"headerlink\" title=\"1.3.成员属性设置为私有\"></a>1.3.成员属性设置为私有</h2><ul>\n<li><strong>优点1：</strong> 将所有成员属性设置为私有，可以自己控制读写权限</li>\n<li><strong>优点2：</strong> 对于写权限，我们可以检测数据的有效性</li>\n</ul>\n<p>通过公开访问区域自定义读写函数，对私人数据进行操作。（例如上诉的封装意义二的代码例子）</p>\n<h1 id=\"2-继承\"><a href=\"#2-继承\" class=\"headerlink\" title=\"2.继承\"></a><strong>2.继承</strong></h1><p><strong>继承是面向对象三大特性之一</strong></p>\n<p>有些类与类之间存在特殊的关系，例如下图中：</p>\n<p><img src=\"/post/C-C++/C-C++_AllFeature/C-C++_Feature/Untitled%2023.png\" alt=\"Untitled%2023.png\"></p>\n<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>\n<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>\n<h2 id=\"2-1-继承的基本语法\"><a href=\"#2-1-继承的基本语法\" class=\"headerlink\" title=\"2.1.继承的基本语法\"></a>2.1.继承的基本语法</h2><details class=\"custom-details\">\n<summary><strong>语法：</strong></summary>\n<p>    <code>class 类A : public 类B</code></p>\n<pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Buliding\n&#123;\npublic:\n    Buliding() : m_a(10) &#123;&#125;\n    int m_a;\n    void ShowBase(void)\n    &#123;\n    cout &lt;&lt; &quot;地基&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;继承上面的\nclass Bedroom : public Buliding\n&#123;\npublic:\n    void ShowBedroom(void)\n    &#123;\n    cout &lt;&lt; &quot;卧室&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Bedroom bedroom;\n    cout &lt;&lt; bedroom.m_a &lt;&lt; endl;\n    bedroom.ShowBase();\n    bedroom.ShowBedroom();\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><p>运行结果：</p>\n<p> <img src=\"/post/C-C++/C-C++_AllFeature/C-C++_Feature/Untitled%2024.png\" alt=\"Untitled%2024.png\"></p>\n</li>\n<li><p><strong>总结：</strong></p>\n<ol>\n<li><p>继承的好处：可以减少重复的代码</p>\n</li>\n<li><p>A 类称为子类 或 派生类</p>\n</li>\n<li><p>B 类称为父类 或 基类</p>\n</li>\n<li><p><strong>派生类中的成员，包含两大部分</strong>：</p>\n<ul>\n<li><p>一类是从基类继承过来的，一类是自己增加的成员。</p>\n</li>\n<li><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-继承方式\"><a href=\"#2-2-继承方式\" class=\"headerlink\" title=\"2.2 继承方式\"></a>2.2 继承方式</h2><p>继承的语法：<br>    <code>class 子类 : 继承方式 父类</code></p>\n<p><strong>继承方式一共有三种：</strong></p>\n<ul>\n<li>公共继承</li>\n<li>保护继承</li>\n<li>私有继承</li>\n</ul>\n<p><img src=\"/post/C-C++/C-C++_AllFeature/C-C++_Feature/Untitled%2025.png\" alt=\"Untitled%2025.png\"></p>\n<h2 id=\"2-3-继承中的对象模型\"><a href=\"#2-3-继承中的对象模型\" class=\"headerlink\" title=\"2.3.继承中的对象模型\"></a>2.3.继承中的对象模型</h2><details class=\"custom-details\">\n<summary><strong>问题：</strong> 从父类继承过来的成员，哪些属于子类对象中？</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Base\n&#123;\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C; &#x2F;&#x2F;私有成员只是被隐藏了，但是还是会继承下去\n&#125;;\n\n&#x2F;&#x2F;公共继承\nclass Son :public Base\n&#123;\npublic:\n\tint m_D;\n&#125;;\n\nvoid test01()\n&#123;\n\tcout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote>\n<h2 id=\"2-4-继承中构造和析构顺序\"><a href=\"#2-4-继承中构造和析构顺序\" class=\"headerlink\" title=\"2.4.继承中构造和析构顺序\"></a>2.4.继承中构造和析构顺序</h2><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>\n<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Base \n&#123;\npublic:\n\tBase()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t~Base()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass Son : public Base\n&#123;\npublic:\n\tSon()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t~Son()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\tSon s;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote>\n<h2 id=\"2-5-继承同名成员处理方式\"><a href=\"#2-5-继承同名成员处理方式\" class=\"headerlink\" title=\"2.5.继承同名成员处理方式\"></a>2.5.继承同名成员处理方式</h2><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>\n<ul>\n<li>访问子类同名成员 直接访问即可</li>\n<li>访问父类同名成员 需要加作用域</li>\n</ul>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Base &#123;\npublic:\n\tBase()\n\t&#123;\n\t\tm_A &#x3D; 100;\n\t&#125;\n\n\tvoid func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid func(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\n\t&#125;\n\npublic:\n\tint m_A;\n&#125;;\n\nclass Son : public Base &#123;\npublic:\n\tSon()\n\t&#123;\n\t\tm_A &#x3D; 200;\n\t&#125;\n\n\t&#x2F;&#x2F;当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n\t&#x2F;&#x2F;如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\n\tvoid func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\nvoid test01()\n&#123;\n\tSon s;\n\n\tcout &lt;&lt; &quot;Son下的m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base下的m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\n\ts.func();\n\ts.Base::func();\n\ts.Base::func(10);\n\n&#125;\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\treturn EXIT_SUCCESS;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><p>总结：</p>\n<ol>\n<li><p>子类对象可以直接访问到子类中同名成员</p>\n</li>\n<li><p>子类对象加作用域可以访问到父类同名成员</p>\n</li>\n<li><p>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-6-继承同名静态成员处理方式\"><a href=\"#2-6-继承同名静态成员处理方式\" class=\"headerlink\" title=\"2.6.继承同名静态成员处理方式\"></a>2.6.继承同名静态成员处理方式</h2><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>\n<p>静态成员和非静态成员出现同名，处理方式一致</p>\n<ul>\n<li>访问子类同名成员 直接访问即可</li>\n<li>访问父类同名成员 需要加作用域</li>\n</ul>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Base &#123;\npublic:\n\tstatic void func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;\n\t&#125;\n\tstatic void func(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;\n\t&#125;\n\n\tstatic int m_A;\n&#125;;\n\nint Base::m_A &#x3D; 100;\n\nclass Son : public Base &#123;\npublic:\n\tstatic void func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;\n\t&#125;\n\tstatic int m_A;\n&#125;;\n\nint Son::m_A &#x3D; 200;\n\n&#x2F;&#x2F;同名成员属性\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;通过对象访问\n\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\n\tSon s;\n\tcout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\n\t&#x2F;&#x2F;通过类名访问\n\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;同名成员函数\nvoid test02()\n&#123;\n\t&#x2F;&#x2F;通过对象访问\n\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\n\tSon s;\n\ts.func();\n\ts.Base::func();\n\n\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\n\tSon::func();\n\tSon::Base::func();\n\t&#x2F;&#x2F;出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\n\tSon::Base::func(100);\n&#125;\nint main() &#123;\n\n\t&#x2F;&#x2F;test01();\n\ttest02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote>\n<h2 id=\"2-7-多继承语法\"><a href=\"#2-7-多继承语法\" class=\"headerlink\" title=\"2.7.多继承语法\"></a>2.7.多继承语法</h2><p>C++允许<strong>一个类继承多个类</strong></p>\n<p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>\n<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>\n<p><strong>C++实际开发中不建议用多继承</strong></p>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Base1 &#123;\npublic:\n\tBase1()\n\t&#123;\n\t\tm_A &#x3D; 100;\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\nclass Base2 &#123;\npublic:\n\tBase2()\n\t&#123;\n\t\tm_A &#x3D; 200;  &#x2F;&#x2F;开始是m_B 不会出问题，但是改为mA就会出现不明确\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\n&#x2F;&#x2F;语法：class 子类：继承方式 父类1 ，继承方式 父类2 \nclass Son : public Base2, public Base1 \n&#123;\npublic:\n\tSon()\n\t&#123;\n\t\tm_C &#x3D; 300;\n\t\tm_D &#x3D; 400;\n\t&#125;\npublic:\n\tint m_C;\n\tint m_D;\n&#125;;\n\n&#x2F;&#x2F;多继承容易产生成员同名的情况\n&#x2F;&#x2F;通过使用类名作用域可以区分调用哪一个基类的成员\nvoid test01()\n&#123;\n\tSon s;\n\tcout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;\n\tcout &lt;&lt; s.Base1::m_A &lt;&lt; endl;\n\tcout &lt;&lt; s.Base2::m_A &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote>\n<h2 id=\"2-8-菱形继承\"><a href=\"#2-8-菱形继承\" class=\"headerlink\" title=\"2.8.菱形继承\"></a>2.8.菱形继承</h2><h3 id=\"2-8-1-菱形继承概念：\"><a href=\"#2-8-1-菱形继承概念：\" class=\"headerlink\" title=\"2.8.1.菱形继承概念：\"></a>2.8.1.菱形继承概念：</h3><ul>\n<li>两个派生类继承同一个基类</li>\n<li>又有某个类同时继承者两个派生类</li>\n<li>这种继承被称为菱形继承，或者钻石继承</li>\n</ul>\n<h3 id=\"2-8-2-典型的菱形继承案例：\"><a href=\"#2-8-2-典型的菱形继承案例：\" class=\"headerlink\" title=\"2.8.2.典型的菱形继承案例：\"></a>2.8.2.典型的菱形继承案例：</h3><p><img src=\"/post/C-C++/C-C++_AllFeature/C-C++_Feature/Untitled%2026.png\" alt=\"Untitled%2026.png\"></p>\n<h3 id=\"2-8-3-菱形继承问题：\"><a href=\"#2-8-3-菱形继承问题：\" class=\"headerlink\" title=\"2.8.3.菱形继承问题：\"></a>2.8.3.菱形继承问题：</h3><ol>\n<li><p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p>\n</li>\n<li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>\n</li>\n</ol>\n<details class=\"custom-details\">\n<summary>示例：</summary>\n<p><pre><code><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Animal\n&#123;\npublic:\n\tint m_Age;\n&#125;;\n\n&#x2F;&#x2F;继承前加virtual关键字后，变为虚继承\n&#x2F;&#x2F;此时公共的父类Animal称为虚基类\nclass Sheep : virtual public Animal &#123;&#125;;\nclass Tuo   : virtual public Animal &#123;&#125;;\nclass SheepTuo : public Sheep, public Tuo &#123;&#125;;\n\nvoid test01()\n&#123;\n\tSheepTuo st;\n\tst.Sheep::m_Age &#x3D; 100;\n\tst.Tuo::m_Age &#x3D; 200;\n\n\tcout &lt;&lt; &quot;st.Sheep::m_Age &#x3D; &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\n\tcout &lt;&lt; &quot;st.Tuo::m_Age &#x3D; &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;\n\tcout &lt;&lt; &quot;st.m_Age &#x3D; &quot; &lt;&lt; st.m_Age &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<ul>\n<li><p>总结：</p>\n<ol>\n<li><p>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</p>\n</li>\n<li><p>利用虚继承可以解决菱形继承问题</p>\n</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"3-多态\"><a href=\"#3-多态\" class=\"headerlink\" title=\"3.多态\"></a><strong>3.多态</strong></h1><h2 id=\"3-1-多态的基本概念\"><a href=\"#3-1-多态的基本概念\" class=\"headerlink\" title=\"3.1.多态的基本概念\"></a>3.1.多态的基本概念</h2><p><strong>多态是C++面向对象三大特性之一</strong></p>\n<p>多态分为两类：</p>\n<ul>\n<li><p>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</p>\n</li>\n<li><p>动态多态: 派生类和虚函数实现运行时多态</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>静态多态和动态多态区别：</strong></p>\n<ol>\n<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>\n<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>\n</ol></blockquote>\n<h1 id=\"参考与致谢\"><a href=\"#参考与致谢\" class=\"headerlink\" title=\"参考与致谢\"></a>参考与致谢</h1><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/122300099\">（虚继承）防止重复内容的有趣操作</a></li>\n</ul>\n","text":"1.封装1.1.封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装意义一： 在设计类的时候，属性和行为写在一起，表现事物 语法： class 类名&#123; 访问权限： 属性 / 行为 &#125...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">1.封装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89\"><span class=\"toc-text\">1.1.封装的意义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-struct-%E5%92%8C-class-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.2.struct 和 class 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89\"><span class=\"toc-text\">1.3.成员属性设置为私有</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">2.继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">2.1.继承的基本语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.2 继承方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2.3.继承中的对象模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">2.4.继承中构造和析构顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.5.继承同名成员处理方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.6.继承同名静态成员处理方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-7-%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">2.7.多继承语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-8-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">2.8.菱形继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-8-1-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E6%A6%82%E5%BF%B5%EF%BC%9A\"><span class=\"toc-text\">2.8.1.菱形继承概念：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-8-2-%E5%85%B8%E5%9E%8B%E7%9A%84%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E6%A1%88%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">2.8.2.典型的菱形继承案例：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-8-3-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">2.8.3.菱形继承问题：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">3.多态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.1.多态的基本概念</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E4%B8%8E%E8%87%B4%E8%B0%A2\"><span class=\"toc-text\">参考与致谢</span></a></li></ol>","author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C/C++ 基础编程","uid":"c7ad3fc5539e6e09e5d04802e792c17b","slug":"C-C++/C-C++_AllBasis/C-C++_basis","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.774Z","comments":true,"path":"api/articles/C-C++/C-C++_AllBasis/C-C++_basis.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/kBnujWr2NEJPVDI.jpg","text":"1.C++入门1.1.Hello world#include &lt;iostream&gt; using namespace std; int main() &#123; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; ...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"C++ 进阶知识","uid":"c4064ddb260b54731c75e982795ee11a","slug":"C-C++/C-C++_AllCore/C++_Core","date":"2022-01-24T10:49:36.000Z","updated":"2022-02-08T15:35:49.781Z","comments":true,"path":"api/articles/C-C++/C-C++_AllCore/C++_Core.json","keywords":null,"cover":"https://s2.loli.net/2022/01/24/ACDGgxRZ8ot9BdF.jpg","text":"1.内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"Language","slug":"Language","count":8,"path":"api/categories/Language.json"}],"tags":[{"name":"C/C++","slug":"C-C","count":7,"path":"api/tags/C-C.json"}],"author":{"name":"Miraggio","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/23/kntF9TEBOyHquwV.png","link":"https://lapzjfit.site","description":"喜欢研究奇奇怪怪的技术&游戏宅","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}