[{"id":"8dcbc6cb855fac456d3a1f9c3e231440","title":"Webots 序章","content":"1. 引言随着机器人技术的不断发展，越来越多的小伙伴开始成为机器人开发者。在机器人开发过程中，经常需要对机器人进行仿真，这时就需要用到机器人仿真软件。机器人仿真软件用于机器人算法的设计、测试和验证，可以大幅提高开发者的工作效率，降低开发成本。\nWebots 是一款优秀的机器人仿真软件，功能强大，易于使用。但由于 Webots 开源时间比较晚，在国内的市场占有率较低，目前使用 Webots 的开发者还不是很多。\nWebots 由 Cyberbotics 公司开发，是一款开源的多平台机器人仿真软件，为机器人的建模、编程和仿真提供了完整的开发环境。Webots 内核基于开源动力学引擎 ODE 和 OpenGL，可以在 Windows，Linux 和 macOS 上运行，并且支持多种编程语言(C/C++，Python，Java，MATLAB)。\nWebots简单易用，文档齐全，支持多种类型的机器人，是一款非常优秀的机器人仿真平台软件。以下视频是Webots示例项目的实机演示视频，大家可以直观了解以下Webots。\n\n2. Webots与其他机器人仿真平台除了webots外，机器人仿真软件还有许多，较常用的如 V-rep，Gazebo，Matlab，Adams 等。V-rep 是一款非常受欢迎的开源机器人仿真软件，由Coppelia robotics 公司开发，内置多种不同的动力学引擎。V-rep 与Webots 一样支持多种类型的机器人仿真，支持多种不同的编程语言，支持Windows，Linux，macOS操作系统。Gazebo 也是一款开源免费的机器人仿真器，与 ROS 兼容，常用于 ROS 中对机器人仿真，但 Gazebo 易用不高。Matlab 机器人工具箱也可用于机器人仿真，但对某些复杂的机器人进行仿真时操作起来很复杂，不易用。Adams 是 MSC 公司的机械系统动力学仿真软件，多用于汽车行业。用于机器人动力学仿真时常与 matlab 联合仿真，易用性较差。\n与上述机器人仿真软件相比，Webots 最大的优势在于功能强大的同时又简单易用。一方面 Webots 专为机器人仿真设计，功能强大。可直接建模，编程，仿真。仿真过程具有较好的视觉效果，且易于导出展示。另一方面Webots 非常易用，学习成本低。支持多平台，多语言，具有完善的文档和示例用于参考。\n但Webots也有许多缺点。首先，Webots 建模过程比较繁琐，对于闭链结构机器人的支持不够完善，使用 webots 仿真并联机器人会比较麻烦。其次，Webots 仿真过程数据不能自动保存，可视化做得也不是很好，使用较为不便。最后，Webots 的中文支持也很一般，控制台不支持中文，软件界面中文翻译不完整，文档也没有中文版。\n各位小伙伴在选择机器人仿真软件时可根据不同的仿真平台特点按需选择，仿真软件只是工具，适合自己项目、能提高开发效率、降低开发成本的工具才是好工具。\n3. Webots简介3.1. Webots 是什么？Webots 是一款开源的多平台机器人仿真软件，为机器人的建模、编程和仿真提供了完整的开发环境。\nWebots 由 Cyberbotics 公司开发，是一款优秀的开源多平台机器人仿真软件，为机器人的建模、编程和仿真提供了完整的开发环境。Webots 开源免费、简单易用、文档齐全并且支持多种类型的机器人。\n3.2. Webots 能做什么？Webots 的主要功能是机器人的建模、控制与仿真，用于开发、测试和验证机器人算法。其内核基于 ODE 引擎，动力学仿真效果较为真实。\nWebots 支持多种不同类型的机器人仿真，如工业机械臂，轮式机器人，足式机器人，履带式机器人，汽车，无人机，水下机器人，航天器等。Webots 支持多种虚拟传感器，如相机，雷达，力传感器，位置传感器，陀螺仪，惯性单元，GPS 等。Webots 还支持多种复杂环境的模拟，如室内，室外，崎岖路面，空中环境，水下环境等。\n3.3. Webots 适合哪些用户？Webots主要用于机器人算法的快速开发验证，开源版本可免费使用，因此特别适合研究人员（如高校教师和学生），机器人爱好者和机器人研发工程师。\n但是Webots作为通用仿真平台功能也有许多局限性，建议大家在做更深入的机器人研究时结合实际情况使用其他工具。\n3.4. 学习和使用 Webots 需要具备哪些知识Webots 简单易学，你只需要具备基础的机器人知识（数学、机器人学、力学等）和基础的编程知识（C/C++，python，java，matlab任意一种）即可上手。\n4. Webots 下载与安装官网下载地址\nWebots 的安装十分简单：\n①双击 Webots 安装文件\n②选择 Install for all users\n\n③选择你要安装的路径，一路点击 next\n\n④安装完成。\n\n5. 学习目录\n\n\n\n\n\n\n\n\n该篇章主要分为三大部分：\n\nWebots 基础篇：介绍常用集成部件使用\nWebots 应用篇：搭建仿真的过程与结果\nWebots 踩坑篇：建模仿真时遇到的问题\n\n5.1. Webots 基础篇\nWebots软件界面介绍\n\n简单模型仿真\n\nWebots节点问题\n\n第一个仿真模型\n\n仿真环境的变量\n\n初识控制器\n\n复合固体与物理属性\n\n简单四轮机器人\n\n补充篇\n\n\n5.2. Webots 应用篇\n键盘控制&amp;控制台打印数据(以C语言为例)\n\n创建三全向轮小车\n\n使用 URDF2WEBOTS 导入 SolidWorks 装配体\n\n添加摄像头\n\n添加IMU传感器\n\n\n参考与致谢\nwebots基础教学视频\n\nWebots机器人仿真简易教程\n\n\n","slug":"Webots/list/Webots序章","date":"2022-01-31T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"02a3b3fcb111561eec2596647d9ebddc","title":"HAL-cubeMX 序章","content":"1.HAL库的某些学前概念HAL库对于刚刚接触的新人来说，确实不太友好，毕竟你已经看惯了标准库，然后突然间让你改掉你标准库的配置环境，重组一个环境之后再给你进行配置，难免会有一些不习惯。我刚开始接触的时候也是各种不习惯，然后越用越香（不是）。\n总之，HAL库和标准库有着本质上的不同，无论是配置上还是从封装上，以下是我个人认为的几个比较突出的不同的地方。\n1.1.突出特点：\n配置方便，但是刚刚开始可能会不适应。\n  HAL的配置确实是方便的不行，也可以有效的防止换板子时候的尴尬（串口很好改），一个模板出来也就十几分钟的事情，但是由于封装上和标准库确实有本质上的不同，所以需要多看。\n\n\n\n多出来的概念：启动函数（或者说标准库 Init使能函数 的分离）\n  HAL中存在着被称为启动函数的东西，HAL生成的代码只会帮你把BSP层的代码全部配置好，但是实际上要不要使能这个函数，是由你来决定的。\n\n\n\n自动分配引脚，是优点也是缺点\n  为什么那么说的，是因为有时候自动分配的引脚会和你板子原理图或者手册的引脚不太同，如果你这个时候不仔细看的话就会出大问题，但是大部分情况是和原理图上面的默认引脚是相同的。优点在于也能很快的看出对应的引脚之前有什么冲突或者关系，不会和标准库一样引脚冲突了也不知道。\n\n\n\n中断配置集合封装\n  个人建议就是好好看一次，HAL自带的中断处理函数有清空标志位和判断标志位，以及判断是否出错的各种各样的功能。因为这个所以以后配置中断不用在每次都很仔细的去看自己配置的到时是什么更新brabrabra要不要对应brabrabra什么的，也算是比较的方便。\n\n\n\n生成格式不等于固化格式\n  虽然是HAL库确实给你生成了一个格式，但是这不代表你可以完全忽略你原来的自己的格式，HAL只是相当于帮你配置好了对应的BSP，和简化封装了一下函数。\n\n\n\n格式变了，内容不变\n  实际上还是使用你标准库的知识，只不过是变量名称和封装变了，但是内容物还是原汁原味的。\n\n\n1.2.注意事项：\n\n\n\n\n\n\n\n\n\n学习 HAL 库之前，需要有 STM32 等单片机的基础。\n使用 HAL 库需要搭配 cubeMX 软件生成。\n\n2.学习目录2.1.基础篇\nProject Manager中的基础属性配置\n\n单片机初始化，RCC时钟树完整配置的方式和详细过程\n\nCM中GPIO的配置，使用，以及启动方法\n\nCM中的模块启动函数，中断配置，配置技巧，方式格式\n\nCM中USART的配置，以及启动方法\n\nCM中的DMA配置简述\n\nCM中USART和DMA的实际关系（DR16为例）\n\nHAL_UART中断代码的理解\n\nCM中TIM定时器的配置，以及启动方法\n\nCM中CAN的配置，使用，以及启动方法\n\nCM中Freertos配置，使用\n\nFreertos中队列的使用\n\n\n2.2.拓展篇\n移植官方DSP库\n\nFlash使用\n\nPWR 电源管理系统\n\n看门狗\n\nRNG\n\n\n参考与致谢在此感谢师兄的帮助以及各种开源参考文章。\n\nAnshinin’s Working house\n\n","slug":"cubeMX/cubeMX序章","date":"2022-01-27T12:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"fb03c6ff7a7697bc30c623660715d012","title":"C/C++ 序章","content":"1.目录\n\n\n\n\n\n\n\n\n该篇章主要分为两大部分：\n\nC/C++ 基础知识：该部分是 C/C++ 通用的基础内容\nC++ 核心知识：涉及 C++ 类和对象内容\n\n1.1.C/C++ 基础知识该部分的内容只是涉及到平时易错以及遗忘点，用的频繁的语法请移步到如黑马等专门的教程中了解。\nC/C++ 基础编程\n1.2.C++ 核心知识该部分的内容比较多，因此分成了好几个章节。\n\nC++ 进阶知识\n\nC++ 类和对象（上）\n\nC++ 类和对象（下）\n\nC++ 友元与运算符\n\nC++ 面向对象三大特征\n\n\n参考与致谢之后的章节主要是参考以下教程：\n\n黑马 C/C++ 系列教程\n\n","slug":"C-C++/C-C++_list","date":"2022-01-25T10:49:36.000Z","categories_index":"Language","tags_index":"C/C++","author_index":"Miraggio"},{"id":"3d9eb6234c196ee164f02c2904330bfd","title":"Windows python3.8环境安装","content":"第一步下载python3.8。\n第二步双击安装，记得勾选红框框！\n不勾选的话，安装完需要自己配置环境变量\n\n等待即可\n\n第三步完成安装，检验是否安装成功 ctrl+R打开运行，输入cmd打开命令行\n\n\n命令行中运行输入python测试是否运行(若电脑中同时有python2和python3则输入python3来指定运行的版本)  \n输入pip –version（或pip3 –version）查看pip的版本\n\n安装完成！\n参考与致谢https://blog.csdn.net/Toufahaizai/article/details/102930444\n","slug":"Python/安装/Windows python3 8环境安装","date":"2022-02-02T12:49:36.000Z","categories_index":"Language","tags_index":"python","author_index":"Miraggio"},{"id":"b44f2b4c0ef151e2d4963b4e3c1a4d2e","title":"键盘控制&控制台打印数据(以C语言为例)","content":"1.键盘控制官方对于键盘有详细的解释\n我们常用就是以下函数，以及使用键盘控制时需要包含的头文件\n#include &lt;webots&#x2F;keyboard.h&gt;\n\n&#x2F;&#x2F;使能键盘控制\nvoid wb_keyboard_enable(int sampling_period);\n&#x2F;&#x2F;失能键盘控制\nvoid wb_keyboard_disable();\n&#x2F;&#x2F;获取键盘控制采样时间\nint wb_keyboard_get_sampling_period();\n&#x2F;&#x2F;获取键盘按键\nint wb_keyboard_get_key();\n\n1.1. 使用方法\n包含头文件\n#include &lt;webots&#x2F;keyboard.h&gt;\n在循环外使能键盘控制\nwb_keyboard_enable(TIME_STEP);\n循环内获取键盘按键，存储到变量中\nint key &#x3D; wb_keyboard_get_key();\n判断获取了键盘按键\nswitch (key)\n    &#123;\n    case &#39;A&#39;:\n      Vx &#x3D; 0.0f;\n      VOmega &#x3D; -5.0f;\n     break;\n   case &#39;D&#39;:\n      Vx &#x3D; 0.0f;\n     VOmega &#x3D; 5.0f;\n     break;\n   case &#39;S&#39;:\n     Vx &#x3D; -5.0f;\n     VOmega &#x3D; 0.0f;\n      break;\n    case &#39;W&#39;:\n     Vx &#x3D; 5.0f;\n     VOmega &#x3D; 0.0f;\n     break;\n   default:\n     Vx &#x3D; 0.0f;\n     VOmega &#x3D; 0.0f;\n    &#125;\n\n2.控制台打印数据在旧版本是可以直接用printf来直接打印数据，但是新版本需要加上一句话才能打印\nprintf(&quot;%d\\n&quot;,key);\nfflush(stdout);\n\n参考与致谢Webots 键盘使用\n","slug":"Webots/Application/键盘控制&控制台打印数据(以C语言为例)","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"1e8431c3de1805ae06496ba42e6842a2","title":"Webots 软件界面介绍","content":"以 Webots 官方示例场景 ROBOTIS OP3 为例，Webots 软件界面如下所示：\n\n软件界面包含以下几个部分：\n1. 三维场景显示界面打开软件，正中间即为三维场景显示界面。\n\n显示界面可实时交互，鼠标左键点击场景中的物体，物体将被选中，选中后默认显示物体的坐标系和碰撞边界(白色线框)，点选坐标系，可以对物体进行平移和旋转。\n\n\n在场景显示界面中，按住鼠标左键并移动，可以旋转相机视角；按住鼠标右键并移动，可以平移相机视角；按住鼠标中键并移动，可以旋转相机视角和改变相机距离。\n按住 ALT 和鼠标左键并移动，可以对 Webots 场景中的物体施加力，其大小和方向与鼠标的移动相关\n\n按住 ALT 和鼠标右键并移动，可以对 Webots 场景中的物体施加力矩。\n\n2. 菜单栏软件最上方为菜单栏，包含文件、编辑、视图、仿真、生成、覆盖、工具、向导、帮助等多个菜单。\n\n菜单栏从左至右的功能如下：\n\n文件菜单用于创建、打开、保存、导入导出各类文件；\n编辑菜单用于控制器程序文本的编辑；\n视图菜单用于设置相机视角和界面渲染选项；\n仿真菜单用于控制仿真过程；\n编译菜单用于设置控制器程序的生成和编译；\n覆盖菜单用于设置相机等显示窗口的覆盖选项；\n工具菜单用于控制软件界面显示、物理插件编辑和设置软件首选项；\n向导菜单用于通过向导创建新的项目、控制器或物理插件；\n帮助菜单用于提供在线或离线的软件帮助。\n\n2.1. 更改语言可以通过 Tools→Prefences在 General 中 language 选项改成 Chinese 中文\n2.2. 更改主题通过 Tools→Prefences→Themes ，选择主题\n3. 工具栏\n工具栏集成了一些常用功能，从左至右的功能如下：\n\n收起\\展开场景树界面\n添加新节点\n重置视角\n打开标准视角菜单\n打开world文件\n保存当前world文件\n重新加载当前world文件并重新开始仿真\n仿真时间显示\n仿真重置\n执行单步仿真\n开始\\暂停仿真（实时）\n开始\\暂停仿真（非实时）\n开始\\暂停仿真（快速模式，无图像显示）\n开始\\暂停以视频方式录制当前仿真\n开始\\暂停以HTML5方式录制当前仿真\n仿真截图\n仿真音量调节\n\n4. 场景树Webots 的场景通过 VRML 语言建模，以节点(node)的形式对机器人及其场景进行建模。关于 webots 的建模，将在后续文章中详细阐述。\n\n5. 编辑器Webots 软件自带一个代码编辑器，用于仿真相关程序文件的编辑，具有基本的代码编辑功能，支持语法高亮，但不支持代码自动补全。我个人不是很习惯用自带的编辑器，用 visual studio 替代。\n大家可以根据自己的喜好选择其他的编辑器或者 IDE。\n\n6. ConsoleConsole 用于显示软件提示和用户控制器打印输出的信息，但不能用于信息的输入。\n\nWebots 的软件界面和功能并不复杂，大家可以参照此教程或官方文档多多摸索，相信大家很快即可掌握。Have Fun！\n参考与致谢\nWebots软件界面介绍\n\n","slug":"Webots/Basis/Webots软件界面介绍","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"fb0e63c8a2cfbc52de8bd40f5b32b170","title":"补充篇","content":"1.延时有时候做完一件事需要延时几毫秒，有些单片机里是用 Delay() 来表示，有些地方是用 Thread.Sleep() 表示，不管哪个函数，webots 里用哪个呢。\n **wb_robot_step();**\n\n在 webots 用这个函数，可以模拟控制器进行延时，而仿真的世界继续运行的情况。和单片机延时差不多的意思。\n在用这个函数需要注意一点，webots 里的控制器并不是以最快的速度一直循环执行代码，而是间隔basicTimeStep（worldInfo下的属性）时间执行一次，单位是 ms。\n假设 basicTimeStep = 32，我们需要在每次循环延迟 100ms，应该在循环中写 wb_robot_step(68)；\n才能达到指定的效果。如果你的延时较短，将 basicTimeStep 改小吧。\n","slug":"Webots/Basis/补充篇","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"1db430f3082768ced870d0c537dad34d","title":"添加IMU传感器","content":"1.添加姿态测量传感器 InertialUnit1.1.创建一个姿态测量传感器在现有的 Robot 上才能创建。\nchildren→InertialUnit 可创建姿态传感器。在 InertialUnit 下创建一个形状，随便一个圆柱也行，放在小车的中心或者想放的任何位置。（跟上文创建摄像头操作基本相同）\n注意：添加 InertialUnit 的过程中不设置 boundingObject 属性和 physics 属性\n\n1.2.编写姿态测量传感器代码首先包含头文件，接着获取姿态传感器句柄，使能传感器。\n#include &lt;webots&#x2F;inertial_unit.h&gt;\n\n&#x2F;&#x2F; initialize IMU\n  WbDeviceTag IMU;\n  IMU &#x3D; wb_robot_get_device(&quot;imu&quot;);\n  wb_inertial_unit_enable(IMU, TIME_STEP);\n\n\n\n\n\n\n\n\n\n\n根据官方的注释：\n该  wb_inertial_unit_get_roll_pitch_yaw 函数返回 InertialUnit 的当前侧倾角，俯仰角和偏航角。这些值作为3个组成部分的数组返回，因此只有索引 0、1 和 2 对访问返回的数组有效。请注意，索引 0、1 和 2 分别返回横滚角，俯仰角和偏航角。（注意：返回是弧度）\n于是可以定义一个有 3 个元素的数组，用于接收 roll, pitch, yaw 的值。\ndouble Eular[3] &#x3D; &#123;0&#125;;\n&#x2F;&#x2F;把函数返回的值copy到自己定义的数组中\nmemcpy(Eular, wb_inertial_unit_get_roll_pitch_yaw(IMU), sizeof(double[3]));\n\nfor (int i &#x3D; 0; i &lt; 3; i++)&#123;\n      Eular[i] *&#x3D; 180.0 &#x2F; 3.14159;\n      Eular[i] +&#x3D; 180.0;            &#x2F;&#x2F;把接收回来的弧度转为角度，因为区间在[-π，π]之间\n    &#125;\n\n通过 printf 可以在控制台实时看到角度的变化\nprintf(&quot;roll &#x3D; %lf:\\n&quot;, Eular[0]);\nprintf(&quot;pitch &#x3D; %lf:\\n&quot;, Eular[1]);\nprintf(&quot;yaw &#x3D; %lf:\\n&quot;, Eular[2]);\n\n2.添加陀螺仪 Gyro2.1.创建一个陀螺仪与上文创建姿态测量传感器步骤一样（该 Robot 只要不设置 selfCollision ，允许穿模，可以与姿态传感器等重合）\n\n2.2.编写陀螺仪代码首先包含头文件，接着获取陀螺仪句柄，使能传感器。\n#include &lt;webots&#x2F;gyro.h&gt;\n\n&#x2F;&#x2F; initialize Gyro\n  WbDeviceTag GYRO;\n  GYRO &#x3D; wb_robot_get_device(&quot;gyro1&quot;);\n  wb_gyro_enable(GYRO, TIME_STEP);\n\n\n\n\n\n\n\n\n\n\n根据官方的注释：\n该 wb_gyro_get_values 函数返回陀螺仪设备的当前测量值。这些值作为 3D 向量返回，因此只有索引 0、1 和 2 对访问向量有效。每个向量元素代表围绕陀螺节点的轴之一的角速度，以每秒弧度[rad / s] 表示。第一个元素对应于绕 x 轴的角速度，第二个元素对应于 y 轴等。（注意：根据车身的坐标，返回对应的角速度）\n于是可以定义一个有 3 个元素的数组，用于接收 Vx, Vy, Vz的值。\ndouble Angular_velocity[3] &#x3D; &#123;0&#125;;\n&#x2F;&#x2F;把函数返回的值copy到自己定义的数组中\nmemcpy(Angular_velocity, wb_gyro_get_values(GYRO), sizeof(double[3]));\nprintf(&quot;Vx &#x3D; %lf:\\n&quot;, Angular_velocity[0]);\nprintf(&quot;Vy &#x3D; %lf:\\n&quot;, Angular_velocity[1]);\nprintf(&quot;Vz &#x3D; %lf:\\n&quot;, Angular_velocity[2]);\n\n3.添加加速度计 Accelerometer3.1.创建一个加速度度计与上文创建姿态测量传感器步骤一样（该 Robot 只要不设置 selfCollision ，允许穿模，可以与姿态传感器等重合）\n\n3.2编写加速度计代码首先包含头文件，接着获取加速度计句柄，使能传感器。\n#include &lt;webots&#x2F;accelerometer.h&gt;\n\n&#x2F;&#x2F; initialize Accelerometer\n  WbDeviceTag ACCELEROMETER;\n  ACCELEROMETER &#x3D; wb_robot_get_device(&quot;accelerometer1&quot;);\n  wb_accelerometer_enable(ACCELEROMETER, TIME_STEP);\n\n\n\n\n\n\n\n\n\n\n根据官方的注释：\n该 wb_accelerometer_get_values 函数返回由加速度计测量的电流值。这些值作为3D向量返回，因此只有索引 0、1 和 2 对访问向量有效。向量的每个元素代表沿加速度计节点相应轴的加速度，以米/秒平方 [m /s²] 表示。第一个元素对应于 x 轴，第二个元素对应于 y 轴，依此类推。在重力作用下静止的加速度计沿垂直轴将指示 1 g（9.81 m /s²）。请注意，可以 gravity 在 WorldInfo 的字段中指定重力节点。为了获得仅由于运动引起的加速度，必须减去该偏移量。如果未减去失调，则器件在自由落体期间的输出将为零。\n于是可以定义一个有 3 个元素的数组，用于接收 xAxis, yAxis, zAxis的值。\ndouble Acceleration[3] &#x3D; &#123;0&#125;;\n&#x2F;&#x2F;把函数返回的值copy到自己定义的数组中\nmemcpy(Acceleration, wb_accelerometer_get_values(ACCELEROMETER), sizeof(double[3]));\n&#x2F;*这里未减去偏移量，偏移量由实际仿真时测得*&#x2F;\nprintf(&quot;xAxis &#x3D; %lf:\\n&quot;, Acceleration[0]);\nprintf(&quot;yAxis &#x3D; %lf:\\n&quot;, Acceleration[1]);\nprintf(&quot;zAxis &#x3D; %lf:\\n&quot;, Acceleration[2]);\n\n4.添加磁力计 Compass4.1.创建一个磁力计与上文创建姿态测量传感器步骤一样（该 Robot 只要不设置 selfCollision ，允许穿模，可以与姿态传感器等重合）\n\n4.2.编写磁力计代码首先包含头文件，接着获取磁力计句柄，使能传感器。\n#include &lt;webots&#x2F;compass.h&gt;\n\n&#x2F;&#x2F; initialize Compass\n  WbDeviceTag COMPASS;\n  COMPASS &#x3D; wb_robot_get_device(&quot;compass1&quot;);\n  wb_compass_enable(COMPASS, TIME_STEP);\n\n\n\n\n\n\n\n\n\n\n根据官方的注释：\n该 wb_compass_get_values 函数返回当前的磁力计测量值。返回的向量指示北斗设备坐标系中的北向。这是 wb_compass_get_values 伪代码中函数的内部算法：\nfloat[3] wb_compass_get_values() &#123;\n  float[3] n &#x3D; getGlobalNorthDirection();\n  n &#x3D; rotateToCompassOrientation3D(n);\n  n &#x3D; normalizeVector3D(n);\n  n[0] &#x3D; applyLookupTable(n[0]);\n  n[1] &#x3D; applyLookupTable(n[1]);\n  n[2] &#x3D; applyLookupTable(n[2]);\n  if (xAxis &#x3D;&#x3D; FALSE) n[0] &#x3D; 0.0;\n  if (yAxis &#x3D;&#x3D; FALSE) n[1] &#x3D; 0.0;\n  if (zAxis &#x3D;&#x3D; FALSE) n[2] &#x3D; 0.0;\n  return n;\n&#125;\n\n如果 LookupTable 为空，并且三个 xAxis，yAxis 和 zAxis 字段均为 TRUE ，则返回向量的长度为 1.0 。\n这些值将作为 3D 向量返回，因此只有索引 0、1 和 2 对访问向量有效。让我们看一个例子。该 WorldInfo.coordinateSystem 字段的默认值是 &quot;ENU&quot; ，因此北方向与Y轴一致。现在，如果磁力计节点处于直立位置，这意味着其 z 轴与全局 z 轴对齐，则可以按以下方式计算以度为单位的方位角：\ndouble get_bearing_in_degrees() &#123;\n  const double *north &#x3D; wb_compass_get_values(tag);\n  double rad &#x3D; atan2(north[0], north[2]);\n  double bearing &#x3D; (rad - 1.5708) &#x2F; M_PI * 180.0;\n  if (bearing &lt; 0.0)\n    bearing &#x3D; bearing + 360.0;\n  return bearing;\n&#125;\n\n\n\n\n\n\n\n\n\n\n其中WorldInfo.coordinateSystem的官方解释：\n该 coordinateSystem 字段指示全局坐标系的轴约定，定义了笛卡尔和重力方向。当前，它仅支持 “ ENU”（默认），“ NUE” 和 “ EUN”。“ ENU” 是指沿X轴的东方向，沿 Y 轴的北方向，以及沿 Z 轴的上方向。它是机器人（包括ROS）中使用最广泛的轴约定。“ NUE”是指沿 X 轴的北，沿 Y 轴的上，沿 Z 轴的东。这是从 VRML97 继承的旧版 Webots 轴约定。“ EUN” 是指沿X轴的东方向，沿 Y轴的轴向上，而沿 Z 轴的方向北。它类似于 “ NUE”，但北和东倒置。加速度计，指南针，InertialUnit 和 GPS 设备。\nWorldInfo.coordinateSystem 建世界时默认的是 ENU ，于是自己建小车的 Y 轴是向上的，所以北方向朝上。\n\n                                                                                                                                     其中：（绿色为Y轴）\n\n套用官方的函数，定义angle；可以定义一个有 3 个元素的数组，用于接收 xAxis, yAxis, zAxis的值。\ndouble get_bearing_in_degrees(double* north)\n&#123;\n  double rad &#x3D; atan2(north[0], north[2]);\n  double bearing &#x3D; (rad - 1.5708) &#x2F; M_PI * 180.0;\n  if (bearing &lt; 0.0)\n    bearing &#x3D; bearing + 360.0;\n  return bearing;\n&#125;\n\ndouble Magnetometer[3] &#x3D; &#123;0&#125;;\n&#x2F;&#x2F;把函数返回的值copy到自己定义的数组中\nmemcpy(Magnetometer, wb_compass_get_values(COMPASS), sizeof(double[3]));\n&#x2F;&#x2F;算出绕北方向旋转的角度\ndouble angle &#x3D; get_bearing_in_degrees(Magnetometer); \nprintf(&quot;angle &#x3D; %lf:\\n&quot;, angle);\n\n参考与致谢\nWebots:姿态测量传感器\n\n\nWebots:陀螺仪\n\n\nWebots:加速度计\n\n\nWebots:磁力计\n\n","slug":"Webots/Application/IMU/添加IMU传感器","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"dc9eb118380877df3be3b78227a1a198","title":"建立 2021RC 图纸","content":"1.Soliworks 导出图纸到 Webots2021RC 场地中间有三个可活动的壶，三个壶分别定义为三个关节，启动区，地板，线等分别单独作为一个Solid导出，总体导出为一个Robot节点。（后面会说为什么要这样导出）\n2.建立场地地板其实小车也可以在原Robot节点上跑，但是带来的问题是，不好控制。小车在有碰撞边界的物体上跑时会增大计算量，导致走得很颠簸，而且会卡。解决这个问题的最好办法是把需要作为地板的固体直接作为一个地板节点。官方碰撞边界里专门有 Plane 节点：\n\n\n\n\n\n\n\n\n\n\n官方解释：\nPlan 节点在局部坐标系中的 y = 0 处定义了一个无限的 3D 平面。 平面可以在 boundingObject 中使用，以模拟边界，例如地板或无限墙。 size字段仅用于视觉表示，当涉及到碰撞检测时，Plan 是无限的。 Plan 是严格静态的对象，不能将其放置在动态（基于物理）对象的 boundingObject 中。\n于是可以把导入的Robot节点里关于地上的东西全部拿出来重新定义为一个地板。\n\n首先创建一个 Transform 节点，再创建一个 Solid j节点用来放置所有关于地板节点。\n再把启动区，主底面，线等 Solid 节点剪切过去（把各个不同模块分开是方便可以染色）\n\n\n\n碰撞边界处就定义一个 Transform→Plan 节点，地板平面要比导入的节点位置都要高，否则仿真时上面小车会穿模，仿真会卡。\n最后把各个模块染下色，对齐坐标，整个地板就完成了。\n\n\n3.修改场地主体模型在导入是碰撞边界是连带生成好的，但是直接使用系统生成的碰撞边界有问题。\n\n不稳定。由于某个地方的纹理比较复杂，小车走到那个地方时计算会出错，导致出现一些2077的BUG。例如原地飞天之类的。\n拖慢仿真速度\n\n在 Solidworks 导出模型时是把围墙作为 Robot 节点的身体，所以第一级节点碰撞边界只需要定义围墙即可。\n\n在第二级节点，就是场地上的壶，要点开里面重定义碰撞边界。（但是由于 Webots 没有空心圆柱的节点生成，于是不作变化）\n\n另外，场地有三个壶是能动的，属于关节，在转成 .proto 文件时，会自动生成电机，但是这里我们只是作为活动关节，所以我们不需要电机，要把电机节点删掉。\n\n物理属性也会自动添加，一般不作修改，把碰撞边界处理好之后就完成了。点击仿真，能正常运行。放置一台小车模型，去撞击场地的个个部分，都正常，到这里就结束了。\n","slug":"Webots/Application/RC map/2021RC 图纸","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"86336032c6ac02563b9014b8bacea503","title":"创建三全向轮小车","content":"官方有开源的全向轮模型，可以先尝试自己建立\n下面我会讲我的思路，默认添加物理属性和碰撞属性。\n1.搭建躯干我们先创建一个 Robot 节点，在 children 里面先建立一个 Transform 节点。这样可以使小车躯干在 Robot（父级）坐标下进行移动。\n我在 Transform→children 创建一个 Shape，创建一个圆柱体作为小车的躯干。\n\n2.创建一个全向轮接着在 Robot→children 里创建一个 HingeJoint（铰链），该节点将作为其中一个轮子的总节点。\n旋转轴和旋转中心最后再确定，在 endPoint 中创建一个 soild，该 soild 包含轮子所有需要的节点。\n一个全向轮包含以下内容：\n\n9 个可以活动的辊子\n一个轮毂\n\n2.1.创建轮毂我们先一个创建轮毂，在 Robot→children→HingeJoint→soild→children 里创建一个 Transform（宏定义为DEF WHEEL_TRANS Transform），新建一个 shape→Cylinder，修改形状，旋转 DEF_WHEEL_TRANS_Transform 里面的坐标轴，使其变成轮毂的形状。（红色的辊子先忽略）\n\n2.2.创建辊子我们只需要确定辊子的形状、几何中心、旋转轴和旋转中心即可。\n\n2.2.1.移动并旋转辊子到合适的位置\n在 Robot→children→HingeJoint→soild 里继续创建 HingeJoint（宏定义为DEF sr1 HingeJoint），在 DEF sr1 HingeJoint→endPoint 中创建一个 soild。\n\n调整 DEF sr1 HingeJoint 里坐标轴，调整坐标的坐标点到图上 D 点处。\n\n接着在 DEF sr1 HingeJoint→children 里新建一个 Transform（宏定义为DEF r1 Transform）。\n\nDEF r1 Transform→children 里新建一个 shape，选择圆柱体。\n\n在 DEF r1 HingeJoint 调整辊子 translation，使得如上图所示的辊子，以每隔四十度角排列。\n\n再调整 DEF r1 Transform 的 rotation，使得辊子沿着轮毂的切线方向\n\n\n这样可以使得 DEF sr1 HingeJoint 的坐标不变，只会以 DEF sr1 HingeJoint 坐标为前提下改变方向，使得移动该辊子的时候可以整个移动，移动到合适的点后再旋转方向。\n图中 D’、D’’ 等都可以通过半径 *sin/cos 来求得 X、Y 的偏移量。\n\n例如：要把辊子移动到 D’\n\n在DEF r1 HingeJoint的translation输入算出来的X、Y的偏移量。\n坐标点移到之后，旋转辊子的rotation，使得方向与轮毂切线方向平行。\n\n\n\n\n\n\n\n\n\n\nratation 不能直接给角度，只能通过调整 X、Y、Z 轴的大小来控制角度。\n\n其中的一个辊子\n\n2.2.2.设置辊子旋转轴的位置旋转轴默认不显示，查看→可选显示→show Joint Axes 并勾上。\n之后会看到一条黑细的一条线，那条就是旋转轴。\n旋转轴在 DEF sr1 HingeJoint→jointParameters 里调整，axis 是调整旋转轴，anchor 是调整旋转中心。\n\n\n\n\n\n\n\n\n\n\n旋转中心一般与endPoint里的translation（即铰链的物体坐标点）相同即可\n2.2.3.设置整个轮子的旋转参数按照上述方法确定旋转轴和旋转中心，device里选择电机，并把电机重命名（作为后续代码的句柄），轮子创建完成。\n3.完整小车建好一个轮子后，把另外两个轮子复制出来名字重新命名。先把两个轮子坐标点全部清0（回到零点），接着把两个轮子分别顺时针转和逆时针转120°，再沿着第一个轮子的轴往前拉动相同距离。\n4.代码在之前的基础上加入三轮运动模型即可。\nconst float Radian &#x3D; 3.14159 &#x2F; 6;\n\ntempSpeed[0] &#x3D; -Vx + VOmega;\ntempSpeed[1] &#x3D; Vx * sin(Radian) - Vy * cos(Radian) + VOmega;\ntempSpeed[2] &#x3D; Vx * sin(Radian) + Vy * cos(Radian) + VOmega;\n\n参考与致谢Webots: 全向轮搭建\n","slug":"Webots/Application/omni wheel/创建三全向轮小车","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"c9ce92de968e539fb260956b4d902ffd","title":"添加摄像头","content":"1.添加camera实体在Robot中添加 camera（camera相机）\n\n\n设置这个 camera 相机的children中添加 transform 节点，\n\n设置这个 transform 节点的children中添加shape节点，并设置外观和形状。设置半径 0.01 高度0.02\n\n\n\n设置camera 相机的名称（这个在控制器中会用到），同时设置相机的偏移量为（x=0,y=0.01,z=0.08），旋转偏移量（x=0,y=1.z=0,angle=3.14 rad）注意：相机的方向的正前方应该是 -z方向，也就是图中蓝色箭头的负方向，在添加相机的时候应当注意。\n\n在camera节点的属性栏中可以设置相机的宽、高和视场角等参数（详情可看官方文档提供的参数）\n\n注意：添加camera的过程中不设置boundingObject属性和 physics属性\n2.添加camera控制接口代码看Cemera节点里命名\n\n根据节点里的命名，在控制器main函数里添加下面代码\n#include &lt;webots&#x2F;camera.h&gt;\n\nWbDeviceTag CAMERA;\nCAMERA &#x3D; wb_robot_get_device(&quot;camera1&quot;);     &#x2F;&#x2F;camera1 是自己定义的名字，在场景树中修改\nwb_camera_enable(CAMERA, TIME_STEP);\n\n点击仿真就可以了\n3.增加识别功能摄像头还有一种功能是识别物体功能，需要代码和配置摄像头 Recognition 来开启。\n#include &lt;webots&#x2F;camera_recognition_object.h&gt;\n\nWbDeviceTag CAMERA &#x3D; wb_robot_get_device(&quot;camera1&quot;);   &#x2F;&#x2F;camera1 是自己定义的名字，在场景树中修改\nwb_camera_enable(CAMERA, TIME_STEP);\nwb_camera_recognition_enable(CAMERA, TIME_STEP);\n\nint number_of_objects &#x3D; wb_camera_recognition_get_number_of_objects(CAMERA); &#x2F;&#x2F;获取识别对象的数量\nprintf(&quot;\\nRecognized %d objects.\\n&quot;, number_of_objects); \n\nconst WbCameraRecognitionObject *objects &#x3D; wb_camera_recognition_get_objects(CAMERA);    &#x2F;&#x2F;获取对象结构体\n\nfor (int i &#x3D; 0; i &lt; number_of_objects; ++i) &#123;\n  printf(&quot;Model of object %d: %s\\n&quot;, i, objects[i].model);      &#x2F;&#x2F;打印识别对象 Model 的名字\n  printf(&quot;Id of object %d: %d\\n&quot;, i, objects[i].id);            &#x2F;&#x2F;打印识别对象的 ID\n  printf(&quot;Relative position of object %d: %lf %lf %lf\\n&quot;, i, objects[i].position[0], objects[i].position[1],\n         objects[i].position[2]);\n  printf(&quot;Relative orientation of object %d: %lf %lf %lf %lf\\n&quot;, i, objects[i].orientation[0], objects[i].orientation[1],\n         objects[i].orientation[2], objects[i].orientation[3]);\n  printf(&quot;Size of object %d: %lf %lf\\n&quot;, i, objects[i].size[0], objects[i].size[1]);\n  printf(&quot;Position of the object %d on the camera image: %d %d\\n&quot;, i, objects[i].position_on_image[0],\n         objects[i].position_on_image[1]);                       &#x2F;&#x2F;打印识别对象在图像的坐标点\n  printf(&quot;Size of the object %d on the camera image: %d %d\\n&quot;, i, objects[i].size_on_image[0], objects[i].size_on_image[1]);\n  for (int j &#x3D; 0; j &lt; objects[i].number_of_colors; ++j)          \n    printf(&quot;- Color %d&#x2F;%d: %lf %lf %lf\\n&quot;, j + 1, objects[i].number_of_colors, objects[i].colors[3 * j],\n           objects[i].colors[3 * j + 1], objects[i].colors[3 * j + 2]);\n&#125;\n\n其中 position_on_image 是我们需要的数据，因为从现象来看与 2020 视觉发来的数据是一致的，也就是相对于图像的坐标。\n代码写好后，还需要在之前摄像头的配置前提下，再配置 Recognition 节点。\n点开 Camera 节点，选到 recognition 节点，添加 Recognition，添加并修改一点参数。\n\n\nframeColor：定义识别框的颜色\nframeThickness：定义识别框的粗细\n\n摄像头还有一个抗锯齿功能，点击 Camera 中 antiAliasing 节点，默认是关闭的，打开就开启图像抗锯齿功能。\n假如觉得图像很模糊，可以调节图像 size，调得越大越清晰。\n4.创建可被识别实体官方文档说 Camera 只能识别 Solid，我尝试了一下，发现普通的 Solid 是无法被识别的，我打开了官方自带的其中一个 Solid，对比后发现是要添加特定的参数才能被识别。\n4.1.创建一个固体简单模型仿真\n4.2.定义名称从对象的结构体会返回被识别物体名称可以看出，被识别的物体是要有名字的，这名字是我们用户定义的，这里我随便定义了一个名字。\n\n4.3.定义颜色在 Camera 上，识别系统需要知道定义的固体的颜色，没有设置是不会被识别的，Soild 节点里有两个地方需要设置颜色，一个是给自己看的，一个是让 Camera 识别的，新建的时候并不会开启，需要手动开启。Solid→recognitionColors\n\n这里与自己用户设置的颜色不一样也没有关系，因为是给系统看的，当然了，一般也会与用户颜色调成一致。\n5.尝试识别把上诉都配置完成后，可以开始测试是否被识别到。效果如下图所示：\n\n控制台打印也正常：\n\n就证明成功了，把仿真暂停，鼠标移动到 Solid 上还能看见参数：\n\n识别在这里就结束了。\n参考与致谢Webots:摄像头\n","slug":"Webots/Application/camera/添加摄像头","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"9f4d731f68633873b2e6fa4c0e1d7745","title":"使用 URDF2WEBOTS 导入 SolidWorks 装配体","content":"1.安装pythonURDF2WEBOTS 要在 python下运行，可以去 python 官网找 python 包然后下载。我用的是 python-3.8.6-amd64 包。\nWindows python3.8环境安装\n2.使用官方包导入URDF2WEBOTS 可以把URDF文件转换成 .proto 文件，Webots 会自动检测为一个 Robot 节点并使用。但是前提是 SolidWorks 导出 URDF 文件时尽可能把坐标点，基准面等配合关系都处理好，不然导入 Webots 里会非常难调整。\n2.1.配置环境安装好之后可以运行 cmd，输入 python\n\n出现下列语句证明已经装成功了 ，可以开始安装 URDF2WEBOTS \n在 cmd 里输入\npip install urdf2webots\n\n就会自动安装，安装完成后就正式可以使用 urdf2webots\n2.2.使用 urdf2webots运行 cmd，输入 python\n接着输入\nfrom urdf2webots.importer import convert2urdf\n\n再输入\nconvert2urdf(&#39;G:\\\\URDF\\\\Lathe8\\\\urdf\\\\Lathe8.urdf&#39;)\n\n其中 G:\\URDF\\Lathe8\\urdf\\Lathe8.urdf 是 SolidWorks 生成 urdf 文件的那个包的路径，之后会生成同文件名 .proto 。如果安装 urdf2webots 是没更改路径，他会自动放在 C:\\用户\\xxx 里（找不到就搜索 .proto 吧）\n找到 xxx.proto 后剪切到工程的 protos 文件夹里，打开工程，点击新建\n\n可以看见 PROTO nodes 里有 Robot 节点可以选\n之后把该节点转换为一个 Robot 节点，在 SolidWorks 导出是定义的所有关节关系就会显示出来。而且会自动设定好了碰撞边界还有物理系数，有需要可以自行修改。\n再给这些关节电机修改名字，加上编写控制器，就可以直接使用模型了。\n但是据某些博客说用官方包会有 BUG（但是我暂时没发现）\n3.使用第三方 urdf2webots 包导入3.1.了解第三方 urdf2webots 包首先还是要 python 环境\n当你安装官方包失败时，或者遇到 BUG，可以使用这个第三方的 urdf2webots 包，是拿比较旧的官方包经过民间修改，所以它不能自动设置碰撞边界，但是比较稳定。\nurdf2webots 压缩包\n解压缩后会出现下面的东西\n\n3.2配置环境如果使用 cmd 能运行，则跳过此步骤。\n在微软商店里安装 PowerShell。\n3.3使用方法在命令行里更改路径：cd 路径（路径为该第三方包的解压路径）\n\n之后输入\npython urdf2webots.py --input&#x3D;yourSelfRobotModel.urdf  &#x2F;&#x2F;URDF文件的路径\n\n\n生成的 xxx.proto 文件位于 urdf2webots 功能包目录下\n找到 xxx.proto 后剪切到工程的 protos 文件夹里，打开工程，点击新建\n\n可以看见 PROTO nodes 里有 Robot 节点可以选\n之后把该节点转换为一个 Robot 节点，在 SolidWorks 导出是定义的所有关节关系就会显示出来。但是碰撞属性要自己设立，一般只需要把 shape 重定义，直接在碰撞属性里找到该宏，直接用就可以了。\n再给这些关节电机修改名字，加上编写控制器，就可以直接使用模型了。\n4.模型显示结构问题urdf2webots 自动生成显示结构是无法修改的。\n某些非必要的结构，例如四轮小车的底板，对仿真没有严格的要求，只需要能检测碰撞边界即可，那么我们可以直接用其生成的显示结构直接作为碰撞边界使用。\n但是必要结构，例如四轮小车的轮子，按照其自动生成的结构，仿真起来会在平地上一跳一跳，这是由于直接使用自动生成结构作为碰撞边界导致的。\n解决这个问题的办法是：自行在该节点下创建一个碰撞属性，用一个接近于物体形状的图形，来代替其原来的碰撞属性，从而使仿真时更加真实。\n官方四足：\n\n\n\n\n5.自身穿模问题如果将此字段设置为 True，则可能正在寻找机器人设备的 “selfCollision” 字段(默认情况下为 False )，机器人将能够自行碰撞。\n但是要小心，如文档中所述，这会影响仿真速度:\n但是，启用自碰撞可能会降低模拟速度，因为在模拟过程中会产生更多的碰撞\n并且不会处理直接连续的实体之间的碰撞:\n注意，仅将检测非连续实体之间的碰撞。对于连续的实体，例如两个通过关节彼此连接的实体，即使启用了自碰撞，也不会执行碰撞检测。原因是用户通常不需要这种类型的碰撞检测，因为将需要非常精确地设计实体的边界对象。为了防止两个连续的实体节点相互穿透，应相应地调整相应联合节点的 minStop 和 maxStop 字段\n参考与致谢\n听说你只会用Gazebo仿真？\n\n\n将solidworks装配体模型导入webots并进行控制_时光@印迹的博客-CSDN博客\n\n\n将SolidWorks机器人模型导入webots的快捷方法_Wildec-CSDN博客\n\n\nWebots\n\n","slug":"Webots/Application/导入模型/使用 URDF2WEBOTS 导入 SolidWorks 装配体","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"b0789e481403d86aa2884de6d2dd0538","title":"初识控制器","content":"1. E-PUCK机器人模型e-puck 机器人周围有 8 个红外距离传感器，我们可以通过判断传感器值来避障。\n控制机器人控制图如下：\n\n下面开始介绍代码使用\n2.自行编写控制器按照之前的步骤创建控制器模板。\n2.1.编写代码首先添加与Robot，DistanceSensor和Motor节点相对应的头文件\n#include &lt;webots&#x2F;robot.h&gt;\n#include &lt;webots&#x2F;distance_sensor.h&gt;\n#include &lt;webots&#x2F;motor.h&gt;\n\n在include语句之后添加一个宏，该宏定义每个物理步骤的持续时间。该宏将用作该wb_robot_step函数的参数，还将用于启用设备。此持续时间以毫秒为单位指定，并且必须是WorldInfo节点basicTimeStep字段中值的倍数。\n#define TIME_STEP 64\n\n宏定义设定机器人速度最大值\n#define MAX_SPEED 7\n\n2.1.1. 传感器首先在main函数里添加传感器初始化\n&#x2F;&#x2F; 初始化传感器\n\tint i;\n\tWbDeviceTag ps[8];\n&#x2F;&#x2F;传感器名字\n\tchar ps_names[8][4] &#x3D; &#123;\n\t\t&quot;ps0&quot;, &quot;ps1&quot;, &quot;ps2&quot;, &quot;ps3&quot;,\n\t\t&quot;ps4&quot;, &quot;ps5&quot;, &quot;ps6&quot;, &quot;ps7&quot;&#125;;\n\n\tfor (i &#x3D; 0; i &lt; 8; i++)\n\t&#123;\n    &#x2F;&#x2F;拿句柄\n\t\tps[i] &#x3D; wb_robot_get_device(ps_names[i]);\n    &#x2F;&#x2F;使能传感器\n\t\twb_distance_sensor_enable(ps[i], TIME_STEP);\n\t&#125;\n\n2.1.2. 电机初始化电机\n&#x2F;&#x2F;初始化电机\n\tWbDeviceTag left_motor &#x3D; wb_robot_get_device(&quot;left wheel motor&quot;);\n\tWbDeviceTag right_motor &#x3D; wb_robot_get_device(&quot;right wheel motor&quot;);\n\n配置电机走的路程\n&#x2F;&#x2F;电机走的位置给无限大\n\twb_motor_set_position(left_motor, INFINITY);\n\twb_motor_set_position(right_motor, INFINITY);\n\n初始化电机速度\n&#x2F;&#x2F;电机的速度初始化\n\twb_motor_set_velocity(left_motor, 0.0);\n\twb_motor_set_velocity(right_motor, 0.0);\n\n2.1.3. 总控制进入while函数里，进行电机控制\n&#x2F;&#x2F;读取传感器数值\n\t\tdouble ps_values[8];\n\t\tfor (i &#x3D; 0; i &lt; 8; i++)\n\t\t&#123;\n\t\t\tps_values[i] &#x3D; wb_distance_sensor_get_value(ps[i]);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F;判断传感器是否触发\n\t\tbool right_obstacle &#x3D;\n\t\t\tps_values[0] &gt; 80.0 ||\n\t\t\tps_values[1] &gt; 80.0 ||\n\t\t\tps_values[2] &gt; 80.0;\n\t\tbool left_obstacle &#x3D;\n\t\t\tps_values[5] &gt; 80.0 ||\n\t\t\tps_values[6] &gt; 80.0 ||\n\t\t\tps_values[7] &gt; 80.0;\n\n\t\t&#x2F;&#x2F; initialize motor speeds at 50% of MAX_SPEED.\n\t\tdouble left_speed &#x3D; 0.5 * MAX_SPEED;\n\t\tdouble right_speed &#x3D; 0.5 * MAX_SPEED;\n\n\t\t&#x2F;&#x2F; modify speeds according to obstacles\n\t\tif (left_obstacle)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; turn right\n\t\t\tleft_speed &#x3D; 0.5 * MAX_SPEED;\n\t\t\tright_speed &#x3D; -0.5 * MAX_SPEED;\n\t\t&#125;\n\t\telse if (right_obstacle)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; turn left\n\t\t\tleft_speed &#x3D; -0.5 * MAX_SPEED;\n\t\t\tright_speed &#x3D; 0.5 * MAX_SPEED;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; write actuators inputs\n\t\twb_motor_set_velocity(left_motor, left_speed);\n\t\twb_motor_set_velocity(right_motor, right_speed);\n\n2.2.编译代码并仿真我们可以看到小车遇到障碍物时能转弯，但是过程非常僵硬，而且转弯幅度并不是线性\n参考与致谢Webots: tutorial-4-more-about-\n","slug":"Webots/Basis/Controllers/More about Controllers","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"8ccb81c699797060f7237a0cd838fd05","title":"复合固体与物理属性","content":"1. 复合固件官方给的关系图如下\n\n1.1. 创建固体哑铃（复合固体）创建如下：\n\n先在主界面创建一个solid，在children里创建一个Group \n\n\nGroup→children里创建shape→Cylinder \n\n\n继续在Group→children里创建Transform→children→shape，创建一个球\n Transform→translation调整球相对于圆柱的坐标点 \n\n\n\n以相同的步骤再创建一个 \n\n哑铃就完成了，但是还没有给他添加物理和碰撞属性\n1.2. 物理属性把Group宏定义成Dumbbells\n直接在该soild节点下的boundingObject添加Dumbbells\n再添加物理属性，就完成了。\n参考与致谢Webots: tutorial-5-compound-solid-and-physics\n","slug":"Webots/Basis/Compound Solid/Compound Solid","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"fc13b73644ba5c7d639ba6021aed1ee5","title":"仿真环境的变量","content":"1.Soild中的具体参数1.1. shape创建完 soild 后，点击 children→Base nodes→shape \n\n\n\n\n\n\n\n\n\n官方对 shape 的定义是这样的：A Shape node is a visual objects that includes both an ‘appearance’ and a ‘geometry’. A Shape can also be used in a ‘boundingObject’, in this case, only its ‘geometry’ field is taken into account.\n也就是说该节点包含“几何形状”和“外观”，shape 也可以在 boundingObject 中使用。\n1.1.1. geometry新建后是没有实体的，所以通过 shape→geometry 中添加 Sphere，创建出一个球。\n\nradius：调整球的半径\nsubdivision：调整球的圆滑度\n\n1.1.2. appearance接着可以选择纹理，shape→appearance 可以选择自己需要的纹理。\n\nIBLStrenght：调整物体纹理亮度\n\ntextureTransform：The TextureTransform node defines a 2D transformation that is applied to texture coordinates. This node affects the way textures coordinates are applied to the geometric surface.\n\n\n1.2.name可以在 Soild→name 中修改名字，或者直接点击 Soild，在下面 DEF 框里填上修改的名字。\n1.2.1. DEF在这里设置节点的名字后相当于宏定义了该节点参数，其他节点调用时可以直接在USE中找到并使用。\n例如：我把其中一个 shape 节点命名为 ball\n\n在 boundingObject 节点可以找到并新增该 shape\n\n1.3. boundingObject上面简述了它是设置该 Soild 的碰撞边界，通过 Soild→Sphere 来创建球的碰撞边界。\n（一般与物体的参数一致就行，甚至可以直接把物体大小等参数直接复制过来）\n2.物体外观该篇讲的是外观的问题，但是一般是闲着没事才会去考虑外观问题。\n\n直接看官方教程吧\n参考与致谢\nWebots: tutorial-2-modification-of-the-\n\nWebots: 外观\n\n\n","slug":"Webots/Basis/Environment/仿真环境的变量","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"4dd2c32722399921db71fc37e2defc0b","title":"Webots 节点问题","content":"每个运行实例被称为节点，换句话说，每个运行的进程就是一个节点，每个机器人程序，可以有非常多个节点。\n我们也可以运行同一个程序的多个副本（确保每个副本使用不同节点名），则每个副本都被当作一个独立节点，节点（Node）可以用来提供某种数据或能力，比如读取某传感器（Sensor）数据，也可以是一个获取这些数据并处理这些数据的节点(Node)。\n例如从别的节点那拿到 Sensor 并处理：\n先来看一下官方文档里的 Node Chart\n\n那我们来举个例子\n\n在这张表里，两个节点之间的箭头表示继承关系\n继承关系表明派生节点(derived node)继承了基本节点(base node)的所有字段和 APl 函数（PS：派生节点是箭头结束点，基本节点是箭头触发点）\n继承的意思就是子承父业，基本节点有的，派生节点全都有。\n例如，Solid (derived node)节点继承自 Transform (base node)节点，因此 Transform 节点中可用的所有字段和功能在Solid节点中也可用\n用虚线表示的框，例如\n\n（Light，Device或Geometry）代表抽象节点（abstract nodes）,即无法实例化的节点。\n抽象节点用于对派生节点(derived nodes)共享的公共字段和功能进行分组\n","slug":"Webots/Basis/Node/Webots节点问题","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"7ac2b54ca1440cb7fe4eb2d0091dbb9b","title":"第一个仿真模型","content":"1.Create a new world与之前创建新世界方法一致：\n简单模型仿真 \n2.Add an e-puck Robot在此基础上，加入一个官方的机器人：\n\n右键→新增→PROTO nodes (webots projects)→robots→Gctronic→Epuck\n\n\n因为该机器人自带一个 Control，它遇到障碍物可以自动避障，而我们要新增一个并改掉它。\n3.Create a New Controller向导（Wizards）→新机器人控制器（new controller）\n\n这里我们选择 C 语言\n\n这里我们先选择 webots 自带的编译器\n\n更改控制器的名称\n\n点击 E-puck→controller，选择刚刚我们新建的 controller\n\n4.Extend the Controller to Speed Control下一步我们来修改自己新建控制代码，并拓展到速度控制。\n在官方的教程中可以找到速度控制源码\n#include &lt;webots&#x2F;robot.h&gt;\n\n&#x2F;&#x2F; Added a new include file\n#include &lt;webots&#x2F;motor.h&gt;\n\n#define TIME_STEP 64\n\n#define MAX_SPEED 6.28\n\nint main(int argc, char **argv) &#123;\n  wb_robot_init();\n\n  &#x2F;&#x2F; get a handler to the motors and set target position to infinity (speed control)\n  WbDeviceTag left_motor &#x3D; wb_robot_get_device(&quot;left wheel motor&quot;);\n  WbDeviceTag right_motor &#x3D; wb_robot_get_device(&quot;right wheel motor&quot;);\n  wb_motor_set_position(left_motor, INFINITY);\n  wb_motor_set_position(right_motor, INFINITY);\n\n  &#x2F;&#x2F; set up the motor speeds at 10% of the MAX_SPEED.\n  wb_motor_set_velocity(left_motor, 0.1 * MAX_SPEED);\n  wb_motor_set_velocity(right_motor, 0.1 * MAX_SPEED);\n\n  while (wb_robot_step(TIME_STEP) !&#x3D; -1) &#123;\n  &#125;\n\n  wb_robot_cleanup();\n\n  return 0;\n&#125;\n\n将其替换掉自己新建的模板（epuck_go_forward.c）\nctrl+s 保存，之后点击编译\n\n可以看到机器人沿着一个方向一直走。\n参考与致谢\nWebots: tutorial-1-your-first-simulatio\n\n","slug":"Webots/Basis/First Simulation/Your First Simulation in Webots","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"509c30d25ef695d68dc7f877cde8022c","title":"简单模型仿真","content":"1. 创建新世界那么最上面的两个节点是 Wordlnfo(世界信息）、Viewpoint(视角)。这两项是无法删除的Wordlnfo 里面有仿真物理学的一些参数，我们一般不修改这些参数\n1.1. Wordlnfo\nWordlnfo→basicTimeStep ：这个参数。它代表仿真最小的时闻单元。当它为32时。每次仿真的时间步长为32ms\nWordlnfo→Gravity：是重力的大小和方向\n坐标系：可以在菜单栏：查看→可选显示→显示坐标系统\n\n\n\nWordlnfo→physics：搭载物理插件的参数，在后期需要用到机械上的铰链、万向节等结构时需要用到物理插件\n\n1.2. Viewpoint\nViewpoint 需要注意的是 follow 这一行，到时候可以输入机器人的名字，呈现给我们的视角就是跟随机器人移动的视角。\n\n1.3. 向导新项目这是基础版的新建世界，另外一种是向导→新项目目录。\n区别在于基础版的世界啥也没有，比如光线背景都是自己设置；然而向导的新项目目录会帮你完成基础选项。\n打个比喻就是基础版还需要抄题写作业，新项目目录已经帮你抄好了题目，直接写答案就可以了。\n然后选择把新建的世界文件放在特定文件夹，建议单独新建一个空文件夹，要不然里面好几个文件要是弄混了就很让人头秃。\n\n第一行是世界的名字，名字尽量别起中文，有可能会报错。\n下面的几个选项分别是：\n\n视觉放中央\n添加背景\n添加光线\n添加方形区域（就是添加了四堵围墙）\n\n点击下一步\n最后点击完成\n\n这里多了两行 TextureBackgroung（项目背景），TextureBackgroundLight（项目光线）\n新世界模板完成。\n2. 添加节点在 simulation vew 里右键，新增节点，在 PROTO nodes(webots projects)里选择 objects\n\n选择floors，这个就是地面\n\n点击添加\n\n点击 floor：\n\n第一行的translation指的是相对于坐标轴的所在位置\n第二行的rotation指的是旋转角度\n\n这里大家可以理解成微积分里面球或者圆柱体坐标系的几个基本变量\n\n第三行是名字\n第五行 size（地图大小）\n\n3. 建立简单模型接下来我们建一个简单的模型，让一个球自由落体，看看仿真效果\n在simulation view点击，右键新建节点\n3.1. solid在 base nodes 里，添加—个 solid 节点\n\nSolid 指的是固体\n\n在 Solid 节点展开下点击 children，右键\n在 base nodes 里新建 shape 节点。并点击 shape 节点\n这里的 shape 是为了给这个固体赋予形状\n在下方 name 中输入 qiu，回车，将 Shape 节点命名为 qiu\n在 Shape 节点下双击 geometry NULL，新建 sphere 节点\n\n\n然后球就诞生了，但是你会发现它陷在了地板里。\n这是因为我们的 translation 没有设置，依然是（0，0，0）；\n点击 查看→可选显示→显示坐标系统\n所以设置成为（0，1，0）\n\n现在球已经漂浮到了空中\n现在我们来做一个最简单的操作，让球自由落体。\n点击 solid→physics，双击 physics NULL 新增节点\n3.2. physics这个节点下可以设置密度和质量了\n默认是密度 1000，质量 -1，-1 代表不使用质量这个属性\n如果要设置质量信息，将密度改成 -1，质量改成相应值就好了\n这里设置成 100\n\n结果球没了，这是因为已经开始了仿真\n3.3. boundingObject仿真时球直接往下掉，是因为没有为球添加碰撞边界。\n选中 boundingObject，按照上面创建 shape 方法创建即可。更简便的方法是，我们直接可通过选中 children 下的 Shape 节点并复制，然后选中 boundingObject 直接粘贴实现。\n这样一个简单的自由落体完成了。\n","slug":"Webots/Basis/Simple model/简单模型仿真","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"5ed1839713d43591c8a49ca17920825f","title":"简单四轮机器人","content":"1. 四轮小车建立流程图\n2. 四轮小车具体建立过程2.1. 新建新世界新建向导项目，创建一个地板（简单模型仿真）\n2.2. 建立小车2.2.1. 建立小车主体新建一个Robot节点，点击children，新增shape，宏定义为BODY\n\n给该Shape新增纹理，geometry里新增box，宏定义为Box\n\n2.2.2. 建立车轮在Robot→children新增HingeJoint（铰链）节点\n\n\njointParameters：控制转动时的参数\ndevice：旋转设备\nendPoint：铰链另一端的连接的物体\n\n\n首先在endPoint新建Solid，再新建一个Shape，宏定义改为WHEEL\n Shape→geometry里创建Cylinder（圆柱体） \n\n\n\n调整轮子位置和角度\n\n接着在device里新建电机 \n 最后在jointParameters里创建HingeJointParameters \n\n\n\n\n\n\n\n\n\n要注意的是，jointParameters→anchor是旋转中心，一般要把该点设置为该轮子坐标的中点，不然会出现奇奇怪怪的问题\n\n再设置碰撞属性，物理参数。\n\n\n到这里一个轮子已经创建好了，接下来把该HingeJoint复制粘贴，得到4个。\n再把每一个HingeJoint里轮子的旋转中心，轮子的位置，电机宏，轮子宏修改后，可以开始编写控制器\n2.3. 编写控制器创建新控制器模板后，把之前的电机控制器代码套进去\n#include &lt;webots&#x2F;robot.h&gt;\n\n&#x2F;&#x2F; Added a new include file\n#include &lt;webots&#x2F;motor.h&gt;\n\n#define TIME_STEP 64\n\nint main(int argc, char **argv)\n&#123;\n  wb_robot_init();\n\n  &#x2F;&#x2F; initialize motors\n  WbDeviceTag wheels[4];\n  char wheels_names[4][8] &#x3D; &#123;\n      &quot;motor1&quot;, &quot;motor2&quot;, &quot;motor3&quot;, &quot;motor4&quot;&#125;;\n  int i;\n  for (i &#x3D; 0; i &lt; 4; i++)\n  &#123;\n    wheels[i] &#x3D; wb_robot_get_device(wheels_names[i]);\n    wb_motor_set_position(wheels[i], INFINITY);\n  &#125;\n\n  while (wb_robot_step(TIME_STEP) !&#x3D; -1)\n  &#123;\n    double left_speed &#x3D; 1.0;\n    double right_speed &#x3D; 1.0;\n\n    wb_motor_set_velocity(wheels[0], left_speed);\n    wb_motor_set_velocity(wheels[1], right_speed);\n    wb_motor_set_velocity(wheels[2], left_speed);\n    wb_motor_set_velocity(wheels[3], right_speed);\n  &#125;\n\n  wb_robot_cleanup();\n\n  return 0;\n&#125;\n\n编译控制器后，电机仿真，发现小车没动\n因为没有修改Robot里控制器，controller里选择为自己的新建控制器\n\n在点仿真，就可以动了\n参考与教程Webots: tutorial-6-4-w\n","slug":"Webots/Basis/Wheeled Robot/Wheeled Robot","date":"2022-01-30T12:49:36.000Z","categories_index":"运动仿真","tags_index":"Webots","author_index":"Miraggio"},{"id":"5f63062ce45d7aec6b36bb6e5eaebe8a","title":"HAL_UART中断代码的理解","content":"这其实是对上一节 USART 和 DMA 方面的补充。\n一方面是为了加深对中断代码的了解程度，另一方面是为了补充上一节没有写完的东西。\n我们先重新来看看中断函数的具体结构。\nvoid DR16_Handler(UART_HandleTypeDef *huart)\n&#123;\n\n\tif (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) &amp;&amp;\n\t\t__HAL_UART_GET_IT_SOURCE(huart, UART_IT_IDLE))\n\t&#123;\n\t\t__HAL_UART_CLEAR_IDLEFLAG(huart);\n\t\t__HAL_DMA_DISABLE(huart-&gt;hdmarx);\n\n\t\t&#x2F;&#x2F;if(DR16BufferNumber - DMA_GET_COUNTER(huart-&gt;hdmarx-&gt;Instance) &#x3D;&#x3D; DR16BufferTruthNumber)\n\t\tif (__HAL_DMA_GET_COUNTER(huart-&gt;hdmarx) &#x3D;&#x3D; DR16BufferLastNumber)\n\t\t&#123;\n\t\t\tDR16.DR16_Process(DR16Buffer);\n\t\t&#125;\n\n\t\t__HAL_DMA_SET_COUNTER(huart-&gt;hdmarx, DR16BufferNumber);\n\t\t__HAL_DMA_ENABLE(huart-&gt;hdmarx);\n\t&#125;\n&#125;\n\n在刚进入中断的时候，和基本库一样，代码会先对对应的标志位进行一次判断。\n但是很奇怪的是这里却判断了两个标志位，为什么呢？\n实际上，这两个判断分别是读取在对应的 HAL 库中的 USART 的寄存器中不同的标志位是怎么样的。\n\n_HAL_UART_GET_IT_SOURCE\n  直接读取控制寄存器里面的 CRx 标志位的情况，CRx 位置的寄存器代表的是对应的功能有没有被开启。也就是说和中断是否有发生无关，这句代码的意思只是单纯的判断你有没有启用中断。\n\n\n\n__HAL_UART_GET_FLAG\n  获取 SR 寄存器里面的情况，也就是读取被 CR 控制器控制之后的对应状态，当有中断来临的时候，SR 被置位，同时我们就可以读取是否有中断来临。这个其实和标准库的直接判断中断有没有来临是很像的。也就是说，要成功的触发这个中断，首先是要求你这个中断必须是已经被开启了的，另外一方面是要求你这个中断必须接收到了中断。当两个条件都被满足的时候，中断开启成功。\n\n\n\n__HAL_DMA_GET_COUNTER\n  指的是对应 DMA 获取剩余数据，如果我定义的数据库的大小是 30 个字节，而遥控器对应的字节是 18 个，那么接收完后对应的字节就是 12 个，以此类推。\n\n\n然后下面就是重新设置对应的 DMA 的长度，然后重新使能接收。\n","slug":"cubeMX/HAL_UART中断函数","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"d375d028bb2ac4562b320ed8e131081e","title":"Freertos中队列的使用","content":"1.队列基础学习可自行搜索。\n2.队列的创建HAL库可以生成队列的，但是生成完之后不怎么方便使用，而且是有点BUG，于是我还是使用标准库的形式写。（创建队列必须放在HAL库规定的位置上，不然下次GENERATE时会删掉）\n函数原型：\nxQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize );\n\nuxQueueLength\n\n&gt; 队列能够存储的最大单元数目，即队列深度。\n\nuxItemSize\n\n&gt; 队列中数据单元的长度，以字节为单位。\n\n返回值 NULL\n\n&gt; 表示没有足够的堆空间分配给队列而导致创建失败。非NULL 值表示队列创建成功。此返回值应当保存下来，以作为操作此队列的句柄。\n\n&#x2F;* USER CODE BEGIN RTOS_QUEUES *&#x2F;\n\t  &#x2F;* add queues, ... *&#x2F;\n\t\t&#x2F;&#x2F;创建Can发送队列\n\txQueueCanReceive &#x3D; xQueueCreate(10, sizeof(CAN_RxTypedef));\n\txQueueCanReceive_2 &#x3D; xQueueCreate(10, sizeof(CAN_RxTypedef));\n  &#x2F;* USER CODE END RTOS_QUEUES *&#x2F;\n\nCAN_RxTypedef是用户自定义的一个结构体：\ntypedef struct\n&#123;\n\tuint8_t     CANx;                  &#x2F;&#x2F;CAN编号     1 CAN1      2 CAN2\n\tuint8_t CAN_RxMessage[8];          &#x2F;&#x2F;CAN接收\n\tCAN_RxHeaderTypeDef CAN_RxHeader;  &#x2F;&#x2F;CAN库结构体\n&#125;CAN_RxTypedef;\n\nxQueueCanReceive / xQueueCanReceive_2是队列句柄，保存创建队列后的返回值；\nosMessageQId \txQueueCanReceive;\nosMessageQId \txQueueCanReceive_2;\n\n3.队列的中断接收该函数是放在CAN中断接收里使用，当CAN中断来数据时，会把数据复制到队列里。\nxQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )\n\n&gt;xQueueSendFromISR()完全等同于 xQueueSendToBackFromISR()\n\nxQueue\n\n&gt;目标队列的句柄。这个句柄即是调用 xQueueCreate()创建该队列时的返回值。\n\npvItemToQueue\n\n&gt;发送数据的指针。其指向将要复制到目标队列中的数据单元。由于在创建队列时设置了队列中数据单元的长度，所以会从该指针指向的空间复制对应长度的数据到队列的存储区域。pxHigherPriorityTaskWoken 对某个队列而言，可能有不止一个任务处于阻塞态在等待其数据有效。调用 xQueueSendToFrontFromISR()或 xQueueSendToBackFromISR()会使得队列数据变为有效，所以会让其中一个等待任务切出阻塞态。如果调用这两个 API 函数使得一个任务解除阻塞，并且这个任务的优先级高于当前任务(也就是被中断的任务)，那么 API 会在函数内部将*pxHigherPriorityTaskWoken 设为 pdTRUE。如果这两个 API 函数将此值设为 pdTRUE，则在中断退出前应当进行一次上下文切换。这样才能保证中断直接返回到就绪态任务中优先级最高的任务中。\n\n1. pdPASS返回 pdPASS 只会有一种情况， 那就是数据被成功发送到队列中。\n\n2. errQUEUE_FULL如 果 由 于 队 列 已 满 而 无 法 将 数 据 写 入 ， 则 将 返 回errQUEUE_FULL\n\n\nxQueueSendToBackFromISR(xQueueCanReceive,&amp;CAN_RxMessage,0);&#x2F;&#x2F;把接收数据发给接收队列\n\n4.队列的数据提取在CM里创建一个CAN接收任务，在任务里放入xQueueReceive函数\nBaseType_t xQueueReceive( QueueHandle_t xQueue,\n                          void * const pvBuffer,\n                          TickType_t xTicksToWait );\n\nxQueue\n\n&gt;队列创建时候的句柄，用于表示向哪个队列写入数据；\n\npvBuffer\n\n&gt;从队列读出来的数据指针；\n\nxTicksToWait\n\n&gt;如果队列为空，则为阻塞的最大时间；当被设置为 0 的时候，不阻塞，如果队列为空，则直接返回；如果设置为 portMAX_DELAY 的话，意味着如果队列为空，则会挂起这个任务；\n\nReturn\n\n&gt;当成功读出队列的数据，返回 pdTRUE；否则返回 errQUEUE_EMPTY；\n\n在任务里执行了这个函数后，就可以读取通过该函数copy出来的数据包进行解码。\nvoid CanReceives(void const * argument)\n&#123;\n  &#x2F;* USER CODE BEGIN CanReceives *&#x2F;\n\t  &#x2F;* Infinite loop *&#x2F;\n\tCAN_RxTypedef CanReceiveData;\n\tuint32_t ID;\n\tfor (;;)\n\t&#123;\n\t\t&#x2F;&#x2F;等待队列不为空\n\t\txQueueReceive(xQueueCanReceive, &amp;CanReceiveData, portMAX_DELAY);\n\t\tID &#x3D; CanReceiveData.CAN_RxHeader.StdId;\n\n\t\tif (CanReceiveData.CANx &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tif (ID &gt;&#x3D; M3508_READID_START &amp;&amp; ID &lt;&#x3D; M3508_READID_END)&#x2F;&#x2F;底盘电机\n\t\t\t&#123;\n\t\t\t\tM3508_getInfo(CanReceiveData);\n\t\t\t&#125;\n\t\t\telse if (ID &#x3D;&#x3D; Chassis_IMU_READID)\n\t\t\t&#123;\n\t\t\t\tGY6050_getChassisInfo(CanReceiveData);\n\t\t\t&#125;\n\t\t\telse if (ID &#x3D;&#x3D; M6020_READID_START)\n\t\t\t&#123;\n\t\t\t\tM6020_getInfo(CanReceiveData);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n  &#x2F;* USER CODE END CanReceives *&#x2F;\n&#125;","slug":"cubeMX/cubeMX-Freertos队列","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"56bfdee5a1538a86dab7c1c2d98d1f03","title":"PWR 电源管理系统","content":"1.PVD-电源监控功能1.1.初始化 PWRPWR_PVDTypeDef pvd_config; &#x2F;&#x2F;定义句柄\n\nvoid PVD_Config(void) &#x2F;&#x2F;初始化\n&#123;\n    __HAL_RCC_PWR_CLK_ENABLE(); &#x2F;&#x2F;初始化时钟\n    pvd_config.PVDLevel &#x3D; PWR_PVDLEVEL_7;\n    pvd_config.Mode &#x3D; PWR_PVD_MODE_IT_RISING_FALLING;\n    HAL_PWR_ConfigPVD(&amp;pvd_config);\n    HAL_PWR_EnablePVD(); &#x2F;&#x2F;使能\n\n    HAL_NVIC_EnableIRQ(PVD_IRQn);         &#x2F;&#x2F;使能pvd中断通道\n    HAL_NVIC_SetPriority(PVD_IRQn, 0, 0); &#x2F;&#x2F;抢占优先级0，子优先级0\n&#125;\n\n把 PVD_Config 在初始化任务中调用。\n1.2.中断处理PWR-PVD 功能里官方自带一个处理函数：\n&#x2F;**\n  * @brief This function handles the PWR PVD interrupt request.\n  * @note This API should be called under the PVD_IRQHandler().\n  * @retval None\n  *&#x2F;\nvoid HAL_PWR_PVD_IRQHandler(void)\n&#123;\n  &#x2F;* Check PWR Exti flag *&#x2F;\n  if(__HAL_PWR_PVD_EXTI_GET_FLAG() !&#x3D; RESET)\n  &#123;\n    &#x2F;* PWR PVD interrupt user callback *&#x2F;\n    HAL_PWR_PVDCallback();\n    \n    &#x2F;* Clear PWR Exti pending bit *&#x2F;\n    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();\n  &#125;\n&#125;\n\n从该函数注释可以知道，这个函数要在 PVD_IRQHandler() 里调用，于是我们可以在中断中添加如下函数：\n&#x2F;**\n * @brief 电源监控\n * \n *&#x2F;\nvoid PVD_IRQHandler(void)\n&#123;\n  HAL_PWR_PVD_IRQHandler();\n&#125;\n\n这样当板子的电压出现变化时，会进入这个中断，这时多半都是炸了，于是我们可以在这里添加软复位：\nvoid HAL_PWR_PVDCallback(void) &#x2F;&#x2F;中断回调函数\n&#123;\n    __set_FAULTMASK(1);\n    HAL_NVIC_SystemReset();\n&#125;\n\n参考与致谢\nSTM32 PWR电源管理系统\n\n\nPWR-电源管理系统概述\n\n\nPVD掉电数据存储\n\n\nstm32如何执行软复位\n\n\nSTM32H7如何用HAL库控制产生一个软件复位\n\n","slug":"cubeMX/cubeMX-PWR","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"cubeMX,PWR","author_index":"Miraggio"},{"id":"fe0f1e831ccdde158001439cb8e6d513","title":"设置任务优先级思路，初始化顺序","content":"在实际调车时，pid 参数的确定是一个很重要的一环，导致 pid 参数确定的难度除了自身调参水平，代码合理性，代码逻辑，数据刷新频率，还有优先级等问题。\n如何初始化机器人也是代码稳定性一个很重要的一环，至少要保证机器人在你不希望动的时候不要动，该动的时候才开始启动。\n现在只讲优先级和初始化顺序的问题。\n1.我的Freertos创建的任务如下\n\n2.优先级思路CM 里优先级是封装好的，只有 7 种优先级\n从 osPriorityRealtime~osPriorityldle 依次递减\n一开始 CAN 接收任务的优先级高于主控制任务优先级（Task_CanMsgRece Priority&gt;Task_Control Priority）,但是我发现在调云台电机的时候参数非常难确定，猜想是不是 CAN 接收的任务把我主控制函数打断了。\n我接下来把主控制的优先级调最高后，发现参数正常了起来\nosThreadDef(Task_Control, RobotControl, osPriorityRealtime, 0, 600);\nTask_ControlHandle &#x3D; osThreadCreate(osThread(Task_Control), NULL);\n\n3.初始化顺序机器人在没初始化前是禁止启动的，主要原因是在创建全局变量的时候，默认值是为 0。但机器人上电后的真实值不一定为 0，会导致机器人突然动一下。为了解决这个问题，就要在启动前把机器人真实值赋值给用户定义的全局变量。解决这个问题的原理是在机器人启动前开启机器人必要的通讯，把机器人各种真实值读取进来，等待稳定过后，再把真实值赋值给用户定义的全局变量（上电记住当前位置）\n在标准库的模板中，任务的创建是可以由用户自由配置的，所以通过在一个任务里创建别的任务来解决这个问题。但是在使用 HAL 库创建任务时，任务都是独立的，而且顺序没法由用户修改。\nosThreadDef(Task_Vision, Vision_Sampling, osPriorityHigh, 0, 128);\nTask_VisionHandle &#x3D; osThreadCreate(osThread(Task_Vision), NULL);\n\n&#x2F;* definition and creation of Task_USART *&#x2F;\nosThreadDef(Task_USART, Test, osPriorityBelowNormal, 0, 256);\nTask_USARTHandle &#x3D; osThreadCreate(osThread(Task_USART), NULL);\n\n&#x2F;* definition and creation of Task_WorldTime *&#x2F;\nosThreadDef(Task_WorldTime, WorldTime, osPriorityAboveNormal, 0, 128);\nTask_WorldTimeHandle &#x3D; osThreadCreate(osThread(Task_WorldTime), NULL);\n\n&#x2F;* definition and creation of Task_CanMsgRece *&#x2F;\nosThreadDef(Task_CanMsgRece, CanReceives, osPriorityHigh, 0, 256);\nTask_CanMsgReceHandle &#x3D; osThreadCreate(osThread(Task_CanMsgRece), NULL);\n\n&#x2F;* definition and creation of Task_Init *&#x2F;\nosThreadDef(Task_Init, All_Init, osPriorityNormal, 0, 128);\nTask_InitHandle &#x3D; osThreadCreate(osThread(Task_Init), NULL);\n\n创建的任务都是并列式的，这就造成一个问题，CAN 的优先级低了，初始化任务都执行完了都还没运行，高了又会打断主控制函数的运行。其中一个解决办法可以参考下面优先级排列：\n主控制任务 &gt; 接收任务 &gt; 初始化任务 &gt; 调试任务\n按照这种逻辑，主控制任务就只能放在初始化任务里创建，于是就不能使用 HAL 自动生成，但也仅此一个，其他任务依然可以由HAL生成。\n在这种优先级下，单片机上电必然会先运行接收任务，但是由于使用了队列，任务会被堵塞。接着便会运行初始化任务，初始化任务会开启一系列外设，由于接收任务优先级高于初始化优先级，接收任务开始接收电机等信息。延时2秒后，数据逐渐稳定，便可以进入临界区，保证初始化变量的时候不被打断。接着就可以创建控制任务了，机器人就可以使能了。\nvoid All_Init(void const * argument)\n&#123;\n  &#x2F;* USER CODE BEGIN All_Init *&#x2F;\n\t  &#x2F;* Infinite loop *&#x2F;\n\tRobot.WorkStatus &#x3D; WorkStatus_Disable;\n\tHAL_TIM_PWM_Start(&amp;htim5, TIM_CHANNEL_1);\n\tHAL_TIM_PWM_Start(&amp;htim5, TIM_CHANNEL_2);\n\tHAL_TIM_PWM_Start(&amp;htim5, TIM_CHANNEL_3);\n\t&#x2F;* C615捕获初始化及使能 *&#x2F;\n\tHAL_TIM_IC_Start_IT(&amp;htim4, TIM_CHANNEL_1);\n\tHAL_TIM_IC_Start_IT(&amp;htim4, TIM_CHANNEL_2);\n\tHAL_TIM_IC_Start_IT(&amp;htim4, TIM_CHANNEL_3);\n\tHAL_TIM_IC_Start_IT(&amp;htim4, TIM_CHANNEL_4);\n\tDevicesMonitor_Init();\n\tCAN1_IT_Init();\n\tCAN2_IT_Init();\n\tJudgeSystem_Init();\n\tDR16_USART1_IT_Init();\n\tUSART6_IT_Init();\n\tVision_USART7_IT_Init();     &#x2F;&#x2F;各种外设启动\n\tHAL_Delay(2000);\n\n\ttaskENTER_CRITICAL();&#x2F;&#x2F;进入临界区\n\tRobot_init();\n\tGY6050_Init();\n\tChassis_Init();\n\tCloud_Init();\n\tVision_Init();\n\tShoot_Init();        &#x2F;&#x2F;各种变量初始化\n\n\tosThreadDef(Task_Control, RobotControl, osPriorityRealtime, 0, 600);\n\tTask_ControlHandle &#x3D; osThreadCreate(osThread(Task_Control), NULL);\n\n\tRobot.WorkStatus &#x3D; WorkStatus_Normal;&#x2F;&#x2F;初始化完成，机器人从这里之后才能动。\n\tvTaskDelete(NULL);&#x2F;&#x2F;删除当前任务。\n\ttaskEXIT_CRITICAL();            &#x2F;&#x2F;退出临界区\n  &#x2F;* USER CODE END All_Init *&#x2F;\n&#125;","slug":"FreeRTOS/Task/Task_Priority","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,FreeRTOS","author_index":"Miraggio"},{"id":"4c5c9d96b89531a94360a8185952acf2","title":"CM中CAN的配置，使用，以及启动方法","content":"1.CAN基础配置1.1.CubeMX里的配置CAN 无论是在 RM 的赛场上，还是在 STM32 的使用中，都是比较重要的功能。\n在 RM 中，基本上所有的RM电机都需要使用 CAN 通讯来进行通信。\n在平常使用上，大部分模块都需要使用 CAN。\n而且 CAN 本身也是一种比较重要的通信方式，原因大家也知道，因为他的泛用性比较的广而且模式多，性能好。下面来说明一下如何配置基础的 CAN 通信系统。\n这里我们以 CAN1 的使用为基础，基于上述程序对应的板子进行配置，先点开对应的 CAN1 配置页面\n\n1.2.手动配置Filter功能配置好对应的 CAN1 内存后可以使能对应的 CAN 功能，但是 CAN 的配置有一个很大的问题，就是他只会为你配置 CAN 的最基本的功能，对应剩下的过滤器，也就是 CAN_Filter 的功能需要你自行配置。\n我们可以在 stm32f4xx_hal_can.h 中找到对应的滤波结构体，他分别对应着不同的参数。\n\nCAN_FilterTypeDef 结构体\ntypedef struct\n&#123;\n  uint32_t FilterIdHigh;          &#x2F;*!&lt; Specifies the filter identification number (MSBs for a 32-bit\n                                       configuration, first one for a 16-bit configuration).\n                                       This parameter must be a number between Min_Data &#x3D; 0x0000 and Max_Data &#x3D; 0xFFFF. *&#x2F;\n\n  uint32_t FilterIdLow;           &#x2F;*!&lt; Specifies the filter identification number (LSBs for a 32-bit\n                                       configuration, second one for a 16-bit configuration).\n                                       This parameter must be a number between Min_Data &#x3D; 0x0000 and Max_Data &#x3D; 0xFFFF. *&#x2F;\n\n  uint32_t FilterMaskIdHigh;      &#x2F;*!&lt; Specifies the filter mask number or identification number,\n                                       according to the mode (MSBs for a 32-bit configuration,\n                                       first one for a 16-bit configuration).\n                                       This parameter must be a number between Min_Data &#x3D; 0x0000 and Max_Data &#x3D; 0xFFFF. *&#x2F;\n\n  uint32_t FilterMaskIdLow;       &#x2F;*!&lt; Specifies the filter mask number or identification number,\n                                       according to the mode (LSBs for a 32-bit configuration,\n                                       second one for a 16-bit configuration).\n                                       This parameter must be a number between Min_Data &#x3D; 0x0000 and Max_Data &#x3D; 0xFFFF. *&#x2F;\n\n  uint32_t FilterFIFOAssignment;  &#x2F;*!&lt; Specifies the FIFO (0 or 1U) which will be assigned to the filter.\n                                       This parameter can be a value of @ref CAN_filter_FIFO *&#x2F;\n\n  uint32_t FilterBank;            &#x2F;*!&lt; Specifies the filter bank which will be initialized.\n                                       For single CAN instance(14 dedicated filter banks),\n                                       this parameter must be a number between Min_Data &#x3D; 0 and Max_Data &#x3D; 13.\n                                       For dual CAN instances(28 filter banks shared),\n                                       this parameter must be a number between Min_Data &#x3D; 0 and Max_Data &#x3D; 27. *&#x2F;\n\n  uint32_t FilterMode;            &#x2F;*!&lt; Specifies the filter mode to be initialized.\n                                       This parameter can be a value of @ref CAN_filter_mode *&#x2F;\n\n  uint32_t FilterScale;           &#x2F;*!&lt; Specifies the filter scale.\n                                       This parameter can be a value of @ref CAN_filter_scale *&#x2F;\n\n  uint32_t FilterActivation;      &#x2F;*!&lt; Enable or disable the filter.\n                                       This parameter can be a value of @ref CAN_filter_activation *&#x2F;\n\n  uint32_t SlaveStartFilterBank;  &#x2F;*!&lt; Select the start filter bank for the slave CAN instance.\n                                       For single CAN instances, this parameter is meaningless.\n                                       For dual CAN instances, all filter banks with lower index are assigned to master\n                                       CAN instance, whereas all filter banks with greater index are assigned to slave\n                                       CAN instance.\n                                       This parameter must be a number between Min_Data &#x3D; 0 and Max_Data &#x3D; 27. *&#x2F;\n\n&#125; CAN_FilterTypeDef;\n\n\n这些参数和基本库的结构体是一一对应的。在学习 HAL 库的时候，其实也可以借机巩固一下基本库的知识，强化基本库到 HAL 库上面的代码层的使用。下面是配置 CAN_Filter 其中一个例子：\nvoid CAN1_FILTER_Init(CAN_FilterTypeDef CAN1_Filter)\n&#123;\n\tCAN1_Filter.FilterFIFOAssignment &#x3D; CAN_FILTER_FIFO0;         &#x2F;&#x2F;筛选器被关联到FIFO0\n\tCAN1_Filter.FilterBank &#x3D; 0;                                                              &#x2F;&#x2F;筛选器组0\n\tCAN1_Filter.SlaveStartFilterBank &#x3D; 0;\n\tCAN1_Filter.FilterMode &#x3D; CAN_FILTERMODE_IDMASK;           &#x2F;&#x2F;工作在ID掩码模式\n\tCAN1_Filter.FilterScale &#x3D; CAN_FILTERSCALE_32BIT;                 &#x2F;&#x2F;筛选器位宽为单个32位。\n\tCAN1_Filter.FilterActivation &#x3D; CAN_FILTER_ENABLE;               &#x2F;&#x2F;使能筛选器\n\t\t&#x2F;* 使能筛选器，按照标志的内容进行比对筛选，扩展ID不是如下的就抛弃掉，是的话，会存入FIFO0。 *&#x2F;\n\tCAN1_Filter.FilterIdHigh &#x3D; 0x0000;                                                &#x2F;&#x2F;要筛选的ID高位 \n\tCAN1_Filter.FilterIdLow &#x3D; 0x0000;                                                &#x2F;&#x2F;要筛选的ID低位 \n\tCAN1_Filter.FilterMaskIdHigh &#x3D; 0x0000;                                     &#x2F;&#x2F;筛选器高16位每位不须匹配\n\tCAN1_Filter.FilterMaskIdLow &#x3D; 0x0000;                                      &#x2F;&#x2F;筛选器低16位每位不须匹配\n\tHAL_CAN_ConfigFilter(&amp;hcan1, &amp;CAN1_Filter);\n&#125;\n\n在成功的配置 CAN_Filter 之后，就可以进行初始化：\nvoid CAN1_IT_Init(void)\n&#123;\n\t&#x2F;*使能滤波器*&#x2F;\n\tCAN1_FILTER_Init(CAN1_Filter);\n\t&#x2F;*启用CAN*&#x2F;\n\tHAL_CAN_Start(&amp;hcan1);\n\t&#x2F;*使能CAN的IT中断*&#x2F;\n\t__HAL_CAN_ENABLE_IT(&amp;hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);         &#x2F;&#x2F;  CAN_IT_FMP0\n\n&#125;\n\n2.CAN接收初始化 CAN 结束后，当有数据来时会进入 CAN 中断，于是可以在 CAN 中断中接收数据：\n\n先判断指定的 CAN 中断源是启用还是禁用。\n把接收数据发给接收队列\n再把接收 CAN 的数据到对应解析结构体中。\n清除 CAN 的挂起标志\n\nvoid CAN1_RX0_IRQHandler(void)\n&#123;\n  &#x2F;* USER CODE BEGIN CAN1_RX0_IRQn 0 *&#x2F;\n\tCAN_RxTypedef CAN_RxMessage;\n\tif (__HAL_CAN_GET_IT_SOURCE(&amp;hcan1, CAN_IT_RX_FIFO0_MSG_PENDING))\n\t&#123;\n\t\t&#x2F;*接收CAN的数据到对应解析结构体中*&#x2F;\n\t\tCAN_RxMessage.CANx &#x3D; 1;\n\t\tHAL_CAN_GetRxMessage(&amp;hcan1, CAN_RX_FIFO0,\n\t\t\t&amp;CAN_RxMessage.CAN_RxHeader,\n\t\t\tCAN_RxMessage.CAN_RxMessage);\n\t\t\n    xQueueSendToBackFromISR(xQueueCanReceive,&amp;CAN_RxMessage,0);&#x2F;&#x2F;把接收数据发给接收队列\n\n\t\t__HAL_CAN_CLEAR_FLAG(&amp;hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);\n\t&#125;\n  &#x2F;* USER CODE END CAN1_RX0_IRQn 0 *&#x2F;\n  HAL_CAN_IRQHandler(&amp;hcan1);\n  &#x2F;* USER CODE BEGIN CAN1_RX0_IRQn 1 *&#x2F;\n\n  &#x2F;* USER CODE END CAN1_RX0_IRQn 1 *&#x2F;\n&#125;\n\n这时便完成一次 CAN 数据的接收。\n3.CAN发送3.1.自定义发送函数通过调用HAL库的函数来发送\n&#x2F;**\n  * @brief  Add a message to the first free Tx mailbox and activate the\n  *         corresponding transmission request.\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\n  *         the configuration information for the specified CAN.\n  * @param  pHeader pointer to a CAN_TxHeaderTypeDef structure.\n  * @param  aData array containing the payload of the Tx frame.\n  * @param  pTxMailbox pointer to a variable where the function will return\n  *         the TxMailbox used to store the Tx message.\n  *         This parameter can be a value of @arg CAN_Tx_Mailboxes.\n  * @retval HAL status\n  *&#x2F;\nHAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, CAN_TxHeaderTypeDef *pHeader, uint8_t aData[], uint32_t *pTxMailbox)\n\n函数作用：向第一个空闲的Tx邮箱添加一条消息，并激活*相应的传输请求。\n\nThe first parameter：can指针指向一个CAN_HandleTypeDef结构，该结构包含*指定CAN的配置信息。（一般是调用CM生成的句柄：&amp;hcanx）\nSecond parameter：指向CAN_TxHeader TypeDef结构的pHeader指针。（设置发送的ID，ID类型，数据长度等）\nThe third parameter：包含Tx帧有效载荷的aData数组。（需要发送的数据）\nThe fourth parameter：pTxMailbox指向变量的指针，函数将在其中返回*用于存储Tx消息的TxMailbox。                                此参数可以是@arg CAN_Tx_Mailboxes的值。（返回发送邮箱的序号）\n\n\n\n于是可以自定义一个函数方便我们调用该函数执行\nvoid CAN_SendData(CAN_HandleTypeDef* CANx, uint8_t id_type, uint32_t id, uint8_t data[8])  \n&#123;\t  \n\tCAN_TxHeaderTypeDef TxMessage;\n\t\n\tif(id_type &#x3D;&#x3D; CAN_ID_STD)&#123;\n\t\tTxMessage.StdId &#x3D; id;\t\t\t\t\t\t \n\t&#125;\n\telse&#123;\n\t\tTxMessage.ExtId &#x3D; id;\t\t\t\t\t &#x2F;&#x2F;ID号\n\t&#125;\n\t\n\tTxMessage.IDE &#x3D; id_type;\t\t\t\t\t &#x2F;&#x2F;ID类型\n\tTxMessage.RTR &#x3D; CAN_RTR_DATA;\t\t\t\t &#x2F;&#x2F;发送的为数据\n\tTxMessage.DLC &#x3D; 0x08;\t\t\t\t\t\t &#x2F;&#x2F;数据长度为8字节\n\tTxMessage.TransmitGlobalTime &#x3D; DISABLE;\n\t\n\tHAL_CAN_AddTxMessage(CANx,&amp;TxMessage,data,(uint32_t*)CAN_TX_MAILBOX0);\n&#125;\n\n3.2.发送例子&#x2F;*************************************\n* Method:    CAN_0x200_SendData\n* Returns:   void\n* Parameter: int16_t iq1，参数值。\n* 说明：0x200报文的统一发送函数—— 控制3508的ID：1-4电机，2006的1-4\n************************************&#x2F;\nvoid CAN_0x200_SendData(CAN_HandleTypeDef* CAN_Num,int16_t iq1, int16_t iq2, int16_t iq3, int16_t iq4) &#123;\n\n\tuint8_t data[8];\n\n\t&#x2F;&#x2F;数据格式详见说明书P32\n\tdata[0] &#x3D; iq1 &gt;&gt; 8;\n\tdata[1] &#x3D; iq1;\n\tdata[2] &#x3D; iq2 &gt;&gt; 8;\n\tdata[3] &#x3D; iq2;\n\tdata[4] &#x3D; iq3 &gt;&gt; 8;\n\tdata[5] &#x3D; iq3;\n\tdata[6] &#x3D; iq4 &gt;&gt; 8;\n\tdata[7] &#x3D; iq4;\n\n\tCAN_SendData(CAN_Num, CAN_ID_STD, 0x200, data);\n\n&#125;\n\n发送函数调用\nCAN_0x200_SendData(&amp;hcan1, M3508s[0].outCurrent, M3508s[1].outCurrent, M3508s[2].outCurrent, M3508s[3].outCurrent);&#x2F;&#x2F;底盘电机(3508)","slug":"cubeMX/cubeMX-AllCAN/CAN","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"ba66d244f8bb441b69f53a62936b94c6","title":"CM中的DMA配置简述","content":"DMA 一般是和 USART 一起使用的，但是由于 DMA 中各种奇奇怪怪的坑，导致在实际上使用的时候会出现这里不行，那里不行，各种各样的问题和 BUG。其实 DMA 这部分是比较难以解释的，在写这个笔记之前我看过网上很多的对于 DMA 配置和相关内容的解释，都讲的很笼统，或者说没有讲到我想要问的点上。\n通过很长的一段时间我终于解决了 DMA 的各种各样的问题，我打算以我自己理解的方式来解释一下到底怎么才可以正确的使用 DMA！\n1.DMA 配置首先的配置，DMA 在 CM 中的配置方式有很多种，比如说你可以直接电机 SystemCore 中的 DMA 来配置，也可以直接在USART的界面进行配置。\n这里我以直接在 USART 界面配置为例，选中 USART 界面中的 DMA Setting 即可进行配置：\n\n\n点击其中一个 DMA 之后可以看到里面对应的信息，以及模式的处理，设置等等。这些其实和标准库的设置是一样的。\n同样，配置后可以看到对应的模块在 SystemView 中显示出来，并更改其中对应的配置。\n\n随后生成代码即可。\n\n\n\n\n\n\n\n\n\n这里不列出对应的 DMA 启动代码和常用，原因会在 USART 和 DMA 配置遥控器的那张进行详细的说明（因为 DMA 有点坑）。后面会有一章详细说明如何配置 DMA 的。\n","slug":"cubeMX/cubeMX-AllDMA/DMA","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"bc39b63ca62620f2c1763c0a6dd974d2","title":"CM中Freertos配置，使用","content":"1.Freertos基础配置随着STM32的相关开发工具越趋完善，现在只需要一些简单的操作便可以在STM32上运行FreeRTOS，今天让我们来看看基于STM32的开发工具STM32CubeMX如何新建基于FreeRTOS的工程。\n1.1.Freertos界面介绍在CM里点开Freertos界面后，选择CMSIS_V1/CMSIS_V2接口。\n\n选择完接口后，来到配置窗口\n\n1.2.Freertos配置首先要修改Include parameters里的内容，根据自己的需求而定\n本人改成下图所示：\n\n接着修改Tasks and Queues里的内容，点击右下角的Add，即可新建函数\n\n创建任务时要注意个任务之间的优先级，初始化顺序\n设置任务优先级思路，初始化顺序\n根据自己的需求创建任务后，可以在FreeRTOS Heap Usage查看使用的堆大小情况。\n\n但是当你点击Generate code时，CubeMX会报警告\n\n这是因为HAL和Rtos使用同一个时钟源了。\n可以在Timebase Source里选择其中一个TIM就行了，这里建议使用基本定时器就可以了。\n\n2.Freertos使用利用STM32CudeMX配置后，任务会自动创建，任务定义在freertos.c中，可直接在任务体中编写任务。\nvoid Test(void const * argument)\n&#123;\n  &#x2F;* USER CODE BEGIN Test *&#x2F;\n\t  &#x2F;* Infinite loop *&#x2F;\n\tfor (;;)\n\t&#123;\n\t\tDebug_addData(VisionData.RawData.x, 1);\n\t\tDebug_addData(VisionData.RawData.y, 2);\n\t\tDebug_addData(VisionData.FPS, 3);\n\t\tDebug_show(3);\n\n\t\tosDelay(5);\n\t&#125;\n  &#x2F;* USER CODE END Test *&#x2F;\n&#125;\n\n例如说这个任务，每5s向上位机发送数据，接线没问题后，出来的结果：\n\n参考与致谢\n时钟源报错\n\n","slug":"cubeMX/cubeMX-AllFRTOS/Freertos","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"fdaeef215bccf348abd53466e04935a5","title":"CM中的模块启动函数，中断配置，配置技巧，方式格式","content":"这张实际上为了补上前面没有说明的内容而写的，也是我写到上一章的时候突然发现没写的内容，这里进行补充。\n首先是一直以来提到却没有详细说的模块启动。\n1.模块启动函数什么是模块启动函数呢？\n在我们生成代码的时候，HAL 只是会帮我们配置好对应的东西，而真正的是否使用这个模块是由我们自己决定的，打个比方，我配置一个 USART1 的中断，配置好之后点击生成代码。但是此时如果直接烧录运行的话，你会发现 USART1 并没有和我们想象的那样子发生中断，取而代之的是什么都没有发生。\n为什么会什么都没有发生呢，是因为我们只是配置好了对应层和对应模块，但是并没有使能它。这个其实和标准库有一点点的区别（其实也可以说没有区别）。那么如何正确的使能它呢，我们需要加上对应的启动函数，不同的模块的启动函数是不同的，如同上面的例子，为了正确的使得 USART1 进行空闲中断运行，我们需要加上：\n__HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_IDLE);\n\n在启动区域中，以保证在代码烧录的时候正确的运行。\n其实这个和分离 Init 函数的道理是一样的，类比于基本库的话，就是其他配置都写好了但是 Init 还没有写上去，这个 Init 函数将由你来写。而转变成HAL库就是另外一种的写法。\n启动函数可以写在代码的任何地方，只要你能运行到对应的函数，那么对应模块的对应功能将被启用，大部分的外设都具备启动函数的。\n2.中断配置中断配置，这里多嘴一句就是可以在任何的模块能触发中断的模块上进行配置，能触发中断的模块在配置的区块上都会有 NVIC Setting 的小格，可以方便你进行配置。顺带一提就是对应中断的配置间的设置要看清楚不然容易出事或者冲突。\n从 HAL 可以进入中断界面管理所有中断\n\n\n\n3.配置技巧配置技巧方面，我们可以先想好我们所需要的中断，排列好对应的优先级（当你使用的是中断系统的时候），然后再统一进行配置，切记不要配置的过程中东改一下西改一下，否则有可能造成优先级混乱的问题。\n4.方式格式方式格式，这个是因人而异的，不同的排版格式决定着你代码的美观和质量，一个优秀的代码格式会让别人看你的代码的时候，无论是理解过程还是编写过程都会大大加分。\n","slug":"cubeMX/cubeMX-AllNVIC/NVIC","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"895faf6251973f9e387856457d39661f","title":"Project Manager中的基础属性配置","content":"1.初始配置截图这个是在我们 Project Manager 栏中的代码生成配置模块的状态修改。\n\n\n","slug":"cubeMX/cubeMX-AllPoject/Project_Manager","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"239cc6a44ffbf4459edfad41793cd530","title":"单片机初始化，RCC时钟树完整配置的方式和详细过程","content":"1.创建工程首先理所当然的，我们需要知道板子对应的型号是怎么样的，只有调整对了板子型号后面的代码才比较好搞，板子型号一般可以从芯片那个地方看到（一般是写在芯片上面的，由于是反光的，你需要一点小技巧才可以看到，比如说手机的手电筒或者一些别的方法）。\n知道板子型号之后，我们就可以直接在 CubeMX 上面创建对应的型号的工程。打个比方，我需要创建一个 STM32F427VITx 的板子的工程，那么步骤如下:\n\n\n\n2.配置RCC创建好工程之后，我们需要优先配置对应的板子的外部工程树，以方便我们后期使用板子的功能，下面依旧是以 STM32F427VITx 为例来进行配置。\n在配置时钟树之前，我们还需要配置两个步骤，第一个就是把板子的模式设置为允许外部连接，方便我们调试和烧录，仿真检查。另外一个就是把板子的时钟调整成为外部时钟模式，也就是 HSE。\n下面来说如何配置两个对应的模式：\n\n首先点开 SYS，将 DEBUG 选项中的Disable调整成为 Serial Wire，这个是方便我们调整出对应的串口来进行烧录程序。\n \n\n\n\n然后是第二步，点到 RCC 部分，然后把 HSE 的 Disable 设置成为 Crystal/Ceramic Resonator，也就是把板子内的外部时钟作为板子的当前板子主要时钟分频。\n \n\n\n完成这两步之后的主要配置就完成了，接下来是配置时钟树。\n3.配置时钟树配置时钟树是极为关键的一步，正确的配置时钟树能够给后面你使用对应模块的时候打下基础。如果你时钟树配置错误的话很可能会导致你后面的某一些模块不能够正常的使用！！\n首先我们需要知道的是，我手上的这个板子的对应的分频是多少，一看到时钟树上面那么多参数难免会感到很难受，所以我们要找到对应的合适的参数来进行设置。\n还是以上面的板子为例，通过查找原理图可以发现，板子对应的时钟的分频为 12MHZ，固在左边选择 HSE后，填入 12MHZ，HCLK 填入最大值 168 即可。\n\n\n以上就配置完毕了，接下来就可以自定义你自己的模块了。\n4.总结我的个人习惯的话，是通常会把同时生成 .c和.h配对生成勾选上的，以及生成代码的时候我会习惯于只生成对一个的 binary 库，这样子的话方便编译而且可以很好的加速。不过配置选择因人而异吧，也不一定说你一定要学我的配置方式，建议多生成自己代码，找到自己喜欢的配置方式会比较的好。\n参考与致谢\nSTM32开发笔记18: STM32CubeMX中Debug Serial Wire的设置问题\n\nSTM32系统学习——RCC（使用HSE/HSI配置时钟）\n\n\n","slug":"cubeMX/cubeMX-AllRCC/RCC","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"4db5497cbecd2cc278cbb61ec8b5e452","title":"CM中TIM定时器的配置，以及启动方法","content":"1.用HAL配置TIM的选项设置接着上一个工程继续进行编辑，由于 TIM 的高级定时器和低级定时器的界面是不同的，所以改动的方法和方式也是不同的，先由高级定时器开始理解。\n这里直接使用一张图来理解高级定时器的作用：\n\n\n\n\n低级定时器就比较的简单，可以直接使能一个按键的的方法来进行配置：\n\n一次触发模式就是只执行一次中断的模式，不过由于不太常用所以经常被人忽略。\n由于高级定时器和低级定时间需要输入的数据一般存在区别，为了泛用性所以这里只是解释一下比较常用的数据和功能。一下将会列出比较常用的功能。\n\n\n以及溢出时间计算公式：\nTout = TimeFiliter/PSC*ARR；\nTout = （(PSC+1)/TimeFiliter）*（1+ARR）\nTimeFiliter：对应挂载时钟频率\nPSC：分频系数\nARR：重装载值，也就是Period。\n注意计算结果永远是微秒us。\n\n\n2.具体功能实现2.1.四通道输入捕获 HAL 库版本的写法与封装（作用于好盈电调传感器）2.1.1.HAL 库的配置这里我是使用 TIM4 输入作为例子\n\n四通道配置为输入捕获，F4 定时器时钟为 90Mhz。\n要以 1Mhz 的频率检测，于是 psc 分频设置为 89，arr 为 65535。\n\n中断配置成全局中断，捕获到电平后会进入中断。\n2.2.代码实现2.2.1.外部控制代码&#x2F;**\n* @brief 获取C615速度\n* @param argument: Not used\n* @retval None\n*&#x2F;\nvoid C615_ObtainSpeed(TIMxCHx_CAPTURE_t *TIMxCHx_CAPTURE, Snail_t *Snail_Power)\n&#123;\n\tif (TIMxCHx_CAPTURE-&gt;STA &amp; 0X80)\t\t\t&#x2F;&#x2F;成功捕获到了一次高电平\n\t&#123;\n\t\tTIMxCHx_CAPTURE-&gt;temp &#x3D; TIMxCHx_CAPTURE-&gt;STA &amp; 0X3F;\n\t\tTIMxCHx_CAPTURE-&gt;temp *&#x3D; 65536;\t\t\t\t\t\t&#x2F;&#x2F;溢出时间总和\n\t\tTIMxCHx_CAPTURE-&gt;temp +&#x3D; TIMxCHx_CAPTURE-&gt;Date2;\n\t\tTIMxCHx_CAPTURE-&gt;temp -&#x3D; TIMxCHx_CAPTURE-&gt;Date1;\t\t&#x2F;&#x2F;得到总的高电平时间\n\t\tif (abs(TIMxCHx_CAPTURE-&gt;temp) &gt; 500)           &#x2F;&#x2F;避免\n\t\t&#123;\n\t\t\tSnail_Power-&gt;realSpeed &#x3D; Snail_Power-&gt;realSpeed;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tSnail_Power-&gt;realSpeed &#x3D; TIMxCHx_CAPTURE-&gt;temp; \n\t\t&#125;\n\t\tTIMxCHx_CAPTURE-&gt;Date1 &#x3D; 0;\n\t\tTIMxCHx_CAPTURE-&gt;STA &#x3D; 0;\t\t\t\t&#x2F;&#x2F;开启下一次捕获\n\t&#125;\n&#125;\n\n此代码放在固定频率控制函数里执行，获取高电平的时间。\nC615_ObtainSpeed(&amp;TIM4CH1_CAPTURE,&amp;Snail_PowerL);\nC615_ObtainSpeed(&amp;TIM4CH2_CAPTURE, &amp;Snail_PowerR);  &#x2F;&#x2F;调用过程\n\n2.2.2捕获函数调用与封装&#x2F;**\n  * @brief This function handles TIM4 global interrupt.\n  *&#x2F;\nvoid TIM4_IRQHandler(void)\n&#123;\n  &#x2F;* USER CODE BEGIN TIM4_IRQn 0 *&#x2F;\n\tC615_CaptureSpeed(TIM4, One);   &#x2F;&#x2F;捕获电平\n  &#x2F;* USER CODE END TIM4_IRQn 0 *&#x2F;\n  HAL_TIM_IRQHandler(&amp;htim4);\n  &#x2F;* USER CODE BEGIN TIM4_IRQn 1 *&#x2F;\n\n  &#x2F;* USER CODE END TIM4_IRQn 1 *&#x2F;\n&#125;\n\n\n其中 TIM 中断捕获函数封装\nvoid C615_CaptureSpeed(TIM_TypeDef * TIMx, uint8_t One_Two)\n&#123;\n\tC615_CaptureSpeed_CH1CH2(TIMx, &amp;TIM4CH1_CAPTURE, &amp;TIM4CH2_CAPTURE);\n\tif (One_Two &#x3D;&#x3D; Two)\n\t&#123;\n\t\tC615_CaptureSpeed_CH3CH4(TIMx, &amp;TIM4CH3_CAPTURE, &amp;TIM4CH4_CAPTURE);\n\t&#125;\n\n\tTIMx-&gt;SR &#x3D; 0;&#x2F;&#x2F;清除中断标志位 \n&#125;\n\n&#x2F;**\n* @brief 捕获第一组C615速度\n* @param argument: Not used\n* @retval None\n*&#x2F;\nvoid C615_CaptureSpeed_CH1CH2(TIM_TypeDef * TIM, TIMxCHx_CAPTURE_t *TIMxCH1_CAPTURE, TIMxCHx_CAPTURE_t *TIMxCH2_CAPTURE)\n&#123;\n\tuint16_t tsr;\n\ttsr &#x3D; TIM-&gt;SR;\n\t&#x2F;&#x2F;CH1中断处理\n\tif ((TIMxCH1_CAPTURE-&gt;STA &amp; 0X80) &#x3D;&#x3D; 0)&#x2F;&#x2F;还未成功捕获\t\n\t&#123;\n\t\tif (tsr &amp; 0X01)&#x2F;&#x2F;溢出\n\t\t&#123;\n\t\t\tif (TIMxCH1_CAPTURE-&gt;STA &amp; 0X40)&#x2F;&#x2F;已经捕获到高电平了\n\t\t\t&#123;\n\t\t\t\tif ((TIMxCH1_CAPTURE-&gt;STA &amp; 0X3F) &#x3D;&#x3D; 0X3F)&#x2F;&#x2F;高电平太长了\n\t\t\t\t&#123;\n\t\t\t\t\tTIMxCH1_CAPTURE-&gt;STA |&#x3D; 0X80;&#x2F;&#x2F;标记成功捕获了一次\n\t\t\t\t\tTIMxCH1_CAPTURE-&gt;Date2 &#x3D; 0XFFFF;\n\t\t\t\t&#125;\n\t\t\t\telse TIMxCH1_CAPTURE-&gt;STA++;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (tsr &amp; 0x02)&#x2F;&#x2F;捕获1发生捕获事件\n\t\t&#123;\n\t\t\tif (TIMxCH1_CAPTURE-&gt;STA &amp; 0X40)\t\t&#x2F;&#x2F;捕获到一个下降沿 \t\t\n\t\t\t&#123;\n\t\t\t\tTIMxCH1_CAPTURE-&gt;STA |&#x3D; 0X80;\t\t&#x2F;&#x2F;标记成功捕获到一次高电平脉宽\n\t\t\t\tTIMxCH1_CAPTURE-&gt;Date2 &#x3D; TIM-&gt;CCR1;\t&#x2F;&#x2F;获取当前的捕获值.\n\t\t\t\tTIM-&gt;CCER &amp;&#x3D; ~(1 &lt;&lt; 1);\t\t\t&#x2F;&#x2F;CC1P&#x3D;0 设置为上升沿捕获\n\t\t\t&#125;\n\t\t\telse  \t\t\t\t\t\t\t\t&#x2F;&#x2F;还未开始,第一次捕获上升沿\n\t\t\t&#123;\n\t\t\t\tTIMxCH1_CAPTURE-&gt;Date2 &#x3D; 0;\n\t\t\t\tTIMxCH1_CAPTURE-&gt;STA &#x3D; 0X40;\t\t&#x2F;&#x2F;标记捕获到了上升沿\n\t\t\t\tTIMxCH1_CAPTURE-&gt;Date1 &#x3D; TIM-&gt;CCR1;\n\t\t\t\tTIM-&gt;CCER |&#x3D; 1 &lt;&lt; 1; \t\t\t\t&#x2F;&#x2F;CC1P&#x3D;1 设置为下降沿捕获 \n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;CH2中断处理\n\tif ((TIMxCH2_CAPTURE-&gt;STA &amp; 0X80) &#x3D;&#x3D; 0)&#x2F;&#x2F;还未成功捕获\t\n\t&#123;\n\t\tif (tsr &amp; 0X01)&#x2F;&#x2F;溢出\n\t\t&#123;\n\t\t\tif (TIMxCH2_CAPTURE-&gt;STA &amp; 0X40)&#x2F;&#x2F;已经捕获到高电平了\n\t\t\t&#123;\n\t\t\t\tif ((TIMxCH2_CAPTURE-&gt;STA &amp; 0X3F) &#x3D;&#x3D; 0X3F)&#x2F;&#x2F;高电平太长了\n\t\t\t\t&#123;\n\t\t\t\t\tTIMxCH2_CAPTURE-&gt;STA |&#x3D; 0X80;&#x2F;&#x2F;标记成功捕获了一次\n\t\t\t\t\tTIMxCH2_CAPTURE-&gt;Date2 &#x3D; 0XFFFF;\n\t\t\t\t&#125;\n\t\t\t\telse TIMxCH2_CAPTURE-&gt;STA++;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (tsr &amp; 0x04)&#x2F;&#x2F;捕获1发生捕获事件\n\t\t&#123;\n\t\t\tif (TIMxCH2_CAPTURE-&gt;STA &amp; 0X40)\t\t&#x2F;&#x2F;捕获到一个下降沿 \t\t\n\t\t\t&#123;\n\t\t\t\tTIMxCH2_CAPTURE-&gt;STA |&#x3D; 0X80;\t\t&#x2F;&#x2F;标记成功捕获到一次高电平脉宽\n\t\t\t\tTIMxCH2_CAPTURE-&gt;Date2 &#x3D; TIM-&gt;CCR2;\t&#x2F;&#x2F;获取当前的捕获值.\n\t\t\t\tTIM-&gt;CCER &amp;&#x3D; ~(1 &lt;&lt; 5);\t\t\t&#x2F;&#x2F;CC1P&#x3D;0 设置为上升沿捕获\n\t\t\t&#125;\n\t\t\telse  \t\t\t\t\t\t\t\t&#x2F;&#x2F;还未开始,第一次捕获上升沿\n\t\t\t&#123;\n\t\t\t\tTIMxCH2_CAPTURE-&gt;Date2 &#x3D; 0;\n\t\t\t\tTIMxCH2_CAPTURE-&gt;STA &#x3D; 0X40;\t\t&#x2F;&#x2F;标记捕获到了上升沿\n\t\t\t\tTIMxCH2_CAPTURE-&gt;Date1 &#x3D; TIM-&gt;CCR2;\n\t\t\t\tTIM-&gt;CCER |&#x3D; 1 &lt;&lt; 5; \t\t\t\t&#x2F;&#x2F;CC1P&#x3D;1 设置为下降沿捕获 \n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n&#x2F;**\n* @brief 捕获第二组C615速度\n* @param argument: Not used\n* @retval None\n*&#x2F;\nvoid C615_CaptureSpeed_CH3CH4(TIM_TypeDef * TIM, TIMxCHx_CAPTURE_t *TIMxCH3_CAPTURE, TIMxCHx_CAPTURE_t *TIMxCH4_CAPTURE)\n&#123;\n\tuint16_t tsr;\n\ttsr &#x3D; TIM-&gt;SR;\n\t&#x2F;&#x2F;CH3中断处理\n\tif ((TIMxCH3_CAPTURE-&gt;STA &amp; 0X80) &#x3D;&#x3D; 0)&#x2F;&#x2F;还未成功捕获\t\n\t&#123;\n\t\tif (tsr &amp; 0X01)&#x2F;&#x2F;溢出\n\t\t&#123;\n\t\t\tif (TIMxCH3_CAPTURE-&gt;STA &amp; 0X40)&#x2F;&#x2F;已经捕获到高电平了\n\t\t\t&#123;\n\t\t\t\tif ((TIMxCH3_CAPTURE-&gt;STA &amp; 0X3F) &#x3D;&#x3D; 0X3F)&#x2F;&#x2F;高电平太长了\n\t\t\t\t&#123;\n\t\t\t\t\tTIMxCH3_CAPTURE-&gt;STA |&#x3D; 0X80;&#x2F;&#x2F;标记成功捕获了一次\n\t\t\t\t\tTIMxCH3_CAPTURE-&gt;Date2 &#x3D; 0XFFFF;\n\t\t\t\t&#125;\n\t\t\t\telse TIMxCH3_CAPTURE-&gt;STA++;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (tsr &amp; 0x08)&#x2F;&#x2F;捕获1发生捕获事件\n\t\t&#123;\n\t\t\tif (TIMxCH3_CAPTURE-&gt;STA &amp; 0X40)\t\t&#x2F;&#x2F;捕获到一个下降沿 \t\t\n\t\t\t&#123;\n\t\t\t\tTIMxCH3_CAPTURE-&gt;STA |&#x3D; 0X80;\t\t&#x2F;&#x2F;标记成功捕获到一次高电平脉宽\n\t\t\t\tTIMxCH3_CAPTURE-&gt;Date2 &#x3D; TIM-&gt;CCR3;\t&#x2F;&#x2F;获取当前的捕获值.\n\t\t\t\tTIM-&gt;CCER &amp;&#x3D; ~(1 &lt;&lt; 9);\t\t\t&#x2F;&#x2F;CC1P&#x3D;0 设置为上升沿捕获\n\t\t\t&#125;\n\t\t\telse  \t\t\t\t\t\t\t\t&#x2F;&#x2F;还未开始,第一次捕获上升沿\n\t\t\t&#123;\n\t\t\t\tTIMxCH3_CAPTURE-&gt;Date2 &#x3D; 0;\n\t\t\t\tTIMxCH3_CAPTURE-&gt;STA &#x3D; 0X40;\t\t&#x2F;&#x2F;标记捕获到了上升沿\n\t\t\t\tTIMxCH3_CAPTURE-&gt;Date1 &#x3D; TIM-&gt;CCR3;\n\t\t\t\tTIM-&gt;CCER |&#x3D; 1 &lt;&lt; 9; \t\t\t\t&#x2F;&#x2F;CC1P&#x3D;1 设置为下降沿捕获 \n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;CH4中断处理\n\tif ((TIMxCH4_CAPTURE-&gt;STA &amp; 0X80) &#x3D;&#x3D; 0)&#x2F;&#x2F;还未成功捕获\t\n\t&#123;\n\t\tif (tsr &amp; 0X01)&#x2F;&#x2F;溢出\n\t\t&#123;\n\t\t\tif (TIMxCH4_CAPTURE-&gt;STA &amp; 0X40)&#x2F;&#x2F;已经捕获到高电平了\n\t\t\t&#123;\n\t\t\t\tif ((TIMxCH4_CAPTURE-&gt;STA &amp; 0X3F) &#x3D;&#x3D; 0X3F)&#x2F;&#x2F;高电平太长了\n\t\t\t\t&#123;\n\t\t\t\t\tTIMxCH4_CAPTURE-&gt;STA |&#x3D; 0X80;&#x2F;&#x2F;标记成功捕获了一次\n\t\t\t\t\tTIMxCH4_CAPTURE-&gt;Date2 &#x3D; 0XFFFF;\n\t\t\t\t&#125;\n\t\t\t\telse TIMxCH4_CAPTURE-&gt;STA++;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (tsr &amp; 0x10)&#x2F;&#x2F;捕获1发生捕获事件\n\t\t&#123;\n\t\t\tif (TIMxCH4_CAPTURE-&gt;STA &amp; 0X40)\t\t&#x2F;&#x2F;捕获到一个下降沿 \t\t\n\t\t\t&#123;\n\t\t\t\tTIMxCH4_CAPTURE-&gt;STA |&#x3D; 0X80;\t\t&#x2F;&#x2F;标记成功捕获到一次高电平脉宽\n\t\t\t\tTIMxCH4_CAPTURE-&gt;Date2 &#x3D; TIM-&gt;CCR4;\t&#x2F;&#x2F;获取当前的捕获值.\n\t\t\t\tTIM-&gt;CCER &amp;&#x3D; ~(1 &lt;&lt; 13);\t\t\t&#x2F;&#x2F;CC1P&#x3D;0 设置为上升沿捕获\n\t\t\t&#125;\n\t\t\telse  \t\t\t\t\t\t\t\t&#x2F;&#x2F;还未开始,第一次捕获上升沿\n\t\t\t&#123;\n\t\t\t\tTIMxCH4_CAPTURE-&gt;Date2 &#x3D; 0;\n\t\t\t\tTIMxCH4_CAPTURE-&gt;STA &#x3D; 0X40;\t\t&#x2F;&#x2F;标记捕获到了上升沿\n\t\t\t\tTIMxCH4_CAPTURE-&gt;Date1 &#x3D; TIM-&gt;CCR4;\n\t\t\t\tTIM-&gt;CCER |&#x3D; 1 &lt;&lt; 13; \t\t\t\t&#x2F;&#x2F;CC1P&#x3D;1 设置为下降沿捕获 \n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t\n&#125;\n\n\n3.精确控制PWM脉冲量3.1.配置主输出定时器先按照普通 PWM 输出配置，需要改动是其中的模式。\n\n3.2.配置从定时器主从定时器之前的关系是固定的，在手册上可以查到。我这里用的是 F407 的图。\n\n\n例如：假如让 TIM8 作为从定时器，那么其时钟源有 ITR0，ITR1，ITR2，ITR3，分别对应着不同的主定时器，选择需要的主定时器就要按照上面标的时钟源。\n\n记得要把中断也打开。\n3.3.用户启动代码主定时器方面使用 PWM 启动的函数启动，从定时器用开始定时器中断函数启动。\n HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_x);\n__HAL_TIM_CLEAR_IT(&amp;htimx, TIM_IT_UPDATE);\n HAL_TIM_Base_Start_IT(&amp;htimx);\n\n这里为什么要加上清除中断标志位呢，因为从定时器就是通过计数 PWM 直到溢出才会产生更新中断，所以一开始要先清标志位，否则开机就会进一次更新中断。\n4.多路PWM脉冲精准控制4.1.多路 PWM 控制思路  按照上面的方法，虽然也可以精确控制脉冲，但是从定时器计数是算脉冲的数量的，没有办法同时控制多路不同的 PWM 输出。于是可以先把从定时器的通道改成比较不输出模式，让各个通道 CCR 寄存器与 CNT 作比较，只要计数到了便产生一个中断，在中断里可以控制输出 PWM 占空比，只要占空比为 0 了就几乎等于是可以认为不输出了（至少我遇到电机占空比为 0 了就不动了），于是便可以使用一个定时器控制多个设备了。但是要产生中断前提是 CCR 值必须大于等于 CNT 的值，否则要等到 CNT 溢出了才可以产生中断。\n  按照下面的机制，我们可以需要脉冲输出的时候，获取当前 CNT 的值，然后我们的总目标值是：当前值+需要目标值，等到中断产生了就可以把占空比归0。但是这样方法又会有一个问题，假设你给的脉冲值不变，当 CNT 溢出的时候，便会一直输出脉冲，这样就会导致一直循环，这时候需要过零处理。\n4.2.过零处理4.2.1.计圈数  就是每当 CNT 值大于设定值而溢出时，可以使用一个变量把多余的值以圈数形式记录起来，理论值 = （圈数*最大值）+（当前值）。但是缺点就是只要数据足够大，还是会溢出，对于长时间工作的设备来说不适合。\n4.2.2.直接减周期  当 CNT 溢出时，会产生一个更新中断，我们可以在中断里，使一个标志位置1，之后我们可以把所有设备的底层都统一种解算，判断当该标志位置1的时候，当前的总路程-最大值，在输出最大值。\n","slug":"cubeMX/cubeMX-AllTIM/TIM","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"20f9345191bccef7afe482693ca5ca5c","title":"CM中USART和DMA的实际关系（DR16为例）","content":"第一是因为 USART 和 DMA 在 RM 比赛中属于比较常用的模块，需要详细的了解清楚对应的方法。\n第二是因为 USART 和 DMA 的配置实在是太坑了，我自己在这里也磨了将近 1 个星期的时间，这一个星期的时间我收集和分析网上各种各样的例子，以及对 HAL 的程序进行了阅读。\n第三是因为 “DMA” 不是 USART 的 DMA，这句话是啥意思呢？先卖个关子好了。\n为了让你们比较详细的了解，我将基于 DR16遥控器的代码调试，结合我的试错过程一步一步的对 DMA 中各种各样的坑进行解释：\n1.第一次尝试：（失败）在 HAL 中进行最基础的配置，在配置好 USART1 的基础上配置了 DMA_RX 的接收（USART1 的 IDLE 中断功能已经通过测试没有问题）\n\n生成对应的代码，在 main 处写下对应的 USART1 和 DMA 的启动函数：\n__HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_IDLE);\nHAL_DMA_Start(huart1,(uint32_t)&amp;USART1-&gt;DR,(uint32_t)DR16Buffer,DR16BufferNumber)；\n\n在中断中加入了对应的 DR16 遥控器的解码解析。\n烧录，启动仿真。\nUSART1 中断正常\nUSART1-&gt;DR 没有接收到数据，异常\nDMA 的 NDTR 位置没有减少，也就是没有发送数据出去，异常\n2.第二次尝试：（失败）由于 USART1 启动中断的时候有概率会因为没有清空或者其他问题导致标志位没有清除，所以在启动 USART1 中断前写入另外一行函数：\n__HAL_UART_CLEAR_IDLEFLAG(&amp;huart1);\n\n同时发现了 HAL 系统默认配置的 IO 口是错误的，需要自己手动选择对应的 IO 口来进行配置，更改回正确的 IO 口。\n清除了在中断中的 DR16 遥控器的解码解析。\n烧录，启动仿真。\nUSART1 中断正常\nUSART1-&gt;DR 接收到了数据，正常\nDMA 的 NDTR 位置没有减少，也就是没有发送数据出去，异常\n2.1.发现问题到这里的时候我已经对 DMA 的内部配置和 USART 内部的配置的不同性产生了怀疑，通过百度之后我发现了惊人的事实！那就是 DMA 的 HAL 结构体和 USART 的 HAL 库结构体有着本质上的不同。结合自己的理解我对下面进行解释。\n为了方便理解，我先对USART的HAL结构体进行了解析：通过打开 stm32f4xx_hal_uart.h，找到对应的 __UART_HandleTypeDef 结构体。\n\n__UART_HandleTypeDef 结构体\ntypedef struct __UART_HandleTypeDef\n&#123;\n  USART_TypeDef                 *Instance;        &#x2F;*!&lt; UART registers base address        *&#x2F;\n\n  UART_InitTypeDef              Init;             &#x2F;*!&lt; UART communication parameters      *&#x2F;\n\n  uint8_t                       *pTxBuffPtr;      &#x2F;*!&lt; Pointer to UART Tx transfer Buffer *&#x2F;\n\n  uint16_t                      TxXferSize;       &#x2F;*!&lt; UART Tx Transfer size              *&#x2F;\n\n  __IO uint16_t                 TxXferCount;      &#x2F;*!&lt; UART Tx Transfer Counter           *&#x2F;\n\n  uint8_t                       *pRxBuffPtr;      &#x2F;*!&lt; Pointer to UART Rx transfer Buffer *&#x2F;\n\n  uint16_t                      RxXferSize;       &#x2F;*!&lt; UART Rx Transfer size              *&#x2F;\n\n  __IO uint16_t                 RxXferCount;      &#x2F;*!&lt; UART Rx Transfer Counter           *&#x2F;\n\n  DMA_HandleTypeDef             *hdmatx;          &#x2F;*!&lt; UART Tx DMA Handle parameters      *&#x2F;\n\n  DMA_HandleTypeDef             *hdmarx;          &#x2F;*!&lt; UART Rx DMA Handle parameters      *&#x2F;\n\n  HAL_LockTypeDef               Lock;             &#x2F;*!&lt; Locking object                     *&#x2F;\n\n  __IO HAL_UART_StateTypeDef    gState;           &#x2F;*!&lt; UART state information related to global Handle management\n                                                       and also related to Tx operations.\n                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef *&#x2F;\n\n  __IO HAL_UART_StateTypeDef    RxState;          &#x2F;*!&lt; UART state information related to Rx operations.\n                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef *&#x2F;\n\n  __IO uint32_t                 ErrorCode;        &#x2F;*!&lt; UART Error code                    *&#x2F;\n\n\n\n很明显可以看出，在 USART 的结构体中，提供了 USART_Tx 发送和 USAT_Rx 接收的 DMA 结构体接口、一些地址和数字的设置的项，以及一些错误返回的选项，通过百度我知道为了使得错误选项不影响结构体在正常运行时候的判断（由于 Error 返回为 1 的时候可能会使得 USART 的整体功能运行受到阻断）。\n\n这个时候我在想，既然 USART 里面提供了对应的 Rx 和 Tx 的地址接口、数据大小和其他各种的状态位置，那么如果我用 DMA 初始化的话，按道理来说这里应该会被填上对应的地址、数据大小和对应的信息，以及对应的 DMA 接口的信息也会被填上去。\n为了验证这个假设，我在 main 函数中使能\nHAL_DMA_Start(huart1,(uint32_t)&amp;USART1-&gt;DR,(uint32_t)DR16Buffer,DR16BufferNumber)；\n\n烧录，仿真，观看对应的 DMA 接口，也就是 *hdmarx 中有没有填上对应的相关信息。\n结果我发现没有！！没有！！！！那个该死的 DMA 接口里面的数据空空如也！！\n再观看对应的 DMA 结构体，DMA 结构体的 Instance 里面虽然有对应的信息，但是无法和 USART 连接起来，因为他是 DMA 专用的对应于 DMA 内部的结构体。\n\n__DMA_HandleTypeDef 结构体\ntypedef struct __DMA_HandleTypeDef\n&#123;\n  DMA_Stream_TypeDef         *Instance;                                                        &#x2F;*!&lt; Register base address                  *&#x2F;\n\n  DMA_InitTypeDef            Init;                                                             &#x2F;*!&lt; DMA communication parameters           *&#x2F; \n\n  HAL_LockTypeDef            Lock;                                                             &#x2F;*!&lt; DMA locking object                     *&#x2F;  \n\n  __IO HAL_DMA_StateTypeDef  State;                                                            &#x2F;*!&lt; DMA transfer state                     *&#x2F;\n\n  void                       *Parent;                                                          &#x2F;*!&lt; Parent object state                    *&#x2F; \n\n  void                       (* XferCpltCallback)( struct __DMA_HandleTypeDef * hdma);         &#x2F;*!&lt; DMA transfer complete callback         *&#x2F;\n\n  void                       (* XferHalfCpltCallback)( struct __DMA_HandleTypeDef * hdma);     &#x2F;*!&lt; DMA Half transfer complete callback    *&#x2F;\n\n  void                       (* XferM1CpltCallback)( struct __DMA_HandleTypeDef * hdma);       &#x2F;*!&lt; DMA transfer complete Memory1 callback *&#x2F;\n  \n  void                       (* XferM1HalfCpltCallback)( struct __DMA_HandleTypeDef * hdma);   &#x2F;*!&lt; DMA transfer Half complete Memory1 callback *&#x2F;\n  \n  void                       (* XferErrorCallback)( struct __DMA_HandleTypeDef * hdma);        &#x2F;*!&lt; DMA transfer error callback            *&#x2F;\n  \n  void                       (* XferAbortCallback)( struct __DMA_HandleTypeDef * hdma);        &#x2F;*!&lt; DMA transfer Abort callback            *&#x2F;  \n\n  __IO uint32_t              ErrorCode;                                                        &#x2F;*!&lt; DMA Error code                          *&#x2F;\n  \n  uint32_t                   StreamBaseAddress;                                                &#x2F;*!&lt; DMA Stream Base Address                *&#x2F;\n\n  uint32_t                   StreamIndex;                                                      &#x2F;*!&lt; DMA Stream Index                       *&#x2F;\n \n&#125;DMA_HandleTypeDef;\n\n\n\n\n再详细阅读官方库给用户的定义的函数\n&#x2F;*UART以DMA方式接收指定长度数据到指定缓冲区*&#x2F;\nHAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\n&#123;\n  uint32_t *tmp;\n \n  &#x2F;* Check that a Rx process is not already ongoing *&#x2F;\n  &#x2F;* 检查huart-&gt;RxState是否处于接收空闲 状态。\n  当这一状态标志非READY时，会跳过DMA接收参数设置，直接返回HAL_BUSY。\n  其它的UART接收函数也会检查这个状态，所以，哪个先调用就执行哪个。*&#x2F;\n  if(huart-&gt;RxState &#x3D;&#x3D; HAL_UART_STATE_READY)  \n  &#123;\n    if((pData &#x3D;&#x3D; NULL) || (Size &#x3D;&#x3D; 0U))\n    &#123;\n      return HAL_ERROR;\n    &#125;\n \n    &#x2F;* Process Locked *&#x2F;\n    __HAL_LOCK(huart);\n \n    huart-&gt;pRxBuffPtr &#x3D; pData;\n    huart-&gt;RxXferSize &#x3D; Size;\n \n    huart-&gt;ErrorCode &#x3D; HAL_UART_ERROR_NONE;\n    huart-&gt;RxState &#x3D; HAL_UART_STATE_BUSY_RX;\n \n    &#x2F;* Set the UART DMA transfer complete callback *&#x2F;\n\t&#x2F;*设置DMA传输完成的回调函数。当DMA以循环方式传输时会调用UART接收完成中断的回调函数；\n\t以Normal方式传输时会关闭UART的DMA通道，并使能UART传输完成中断，触发UART传输完成中断，\n\t设置huart-&gt;RxState为READY，并调用UART接收完成中断的回调函数。\n\t所以，不管DMA按循环或正常模式传输，到最后都会调用UART接收完成中断的回调函数*&#x2F;\n    huart-&gt;hdmarx-&gt;XferCpltCallback &#x3D; UART_DMAReceiveCplt; \n    &#x2F;* Set the UART DMA Half transfer complete callback *&#x2F;\n    huart-&gt;hdmarx-&gt;XferHalfCpltCallback &#x3D; UART_DMARxHalfCplt;\n \n    &#x2F;* Set the DMA error callback *&#x2F;\n    huart-&gt;hdmarx-&gt;XferErrorCallback &#x3D; UART_DMAError;\n \n    &#x2F;* Set the DMA abort callback *&#x2F;\n    huart-&gt;hdmarx-&gt;XferAbortCallback &#x3D; NULL;\n \n    &#x2F;* Enable the DMA channel *&#x2F;\n\t&#x2F;*以中断方式打开DMA传输。所以CubeMx中DMA中断默认是打开的切不可更改*&#x2F;\n    tmp &#x3D; (uint32_t*)&amp;pData;\n    HAL_DMA_Start_IT(huart-&gt;hdmarx, (uint32_t)&amp;huart-&gt;Instance-&gt;DR, *(uint32_t*)tmp, Size);\n    &#x2F;* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer *&#x2F;\n    __HAL_UART_CLEAR_OREFLAG(huart);\n \n    &#x2F;* Process Unlocked *&#x2F;\n    __HAL_UNLOCK(huart);\n \n    &#x2F;* Enable the UART Parity Error Interrupt *&#x2F;\n    SET_BIT(huart-&gt;Instance-&gt;CR1, USART_CR1_PEIE);\n \n    &#x2F;* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) *&#x2F;\n    SET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_EIE);\n \n    &#x2F;* Enable the DMA transfer for the receiver request by setting the DMAR bit\n    in the UART CR3 register *&#x2F;\n    SET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAR);\n \n    return HAL_OK;\n  &#125;\n  else\n  &#123;\n    return HAL_BUSY;\n  &#125;\n&#125;\n\n\n\n可见官方库是一定要你开启 DMA 中断，而且要对 USART1 结构体上面的 Rx 地址和 Rx 数据大小重新定向。\n2.2.推断方法：通过上面的分析，我得出了当下的两个情况：\n\n我开启的 DMA 并不是挂载在 USART1 上面的 DMA ，对应的 DMA 数据也没有挂载到 USART1 上发挥作用\nUSART1 上面不管是挂载着的 DMA 的结构体，还是里面对应的 Rx 地址，Rx 数据大小都没有任何的值\nErrorCode 这个错误返回的标志位最好使能掉比较好，省的阻断我程序的运行流程\n\n那么，首先我要做的事情就是先给 USART1 结构体上面的 Rx 地址和 Rx 数据大小重新定向，同时关闭我的 ErrorCoude 的响应。\n参考 stm32f427xx_hal.h 和 DevelopmentBoard_Example 中通过 CR3 位置直接打开对应挂载 DMA 传输的方法。\n&#x2F;*检测当前huart状态*&#x2F;\n\t\tif(huart-&gt;RxState &#x3D;&#x3D; HAL_UART_STATE_READY)\n\t\t&#123;\n\t\t\t&#x2F;*输入的地址或者数据有问题的话*&#x2F;\n\t\t\tif((pData &#x3D;&#x3D; NULL) || (Size &#x3D;&#x3D; 0))\n\t\t\t&#123;\n\t\t\t\t\treturn HAL_ERROR;\n\t\t\t&#125;\n\t\t\t\n\t\t\t&#x2F;*huart里面对应的Rx变量重定向*&#x2F;\n\t\t\thuart-&gt;pRxBuffPtr &#x3D; pData;\n\t\t\thuart-&gt;RxXferSize &#x3D; Size;\n\t\t\thuart-&gt;ErrorCode &#x3D; HAL_UART_ERROR_NONE;\n\t\t\t\n\t\t\t&#x2F;*开启huart1上的RX_DMA*&#x2F;\n\t\t\tHAL_DMA_Start(huart-&gt;hdmarx,(uint32_t)&amp;huart-&gt;Instance-&gt;DR,(uint32_t)pData,Size);\n\t\t\t\n\t\t\t&#x2F;*只开启对应DMA上面的Rx功能（如果是开启Tx的话就是USART_CR3_DMAT）*&#x2F;\n\t\t\tSET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAR);\n\t\t\t\n\t\t\t\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn HAL_BUSY;\n\t\t&#125;\n\n3.第三次尝试：（成功）上述的方法，生成代码，编译烧录\nUSART1 中断正常\nUSART1-&gt;DR 接收到了数据，正常\nDMA 的 NDTR 位置成功减少，正常\nDR16Buffer 位置成功减少，正常\n解码，正常\n回看到中断里面的回调函数：\nvoid DR16_Handler(UART_HandleTypeDef *huart)\n&#123;\n\n\tif (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) &amp;&amp;\n\t\t__HAL_UART_GET_IT_SOURCE(huart, UART_IT_IDLE))\n\t&#123;\n\t\t__HAL_UART_CLEAR_IDLEFLAG(huart);\n\t\t__HAL_DMA_DISABLE(huart-&gt;hdmarx);\n\n\t\t&#x2F;&#x2F;if(DR16BufferNumber - DMA_GET_COUNTER(huart-&gt;hdmarx-&gt;Instance) &#x3D;&#x3D; DR16BufferTruthNumber)\n\t\tif (__HAL_DMA_GET_COUNTER(huart-&gt;hdmarx) &#x3D;&#x3D; DR16BufferLastNumber)\n\t\t&#123;\n\t\t\tDR16.DR16_Process(DR16Buffer);\n\t\t&#125;\n\n\t\t__HAL_DMA_SET_COUNTER(huart-&gt;hdmarx, DR16BufferNumber);\n\t\t__HAL_DMA_ENABLE(huart-&gt;hdmarx);\n\t&#125;\n&#125;\n\n对于上述对应空闲标志位的判断，我们下一个笔记再解释。\n","slug":"cubeMX/cubeMX-AllUD/USART_DMA","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"dea130efefdf0c7df84d0658a83a4131","title":"CM中USART的配置，以及启动方法","content":"1.USART 配置USART 的配置部分比较的难搞，但是其实大部分如果注意一下的话，问题其实并不太大。\n以下是 USART 中一些比较常用的通讯方式（其实实际上用的多的也就异步）\n\n以及下面还有 RS232 的通信模式\n\n这里涵盖了大部分的串口的通信模式，同时也可以说是涵盖了大部分的串口的功能，下面还没有解释的情况可以具体理解。\n以下是对应的 USART 中的一些参数的配置：\n\nUSART 的配置相对来说是介于 GPIO 配置中比较简单的一个部分，在配置好参数之后我们就可以创建代码进行调试了。\n2.USART 常用函数2.1.USART 启动函数通常用于启动 USART 的传输和 USART 的附带中断的传输模式：\n__HAL_UART_ENABLE(__HANDLE__) \n__HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__)\n\n其实和上面的一章的原理是一样的，是单纯的启动还是带中断的启动，而启动的效果也是不一样的，具体可以参考 TIM 那章中的启动函数的不同。\n__HAL_UART_DISABLE(__HANDLE__) \n__HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__)\n\n同理，失能或者失能中断效果的串口传输。\n2.2.USART 标志位函数获取 USART 中断的时候的中断标志是什么。\n__HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__)\n\n清除中断标志位，但是这个的清除是有点问题的，后面会说如何清除会比较的好。\n__HAL_UART_CLEAR_FLAG(__HANDLE__, __FLAG__)\n\n\n\n\n\n\n\n\n\n\n当然，USART 是可以添加 DMA 的，我会放到后面再写，以及中断我也会放到后面写，这里主要是希望大家可以理解对应的配置关系就可以了。\n","slug":"cubeMX/cubeMX-AllUSART/USART","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"953874cd19baad4a77313739111b0aad","title":"移植官方DSP库","content":"1.这里一定要勾选所有库\n2.debug里引入该路径\n3.然后在工程里引入这四个库\n4.HAL库在生成的时候已经赋值过来了，在自己工程的这个位置\n5.然后在魔术棒里添加下面的宏定义\n宏定义如下\n__TARGET_FPU_VFP=1,ARM_MATH_CM4,__CC_ARM\n\n5.1.使能FPU似乎新版的CMSIS库中需要使用__TARGET_FPU_VFP=1宏来使能FPU\n\n实际上是启用__FPU_USED宏，同时不需要手动定义__FPU_PRESENT，同时需要添加ARM_MATH_CM4等Cortex系列定义。\n\n\n定义后再编译，可以在system_stm32f4xx.c中的SystemInit()函数中看到FPU使能命令：\n  \n\n\n完成后即可正常编译\n6.使用时注意事项6.1.直接调用 “arm_math.h” 会报错\n解决方法：\n\n","slug":"cubeMX/cubeMX-DSP/DSP","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"cubeMX,DSP","author_index":"Miraggio"},{"id":"183e6b77bf2e73e194c62a98ae96b0fa","title":"Flash使用","content":"1.Flash 的上锁解锁&#x2F;**\n * @brief Flash解锁 \n * \n *&#x2F;\nvoid MEM_If_Init_FS(void)\n&#123;\n    HAL_FLASH_Unlock();\n    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\n                           FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\n&#125;\n\n&#x2F;**\n * @brief Flash上锁\n * \n *&#x2F;\nvoid MEM_If_DeInit_FS(void)\n&#123;\n    HAL_FLASH_Lock();\n&#125;\n\n2.Flash 的读取2.1.Flash 读取配置从需要读取的地址开始，一直到结束的地方为止。读取的流程大致如下：\n\n对扇区解锁\n读取\n对扇区上锁\n\n&#x2F;**\n * @brief 读取一个4字节的数据\n * \n * @param faddr \n * @return  \n *&#x2F;\nuint32_t STMFLASH_ReadWord(uint32_t faddr)\n&#123;\n    return *(__IO uint32_t *)faddr;\n&#125;\n\n&#x2F;**\n * @brief Flash的读取\n * \n * @param ReadAddr 开头地址\n * @param pBuffer 需要读取的数据\n * @param size 需要读取数据的大小\n * @return  \n *&#x2F;\nvoid MEM_If_Read_FS(uint32_t ReadAddr, uint32_t *pBuffer, uint32_t size)\n&#123;\n    MEM_If_Init_FS();\n    for (uint32_t i &#x3D; 0; i &lt; size; i++)\n    &#123;\n        pBuffer[i] &#x3D; STMFLASH_ReadWord(ReadAddr); &#x2F;&#x2F;读取4个字节.\n        ReadAddr +&#x3D; 4;                            &#x2F;&#x2F;偏移4个字节.\n    &#125;\n    MEM_If_DeInit_FS(); &#x2F;&#x2F;上锁\n&#125;\n\n2.2.Flash 读取调用我目前需要写入陀螺仪校准后的零漂数据，于是可以这样调用：\nvoid DJI_IMUReadOffset(uint32_t *pBuffer, uint32_t num)\n&#123;\n    MEM_If_Read_FS(STM32_FLASH_BASE, pBuffer, sizeof(uint32_t[num]));\n&#125;\n\n3.Flash 的写入3.1.Flash 写入配置生成 bin 文件之后，可以看见自己代码大小，根据 F4 的扇区，可以选择一块不影响正常代码运行的扇区进行写入。写入流程大致如下：\n\n判断需要写入扇区地址是否正确\n对扇区解锁\n获取扇区地址数据，若不是 0XFFFFFFFF 就进行扇区擦除\n重新写入数据\n对扇区上锁\n\n&#x2F;**\n  * @brief  Gets the sector of a given address\n  * @param  Address: Flash address\n  * @retval The sector of a given address\n  *&#x2F;\nstatic uint32_t GetSector(uint32_t Address)\n&#123;\n    uint32_t sector &#x3D; 0;\n\n    if ((Address &lt; ADDR_FLASH_SECTOR_1) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_0))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_0;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_2) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_1))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_1;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_3) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_2))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_2;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_4) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_3))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_3;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_5) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_4))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_4;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_6) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_5))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_5;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_7) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_6))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_6;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_8) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_7))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_7;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_9) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_8))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_8;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_10) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_9))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_9;\n    &#125;\n    else if ((Address &lt; ADDR_FLASH_SECTOR_11) &amp;&amp; (Address &gt;&#x3D; ADDR_FLASH_SECTOR_10))\n    &#123;\n        sector &#x3D; FLASH_SECTOR_10;\n    &#125;\n    else\n    &#123;\n        sector &#x3D; FLASH_SECTOR_11;\n    &#125;\n\n    return sector;\n&#125;\n\n&#x2F;**\n * @brief Flash的写入\n * \n * @param WriteAddr 开头地址\n * @param pBuffer 需要写入的数组\n * @param Num 需要写入数组元素数量\n * @return  \n *&#x2F;\nvoid MEM_If_Write_FS(uint32_t WriteAddr, uint32_t *pBuffer, uint32_t Num)\n&#123;\n    FLASH_EraseInitTypeDef FlashEraseInit;\n    HAL_StatusTypeDef FlashStatus &#x3D; HAL_OK;\n    uint32_t SectorError &#x3D; 0;\n    uint32_t addrx &#x3D; 0;\n    uint32_t endaddr &#x3D; 0;\n    if (WriteAddr &lt; STM32_FLASH_BASE || WriteAddr % 4)\n        return; &#x2F;&#x2F;非法地址\n\n    MEM_If_Init_FS();\n    addrx &#x3D; WriteAddr;             &#x2F;&#x2F;写入的起始地址\n    endaddr &#x3D; WriteAddr + Num * 4; &#x2F;&#x2F;写入的结束地址\n\n    if (addrx &lt; 0x080E1000)\n    &#123;\n        while (addrx &lt; endaddr)\n        &#123;\n            if (STMFLASH_ReadWord(addrx) !&#x3D; 0XFFFFFFFF)\n            &#123;\n                FlashEraseInit.TypeErase &#x3D; FLASH_TYPEERASE_SECTORS;  &#x2F;&#x2F;擦除类型，扇区擦除\n                FlashEraseInit.Sector &#x3D; GetSector(addrx);            &#x2F;&#x2F;要擦除的扇区\n                FlashEraseInit.NbSectors &#x3D; 1;                        &#x2F;&#x2F;一次只擦除一个扇区\n                FlashEraseInit.VoltageRange &#x3D; FLASH_VOLTAGE_RANGE_3; &#x2F;&#x2F;电压范围，VCC&#x3D;2.7~3.6V之间!!\n                if (HAL_FLASHEx_Erase(&amp;FlashEraseInit, &amp;SectorError) !&#x3D; HAL_OK)\n                &#123;\n                    break; &#x2F;&#x2F;发生错误了\n                &#125;\n            &#125;\n            else\n                addrx +&#x3D; 4;\n            FLASH_WaitForLastOperation(FLASH_WAITETIME); &#x2F;&#x2F;等待上次操作完成\n        &#125;\n    &#125;\n    FlashStatus &#x3D; FLASH_WaitForLastOperation(FLASH_WAITETIME); &#x2F;&#x2F;等待上次操作完成\n    if (FlashStatus &#x3D;&#x3D; HAL_OK)\n    &#123;\n        while (WriteAddr &lt; endaddr) &#x2F;&#x2F;写数据\n        &#123;\n            if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, WriteAddr, *pBuffer) !&#x3D; HAL_OK) &#x2F;&#x2F;写入数据\n            &#123;\n                break; &#x2F;&#x2F;写入异常\n            &#125;\n            WriteAddr +&#x3D; 4;\n            pBuffer++;\n        &#125;\n    &#125;\n    MEM_If_DeInit_FS(); &#x2F;&#x2F;上锁\n&#125;\n\n3.2.Flash 的写入调用我目前需要写入陀螺仪校准后的零漂数据，于是可以这样调用：\nvoid DJI_IMUWriteOffset(uint32_t *pBuffer, uint32_t num)\n&#123;\n    MEM_If_Write_FS(STM32_FLASH_BASE, pBuffer, num);\n&#125;\n\n4.Flash 配置头文件#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n#include &quot;main.h&quot;\n\n#define STM32_FLASH_BASE 0x080D0000 &#x2F;&#x2F;STM32 FLASH的起始地址\n#define FLASH_WAITETIME 50000       &#x2F;&#x2F;FLASH等待超时时间\n\n#define ADDR_FLASH_SECTOR_0 ((uint32_t)0x08000000)  &#x2F;* Base @ of Sector 0, 16 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_1 ((uint32_t)0x08004000)  &#x2F;* Base @ of Sector 1, 16 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_2 ((uint32_t)0x08008000)  &#x2F;* Base @ of Sector 2, 16 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_3 ((uint32_t)0x0800C000)  &#x2F;* Base @ of Sector 3, 16 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_4 ((uint32_t)0x08010000)  &#x2F;* Base @ of Sector 4, 64 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_5 ((uint32_t)0x08020000)  &#x2F;* Base @ of Sector 5, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_6 ((uint32_t)0x08040000)  &#x2F;* Base @ of Sector 6, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_7 ((uint32_t)0x08060000)  &#x2F;* Base @ of Sector 7, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_8 ((uint32_t)0x08080000)  &#x2F;* Base @ of Sector 8, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_9 ((uint32_t)0x080A0000)  &#x2F;* Base @ of Sector 9, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_10 ((uint32_t)0x080C0000) &#x2F;* Base @ of Sector 10, 128 Kbyte *&#x2F;\n#define ADDR_FLASH_SECTOR_11 ((uint32_t)0x080E0000) &#x2F;* Base @ of Sector 11, 128 Kbyte *&#x2F;\n\n参考与致谢\n生成bin文件（查看代码大小）\n\n\nSTM32内部Flash读写问题\n\n\nstm32f4flash\n\n\nSTM32片上Flash读写的一些重要知识\n\n\nhal库-芯片内部flash读写\n\n","slug":"cubeMX/cubeMX-Flash/Flash","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"cubeMX,Flash","author_index":"Miraggio"},{"id":"e72a37ec3a778e7788cfedf767ec8c28","title":"看门狗","content":"1.CubeMX配置这次用的是独立看门狗，在 CubeMX 里可以这样配置：\n\n这里按照公式配置需要的时间。\n2.程序喂狗经过上面配置后，开机后自动会运行看门狗，要是不进行代码上喂狗的话，是会不断重启的，喂狗如下：\nHAL_IWDG_Refresh(&amp;hiwdg); &#x2F;&#x2F;喂狗\n\n只需要调用这段话就可以喂狗，可以加入你需要的条件判断，比如数据是否准确，帧率是否正常等。\n参考与致谢\n基于STM32、FreeRTOS实现硬件看门狗+软件看门狗监测多任务的思路\n\n\nSTM32 看门狗详解\n\n\nSTM32的IWDG（独立看门狗）详细用法\n\n\nSTM32单片机：独立看门狗、窗口看门狗的配置\n\n\nHAL库开发教程(八)—看门狗使用\n\n","slug":"cubeMX/cubeMX-IWDG/看门狗","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"cubeMX,IWDG","author_index":"Miraggio"},{"id":"b99053034a0f282087f2cf75e7079caa","title":"RNG","content":"1.CubeMX的配置\n找到 RNG 使能  \n点开时钟配置，会提醒你配置，就按默认生成的时钟就可以了  \n\n2.RNG 使用&#x2F;&#x2F;RNG ：硬件随机数发生器 ：提供个32位的随机数\n&#x2F;&#x2F;两个连续随机数之间的间隔是40个PLL48CLK时钟信号周期\n&#x2F;&#x2F;若随机数发生器发生错误，则可以在SR寄存器中去读到它的状态\n&#x2F;&#x2F;若其发生错误，还可以产生中断\n&#x2F;&#x2F;数据需要就绪才可以去读取随机数，需要大量的种子产生\n&#x2F;&#x2F;取一定范围内的随机数，是通过除以range取余法\n&#x2F;&#x2F;range(min,max) X % (max-min+1)+min 即是range(min,max)内的随机数\n&#x2F;&#x2F;获取一定范围内的随机数\nuint16_t Get_RandomNumbers_Range(int16_t min,int16_t max)\n&#123;\n uint32_t rng_number;\n &#x2F;&#x2F;无需对其状态位进行判断，因为在获取随机数的函数中，本身就带有检测\n &#x2F;&#x2F; if(__HAL_RNG_GET_FLAG(&amp;hrng,RNG_FLAG_DRDY) &#x3D;&#x3D; SET)\n &#x2F;&#x2F; &#123;&#125;\n rng_number &#x3D; HAL_RNG_GetRandomNumber(&amp;hrng);\n \n return rng_number % (max - min + 1) + min;\n    &#125;","slug":"cubeMX/cubeMX-RNG/RNG","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"cubeMX,RNG","author_index":"Miraggio"},{"id":"d4fbf5902e3d36a3dfddb88b82a353a3","title":"CM中GPIO的配置，使用，以及启动方法","content":"1.配置 GPIO配置 GPI O大概是 CubeMX 中最最简单的一个模块的配置的，大概没有比这个更加简单的模块了，如果有那就是基本库。\n但是，简单归简单，坑依旧是不见少到哪里去，配置之后找问题还是一样的自闭。\n比方说你要定义一个 GPIO 的 LED 灯，以 STM32F427VIT6 为例，例如说 PE9 为对应我们所需要使用的 LED 灯。\n\n选中 PE9 引口之后单击会出现一个对应的窗口，里面可以配置对应的 GPIO 的各种各样的属性和性能，这些性能你在别的配置中也可能会用到，不过不是说你要每一个引口都记下（那是不可能的），你需要的只是知道你要配置的时候需要什么步骤即可。\n选择 GPIO_Output 模式，众所周知 LED 都是高低电平的输出决定它的灭亮，所以必然是输出模式。\n选择时候引口的名字会变成这个样子：\n\n这个时候我们还可以对他进行命名，这个命名就像宏定义一样，你在这个位置进行命名之后，在代码里面的宏定义命名就是变成你在这个界面的命名。\n如何对引脚进行命名呢？右键对应的引脚，选择 Enter User Label\n\n这个时候会出现一个框框供你填入你想要填入的名字，比如我想给这个 LED 的宏定义定位 LED_1 \n那么我就可以在框框中写入 LED_1，点击回车之后，名字就变成 LED_1 了。\n通常情况下我们并不可能只是定义一个 LED 灯，同一块板子上至少有差不多 2 到 3 个 LED 灯，或者更多。\n当我们配置了很多的 LED 或者输出的 IO 口时，我们如何查看我们定义多少个 IO 口呢？\n其实是有方法的，在版面选择 System View 变成系统的查看版面\n\n点开之后你会发现我们可以看到各式各样的模块的记录，包括你定义了什么模块，以及什么模块中可能会发生故障等等。\n我们点开 GPIO\n\n\n这个时候我们就可以看到我们目前定义的所有的 LED 的状况啦，当然你也可以在这个版面修改你默认的电平，默认模式，默认输出速度，宏定义等等。\n\n一切准备就绪，直接点击生成代码就可以了。\n2.常见 GPIO 函数使用方面，这里会写出几个比较常用的函数，个人感觉用的次数是比较多的供参考，不过实际上到真正要多次使用的时候，建议还是自己看代码里面的宏定义来进行使用。\n1、GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);\n\n读取当前的 PXn 口的对应状态，返回的状态一般为高低电平。\n2、void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);\n\n更改当前对应 PXn 口的电平，更改为高电平和低电平\n3、void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);\n\n置反当前端口的电平，高电平变成低电平，低电平变成高电平。\n","slug":"cubeMX/cubeMx-AllGPIO/GPIO","date":"2022-01-27T10:49:36.000Z","categories_index":"Embedded","tags_index":"HAL,cubeMX","author_index":"Miraggio"},{"id":"c7ad3fc5539e6e09e5d04802e792c17b","title":"C/C++ 基础编程","content":"1.C++入门1.1.Hello world#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;\n\n    system(&quot;pause&quot;);\n    return 0;\n&#125;\n\n1.2.数据输入语法：cin &gt;&gt; 变量\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()&#123;\n\n\t&#x2F;&#x2F;整型输入\n\tint a &#x3D; 0;\n\tcout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl;\n\tcin &gt;&gt; a;\n\tcout &lt;&lt; a &lt;&lt; endl;\n\n\t&#x2F;&#x2F;浮点型输入\n\tdouble d &#x3D; 0;\n\tcout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl;\n\tcin &gt;&gt; d;\n\tcout &lt;&lt; d &lt;&lt; endl;\n\n\t&#x2F;&#x2F;字符型输入\n\tchar ch &#x3D; 0;\n\tcout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl;\n\tcin &gt;&gt; ch;\n\tcout &lt;&lt; ch &lt;&lt; endl;\n\n\t&#x2F;&#x2F;字符串型输入\n\tstring str;\n\tcout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl;\n\tcin &gt;&gt; str;\n\tcout &lt;&lt; str &lt;&lt; endl;\n\n\t&#x2F;&#x2F;布尔类型输入\n\tbool flag &#x3D; true;\n\tcout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl;\n\tcin &gt;&gt; flag;\n\tcout &lt;&lt; flag &lt;&lt; endl;\n\tsystem(&quot;pause&quot;);\n\treturn EXIT_SUCCESS;\n&#125;\n\n2.程序流程结构2.1.三目运算符语法：表达式1？表达式2：表达式3\n解释：\n如果表达式1的值为真，执行表达式2，并返回表达式2的结果；\n如果表达式1的值为假，执行表达式3，并返回表达式3的结果。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main()\n&#123;\n    int a &#x3D; 10;\n    int b &#x3D; 20;\n    int c &#x3D; 0;\n\n    c &#x3D; a &gt; b ? a : b;\n    cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\n    &#x2F;&#x2F;C++中三目运算符返回的是变量,可以继续赋值\n    (a &gt; b ? a : b) &#x3D; 100;\n    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n    cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\n    system(&quot;pause&quot;);\n    return 0;\n&#125;\n\n运行结果：\n\n2.2.do……while 语句语法：do{ 循环语句 } while( 循环条件 )\n\n注意：与 while 的区别在于 do……while 会先执行一次循环语句，再判断循环条件\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main()\n&#123;\n    int num &#x3D; 10;\n\n    do\n    &#123;\n        cout &lt;&lt; num &lt;&lt; endl;\n        num++;\n    &#125; while (num &lt; 10);\n\n    system(&quot;pause&quot;);\n    return 0;\n&#125;\n\n运行结果：\n\n2.3.continue语句语法：continue；\n作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环\n\n注意：continue 并没有使整个循环终止，而 break 会跳出循环\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main()\n&#123;\n    for (int i &#x3D; 0; i &lt; 10; i++)\n    &#123;\n        if (i % 2 &#x3D;&#x3D; 0)\n        &#123;\n            continue;\n        &#125;\n        cout &lt;&lt; &quot;i &#x3D; &quot; &lt;&lt; i &lt;&lt; &quot;\\n&quot;\n             &lt;&lt; endl;\n    &#125;\n\n    system(&quot;pause&quot;);\n    return 0;\n&#125;\n\n运行结果：\n\n2.4.goto语句语法：goto 标记；\n作用：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;\n\n    goto FLAG;\n\n    cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;3&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;4&quot; &lt;&lt; endl;\n\nFLAG:\n\n    cout &lt;&lt; &quot;5&quot; &lt;&lt; endl;\n\n    system(&quot;pause&quot;);\n    return 0;\n&#125;\n\n运行结果：\n\n3.数组3.1.二维数组数组名\n查看二维数组所占内存空间\n获取二维数组首地址\n\nint main() &#123;\n\n\t&#x2F;&#x2F;二维数组数组名\n\tint arr[2][3] &#x3D;\n\t&#123;\n\t\t&#123;1,2,3&#125;,\n\t\t&#123;4,5,6&#125;\n\t&#125;;\n\n\tcout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) &#x2F; sizeof(arr[0]) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) &#x2F; sizeof(arr[0][0]) &lt;&lt; endl;\n\n\t&#x2F;&#x2F;地址\n\tcout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;\n\tcout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n总结1：二维数组名就是这个数组的首地址\n总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小\n4.函数4.1.函数的声明作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\n\n函数的声明可以多次，但是函数的定义只能有一次\n\n&#x2F;&#x2F;声明可以多次，定义只能一次\n&#x2F;&#x2F;声明\nint max(int a, int b);\nint max(int a, int b);\n&#x2F;&#x2F;定义\nint max(int a, int b)\n&#123;\n\treturn a &gt; b ? a : b;\n&#125;\n\nint main() &#123;\n\n\tint a &#x3D; 100;\n\tint b &#x3D; 200;\n\n\tcout &lt;&lt; max(a, b) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n5.指针5.1.指针所占内存空间所有指针类型在32位操作系统下是4个字节\nint main() &#123;\n\n\tint a &#x3D; 10;\n\n\tint * p;\n\tp &#x3D; &amp;a; &#x2F;&#x2F;指针指向数据a的地址\n\n\tcout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;* 解引用\n\tcout &lt;&lt; sizeof(p) &lt;&lt; endl;\n\tcout &lt;&lt; sizeof(char *) &lt;&lt; endl;\n\tcout &lt;&lt; sizeof(float *) &lt;&lt; endl;\n\tcout &lt;&lt; sizeof(double *) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n5.2.空指针和野指针空指针：指针变量指向内存中编号为0的空间\n\n用途：初始化指针变量\n注意：空指针指向的内存是不可以访问的\n\nint main() &#123;\n\n\t&#x2F;&#x2F;指针变量p指向内存地址编号为0的空间\n\tint * p &#x3D; NULL;\n\n\t&#x2F;&#x2F;访问空指针报错 \n\t&#x2F;&#x2F;内存编号0 ~255为系统占用内存，不允许用户访问\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n野指针：指针变量指向非法的内存空间\nint main() &#123;\n\n\t&#x2F;&#x2F;指针变量p指向内存地址编号为0x1100的空间\n\tint * p &#x3D; (int *)0x1100;\n\n\t&#x2F;&#x2F;访问野指针报错 \n\tcout &lt;&lt; *p &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：空指针和野指针都不是我们申请的空间，因此不要访问。\n6.结构体6.1.结构体中 const使用场景作用：用const来防止误操作\n&#x2F;&#x2F;学生结构体定义\nstruct student\n&#123;\n\t&#x2F;&#x2F;成员列表\n\tstring name;  &#x2F;&#x2F;姓名\n\tint age;      &#x2F;&#x2F;年龄\n\tint score;    &#x2F;&#x2F;分数\n&#125;;\n\n&#x2F;&#x2F;const使用场景\nvoid printStudent(const student *stu) &#x2F;&#x2F;加const防止函数体中的误操作\n&#123;\n\t&#x2F;&#x2F;stu-&gt;age &#x3D; 100; &#x2F;&#x2F;操作失败，因为加了const修饰\n\tcout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;\n\n&#125;\n\nint main() &#123;\n\n\tstudent stu &#x3D; &#123; &quot;张三&quot;,18,100 &#125;;\n\n\tprintStudent(&amp;stu);\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n6.2.结构体中的字节对齐\n第一个例子结构体\nstruct STUDENT\n&#123;\n    char a;\n    int b;\n&#125;data;\n\n\n\n是占 6 字节吗？不是，其实占了 8 字节，这个就叫字节对齐。\n结构体变量 data 的成员中占内存最多的数据类型是 int 型，其占 4 字节的内存空间，那么所有成员在分配内存时都要与 4 字节的长度对齐。也就是说，虽然 char 只占 1 字节，但是为了与 4 字节的长度对齐，它后面的 3 字节都会空着，即：\n\n所谓空着其实也不是里面真的什么都没有，它就同定义了一个变量但没有初始化一样，里面是一个很小的、负的填充字。为了便于表达，我们就暂且称之为空好了。\n\n第二个例子结构体  如果结构体成员为：\nstruct STUDENT\n&#123;\n    char a;\n    char b;\n    int c;\n&#125;data;\n\n答案：  \n\n\n第三个例子结构体  struct STUDENT\n&#123;\n    char a;\n    char b;\n    char c;\n    char d;\n    char e;\n    int f;\n&#125;data;\n\n答案  \n\n\n第四个例子结构体  struct STUDENT\n&#123;\n    char a;\n    int b;\n    char c;\n&#125;data;\n\n答案：  \n\n\n第五个例子结构体  struct STUDENT\n&#123;\n    char name[10];\n    int age;\n    char sex;\n    float score;\n&#125;data;\n\n答案：  \n\n\n\n参考与致谢\nC/C++ 中的static关键字\n\n结构体字节对齐，C语言结构体字节对齐详解\n\n\n","slug":"C-C++/C-C++_AllBasis/C-C++_basis","date":"2022-01-24T10:49:36.000Z","categories_index":"Language","tags_index":"C/C++","author_index":"Miraggio"},{"id":"c4064ddb260b54731c75e982795ee11a","title":"C++ 进阶知识","content":"1.内存分区模型C++程序在执行时，将内存大方向划分为4个区域\n\n代码区：存放函数体的二进制代码，由操作系统进行管理的\n全局区：存放全局变量和静态变量以及常量\n栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等\n堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收\n\n其中代码区和全局区是在程序编译之前，栈区和堆区是在程序编译之后。\n1.1.程序运行前在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域\n1.1.1.代码区：\n存放 CPU 执行的机器指令\n代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令\n\n1.1.2.全局区：\n全局变量和静态变量存放在此\n全局区还包含了常量区, 字符串常量和其他常量也存放在此\n该区域的数据在程序结束后由操作系统释放\n\n\n示例：\n一.字符串常量\n\n直接打印 &quot;hello world&quot; 就是一个字符串常量，存储在全局区中。\n\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;\n\n二.静态变量\n\n一般来说，只要是局部变量（在函数里创建的变量）就不是放在全局区内，但是静态变量除外，它既可以在函数外，也可以在函数内创建，而且都属于全局区。\n\n\n\n总结：\n\nC++中在程序运行前分为全局区和代码区\n代码区特点是共享和只读\n全局区中存放全局变量、静态变量、常量\n常量区中存放 const修饰的全局常量 和 字符串常量\n\n1.2.程序运行后1.2.1.栈区： 由编译器自动分配释放, 存放函数的参数值,局部变量等\n 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n示例：\nint * func()\n&#123;\n\tint a &#x3D; 10; \n\treturn &amp;a;  &#x2F;&#x2F;返回了局部变量的地址，此操作是属于违法操作\n&#125;\n\nint main() &#123;\n\n\tint *p &#x3D; func();\n  &#x2F;&#x2F;函数结束后系统会自动释放局部变量，这是 *p 已经不是我们要的了\n\n\tcout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;第一次是正常的，是因为编译器自动保存了一次值\n\tcout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;第二次就出现乱码了\n  &#x2F;&#x2F;总体来说，就不要返回局部变量的地址\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n1.2.2.堆区由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\n 在C++中主要利用new在堆区开辟内存\n\n示例：\nint* func()\n&#123;\n\tint* a &#x3D; new int(10);  &#x2F;&#x2F;C++ 内通过 new 创建堆区的内存（C 一般用 malloc）\n\treturn a;              &#x2F;&#x2F;返回的其实是创建堆区的地址，而不是上诉栈区的地址\n&#125;\n\nint main() &#123;\n\n\tint *p &#x3D; func();\n\n\tcout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;第一次正常\n\tcout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;第二次也是正常\n    \n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n总结：\n堆区数据由程序员管理开辟和释放\n堆区数据利用new关键字进行开辟内存\n1.3.new 操作符\nnew 会向堆区申请内存\nint *func(void)\n&#123;\n\tint *a &#x3D; new int(-1000);  &#x2F;&#x2F;创建一个值为 -1000 的 int 类型变量的内存\n\treturn a;\n&#125;\n\nint *func1(void)\n&#123;\n\tint *arr &#x3D; new int[10];   &#x2F;&#x2F;创建一个元素为 10 的 int 类型数组的内存\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tarr[i] &#x3D; 100 + i;       &#x2F;&#x2F;给每一个元素赋值\n\t&#125;\n\treturn arr;\n&#125;\n\nint main()\n&#123;\n\n\tint *p &#x3D; func();\n\tint *arr1 &#x3D; func1();\n\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tcout &lt;&lt; arr1[i] &lt;&lt; endl;\n\t&#125;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n2.引用2.1.引用的基本使用作用： 给变量起别名\n语法： 数据类型 &amp;别名 = 原名\n\n\n示例：\nint main() &#123;\n\n\tint a &#x3D; 10;\n\tint &amp;b &#x3D; a;\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\n\tb &#x3D; 100;\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n运行结果：  \n\n2.2.引用注意事项\n引用必须初始化\n引用在初始化后，不可以改变\n\n\n\n示例：\n\tint main() &#123;\n\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\t&#x2F;&#x2F;int &amp;c; &#x2F;&#x2F;错误，引用必须初始化\n\tint &amp;c &#x3D; a; &#x2F;&#x2F;一旦初始化后，就不可以更改\n\tc &#x3D; b; &#x2F;&#x2F;这是赋值操作，不是更改引用\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\tcout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;结果都是20\n\n\n\n2.3.引用做函数参数\n作用：  函数传参时，可以利用引用的技术让形参修饰实参\n优点：  可以简化指针修改实参\n\n\n引用做函数参数的话更改是会直接改变输入变量，与传地址产生的效果是一样的。\nvoid mySwap03(int&amp; a, int&amp; b) &#123;\n\tint temp &#x3D; a;\n\ta &#x3D; b;\n\tb &#x3D; temp;\n&#125;\n\nint main() &#123;\n\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\n\tmySwap03(a, b);\n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n2.4.引用做函数返回值作用：引用是可以作为函数的返回值存在的\n注意：不要返回局部变量引用\n\n用法：函数调用作为左值\n&#x2F;&#x2F;返回局部变量引用\nint&amp; test01() &#123;\n\tint a &#x3D; 10; &#x2F;&#x2F;局部变量\n\treturn a;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;不能返回局部变量的引用\n\tint&amp; ref &#x3D; test01();\n\tcout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;同上诉原理是一样的，返回局部变量的引用操作是属于非法操作的\n\n&#x2F;&#x2F;返回静态变量引用\nint&amp; test02() &#123;\n\tstatic int a &#x3D; 20;  &#x2F;&#x2F;属于全局区的内存\n\treturn a;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;如果函数做左值，那么必须返回引用\n\tint&amp; ref2 &#x3D; test02();\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\n\ttest02() &#x3D; 1000;  &#x2F;&#x2F;相当于 a &#x3D; 1000\n\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n运行结果：    可以看出确实是成功改变了变量值。\n\n2.5.引用的本质\n本质：引用的本质在 C++ 内部实现是一个指针常量.\n&#x2F;&#x2F;发现是引用，转换为 int* const ref &#x3D; &amp;a;\nvoid func(int&amp; ref)&#123;\n\tref &#x3D; 100; &#x2F;&#x2F; ref是引用，转换为*ref &#x3D; 100\n&#125;\nint main()&#123;\n\tint a &#x3D; 10;\n    \n    &#x2F;&#x2F;自动转换为 int* const ref &#x3D; &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n\tint&amp; ref &#x3D; a; \n\tref &#x3D; 20; &#x2F;&#x2F;内部发现ref是引用，自动帮我们转换为: *ref &#x3D; 20;\n    \n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\n    \n\tfunc(a);\n\treturn 0;\n&#125;\n\n\n\n结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n2.6.常量引用作用：常量引用主要用来修饰形参，防止误操作\n\n在函数形参列表中，可以加const修饰形参，防止形参改变实参\n&#x2F;&#x2F;引用使用的场景，通常用来修饰形参\nvoid showValue(const int&amp; v)     &#x2F;&#x2F;加了 const 之后，该函数不能再对传进去的变量进行赋值，否则就会出现误操作\n&#123;\n\t&#x2F;&#x2F;v +&#x3D; 10;\n\tcout &lt;&lt; v &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;int&amp; ref &#x3D; 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t&#x2F;&#x2F;加入const就可以了，编译器优化代码，int temp &#x3D; 10; const int&amp; ref &#x3D; temp;\n\tconst int&amp; ref &#x3D; 10;\n\n\t&#x2F;&#x2F;ref &#x3D; 100;  &#x2F;&#x2F;加入const后不可以修改变量\n\tcout &lt;&lt; ref &lt;&lt; endl;\n\n\t&#x2F;&#x2F;函数中利用常量引用防止误操作修改实参\n\tint a &#x3D; 10;\n\tshowValue(a);\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n3.函数提高3.1.函数默认参数在C++中，函数的形参列表中的形参是可以有默认值的。\n\n语法：返回值类型 函数名 （参数= 默认值）&#123;&#125;\nint func(int a, int b &#x3D; 10, int c &#x3D; 10) &#123;\n\treturn a + b + c;\n&#125;\n\n&#x2F;&#x2F;1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\n&#x2F;&#x2F;2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\n&#x2F;&#x2F;声明和定义只能有一个是形参有默认值，不然编译器报错\nint func2(int a &#x3D; 10, int b &#x3D; 10);\nint func2(int a, int b) &#123;\n\treturn a + b;\n&#125;\n\nint main() &#123;\n\n\tcout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(100) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n3.2.函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n占位参数也可以添加默认参数\n\n语法： 返回值类型 函数名 (数据类型)&#123;&#125;\n&#x2F;&#x2F;函数占位参数 ，占位参数也可以有默认参数\nvoid func(int a, int) &#123;\n\tcout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\tfunc(10,10); &#x2F;&#x2F;占位参数必须填补\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n3.3.函数重载\n作用： 函数名可以相同，提高复用性\n\n函数重载满足条件：\n\n同一个作用域下（例如目前函数都写在 main 函数外面，属于全局函数，就在同一个作用域下）\n函数名称相同\n函数参数类型不同 或者 个数不同 或者 顺序不同\n\n注意: 函数的返回值不可以作为函数重载的条件\n\n示例：\nvoid func()\n&#123;\n\tcout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int a)\n&#123;\n\tcout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(int a ,double b)\n&#123;\n\tcout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;\n&#125;\n\nvoid func(double a ,int b)\n&#123;\n\tcout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n  &#x2F;&#x2F;这些都可以被调用，只要参数不一样，或者参数顺序不一样就没问题\n\tfunc();  \n\tfunc(10);\n\tfunc(10, 3.14);\n\tfunc(3.14, 10);\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n3.4.函数重载注意事项\n引用作为重载条件\n函数重载碰到函数默认参数\n\n\n示例：\n&#x2F;&#x2F;1、引用作为重载条件\n\nvoid func(int &amp;a)\n&#123;\n\tcout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;\n&#125;\n\nvoid func(const int &amp;a)\n&#123;\n\tcout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;2、函数重载碰到函数默认参数\n\nvoid func2(int a, int b &#x3D; 10)\n&#123;\n\tcout &lt;&lt; &quot;func2(int a, int b &#x3D; 10) 调用&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2(int a)\n&#123;\n\tcout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\t\n\tint a &#x3D; 10;\n\tfunc(a); &#x2F;&#x2F;调用无const\n\tfunc(10);&#x2F;&#x2F;调用有const\n\n\t&#x2F;&#x2F;func2(10); &#x2F;&#x2F;碰到默认参数产生歧义，需要避免\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n参考与致谢\nC++内存分配秘籍\n\n","slug":"C-C++/C-C++_AllCore/C++_Core","date":"2022-01-24T10:49:36.000Z","categories_index":"Language","tags_index":"C/C++","author_index":"Miraggio"},{"id":"685a5f7f3a39655d238f8071cde76eaf","title":"C++ 面向对象三大特征","content":"1.封装1.1.封装的意义封装是C++面向对象三大特性之一\n封装的意义：\n\n将属性和行为作为一个整体，表现生活中的事物\n将属性和行为加以权限控制\n\n\n封装意义一：\n在设计类的时候，属性和行为写在一起，表现事物\n语法：    class 类名&#123; 访问权限： 属性 / 行为 &#125;;\n\n*示例1：**设计一个圆类，求圆的周长\n  #define PI 3.14159\n\n&#x2F;&#x2F;创建一个类\nclass Circle\n&#123;\npublic: &#x2F;&#x2F;访问权限  公共的权限\n\t&#x2F;&#x2F;属性\n\tint m_r;\n\n\t&#x2F;&#x2F;行为\n\t&#x2F;&#x2F;计算圆的周长\n\tdouble calculateZC()\n\t&#123;\n\t\treturn 2 * PI * m_r;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;创建对象\nCircle c1;\n\nint main()\n&#123;\n\tc1.m_r &#x3D; 10;\n\n\tcout &lt;&lt; c1.calculateZC() &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n其中：\n\n所有属性和行为都属于成员\n属性的别名：成员属性 成员变量\n行为的别名：成员函数 成员方法\n\n\n\n而且行为里都是正常的函数的写法，既可以像上诉一样，也可以有函数参数。\n\n\n封装意义二：\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n访问权限有三种：\n\npublic 公共权限（成员在类内和类外都可以被访问）\n\nprotected 保护权限（成员数据在类内可以被访问，类外不可以；儿子可以访问父亲中的保护内容）\n\nprivate 私有权限（成员数据在类内可以被访问，类外不可以；儿子不可以访问父亲中的保护内容）\n\n\n\n示例：\n  class CAN\n&#123;\nprivate: &#x2F;&#x2F;访问权限 私人权限\n&#x2F;&#x2F;属性\n\n&#x2F;&#x2F;行为\nprotected: &#x2F;&#x2F;访问权限 保护权限\n&#x2F;&#x2F;属性\nint Can_Receive;\n\npublic: &#x2F;&#x2F;访问权限  公共的权限\n&#x2F;&#x2F;属性\nint Can_Data;\n\n&#x2F;&#x2F;行为\nvoid Can_ReceiveData(int Can_ReceiveDatas)\n&#123;\n\tCan_Receive &#x3D; Can_ReceiveDatas;\n\tCan_Data &#x3D; Can_Receive;\n&#125;\n&#125;;\n\n&#x2F;&#x2F;创建对象\nCAN c1;\n\nint main()\n&#123;\n\tc1.Can_ReceiveData(10);\n\n\tcout &lt;&lt; c1.Can_Data &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n1.2.struct 和 class 区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同\n区别：\n\nstruct 默认权限为公共\nclass 默认权限为私有\n\n1.3.成员属性设置为私有\n优点1： 将所有成员属性设置为私有，可以自己控制读写权限\n优点2： 对于写权限，我们可以检测数据的有效性\n\n通过公开访问区域自定义读写函数，对私人数据进行操作。（例如上诉的封装意义二的代码例子）\n2.继承继承是面向对象三大特性之一\n有些类与类之间存在特殊的关系，例如下图中：\n\n我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。\n这个时候我们就可以考虑利用继承的技术，减少重复代码\n2.1.继承的基本语法\n语法：\n    class 类A : public 类B\nclass Buliding\n&#123;\npublic:\n    Buliding() : m_a(10) &#123;&#125;\n    int m_a;\n    void ShowBase(void)\n    &#123;\n    cout &lt;&lt; &quot;地基&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;继承上面的\nclass Bedroom : public Buliding\n&#123;\npublic:\n    void ShowBedroom(void)\n    &#123;\n    cout &lt;&lt; &quot;卧室&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Bedroom bedroom;\n    cout &lt;&lt; bedroom.m_a &lt;&lt; endl;\n    bedroom.ShowBase();\n    bedroom.ShowBedroom();\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n\n\n\n运行结果：\n \n\n总结：\n\n继承的好处：可以减少重复的代码\n\nA 类称为子类 或 派生类\n\nB 类称为父类 或 基类\n\n派生类中的成员，包含两大部分：\n\n一类是从基类继承过来的，一类是自己增加的成员。\n\n从基类继承过过来的表现其共性，而新增的成员体现了其个性\n\n\n\n\n\n\n2.2 继承方式继承的语法：    class 子类 : 继承方式 父类\n继承方式一共有三种：\n\n公共继承\n保护继承\n私有继承\n\n\n2.3.继承中的对象模型\n问题： 从父类继承过来的成员，哪些属于子类对象中？\nclass Base\n&#123;\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C; &#x2F;&#x2F;私有成员只是被隐藏了，但是还是会继承下去\n&#125;;\n\n&#x2F;&#x2F;公共继承\nclass Son :public Base\n&#123;\npublic:\n\tint m_D;\n&#125;;\n\nvoid test01()\n&#123;\n\tcout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到\n2.4.继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数\n问题：父类和子类的构造和析构顺序是谁先谁后？\n\n示例：\nclass Base \n&#123;\npublic:\n\tBase()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t~Base()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass Son : public Base\n&#123;\npublic:\n\tSon()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t~Son()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\tSon s;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n2.5.继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n\n访问子类同名成员 直接访问即可\n访问父类同名成员 需要加作用域\n\n\n示例：\nclass Base &#123;\npublic:\n\tBase()\n\t&#123;\n\t\tm_A &#x3D; 100;\n\t&#125;\n\n\tvoid func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid func(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\n\t&#125;\n\npublic:\n\tint m_A;\n&#125;;\n\nclass Son : public Base &#123;\npublic:\n\tSon()\n\t&#123;\n\t\tm_A &#x3D; 200;\n\t&#125;\n\n\t&#x2F;&#x2F;当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n\t&#x2F;&#x2F;如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\n\tvoid func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\nvoid test01()\n&#123;\n\tSon s;\n\n\tcout &lt;&lt; &quot;Son下的m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base下的m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\n\ts.func();\n\ts.Base::func();\n\ts.Base::func(10);\n\n&#125;\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\treturn EXIT_SUCCESS;\n&#125;\n\n\n\n\n总结：\n\n子类对象可以直接访问到子类中同名成员\n\n子类对象加作用域可以访问到父类同名成员\n\n当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数\n\n\n\n\n2.6.继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？\n静态成员和非静态成员出现同名，处理方式一致\n\n访问子类同名成员 直接访问即可\n访问父类同名成员 需要加作用域\n\n\n示例：\nclass Base &#123;\npublic:\n\tstatic void func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;\n\t&#125;\n\tstatic void func(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;\n\t&#125;\n\n\tstatic int m_A;\n&#125;;\n\nint Base::m_A &#x3D; 100;\n\nclass Son : public Base &#123;\npublic:\n\tstatic void func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;\n\t&#125;\n\tstatic int m_A;\n&#125;;\n\nint Son::m_A &#x3D; 200;\n\n&#x2F;&#x2F;同名成员属性\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;通过对象访问\n\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\n\tSon s;\n\tcout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\n\t&#x2F;&#x2F;通过类名访问\n\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;同名成员函数\nvoid test02()\n&#123;\n\t&#x2F;&#x2F;通过对象访问\n\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\n\tSon s;\n\ts.func();\n\ts.Base::func();\n\n\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\n\tSon::func();\n\tSon::Base::func();\n\t&#x2F;&#x2F;出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\n\tSon::Base::func(100);\n&#125;\nint main() &#123;\n\n\t&#x2F;&#x2F;test01();\n\ttest02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n2.7.多继承语法C++允许一个类继承多个类\n语法：class 子类 ：继承方式 父类1 ， 继承方式 父类2...\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\nC++实际开发中不建议用多继承\n\n示例：\nclass Base1 &#123;\npublic:\n\tBase1()\n\t&#123;\n\t\tm_A &#x3D; 100;\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\nclass Base2 &#123;\npublic:\n\tBase2()\n\t&#123;\n\t\tm_A &#x3D; 200;  &#x2F;&#x2F;开始是m_B 不会出问题，但是改为mA就会出现不明确\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\n&#x2F;&#x2F;语法：class 子类：继承方式 父类1 ，继承方式 父类2 \nclass Son : public Base2, public Base1 \n&#123;\npublic:\n\tSon()\n\t&#123;\n\t\tm_C &#x3D; 300;\n\t\tm_D &#x3D; 400;\n\t&#125;\npublic:\n\tint m_C;\n\tint m_D;\n&#125;;\n\n&#x2F;&#x2F;多继承容易产生成员同名的情况\n&#x2F;&#x2F;通过使用类名作用域可以区分调用哪一个基类的成员\nvoid test01()\n&#123;\n\tSon s;\n\tcout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;\n\tcout &lt;&lt; s.Base1::m_A &lt;&lt; endl;\n\tcout &lt;&lt; s.Base2::m_A &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域\n2.8.菱形继承2.8.1.菱形继承概念：\n两个派生类继承同一个基类\n又有某个类同时继承者两个派生类\n这种继承被称为菱形继承，或者钻石继承\n\n2.8.2.典型的菱形继承案例：\n2.8.3.菱形继承问题：\n羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\n\n草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\n\n\n\n示例：\nclass Animal\n&#123;\npublic:\n\tint m_Age;\n&#125;;\n\n&#x2F;&#x2F;继承前加virtual关键字后，变为虚继承\n&#x2F;&#x2F;此时公共的父类Animal称为虚基类\nclass Sheep : virtual public Animal &#123;&#125;;\nclass Tuo   : virtual public Animal &#123;&#125;;\nclass SheepTuo : public Sheep, public Tuo &#123;&#125;;\n\nvoid test01()\n&#123;\n\tSheepTuo st;\n\tst.Sheep::m_Age &#x3D; 100;\n\tst.Tuo::m_Age &#x3D; 200;\n\n\tcout &lt;&lt; &quot;st.Sheep::m_Age &#x3D; &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\n\tcout &lt;&lt; &quot;st.Tuo::m_Age &#x3D; &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;\n\tcout &lt;&lt; &quot;st.m_Age &#x3D; &quot; &lt;&lt; st.m_Age &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n总结：\n\n菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义\n\n利用虚继承可以解决菱形继承问题\n\n\n\n\n3.多态3.1.多态的基本概念多态是C++面向对象三大特性之一\n多态分为两类：\n\n静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名\n\n动态多态: 派生类和虚函数实现运行时多态\n\n\n\n\n\n\n\n\n\n\n\n静态多态和动态多态区别：\n\n静态多态的函数地址早绑定 - 编译阶段确定函数地址\n动态多态的函数地址晚绑定 - 运行阶段确定函数地址\n\n参考与致谢\n（虚继承）防止重复内容的有趣操作\n\n","slug":"C-C++/C-C++_AllFeature/C-C++_Feature","date":"2022-01-24T10:49:36.000Z","categories_index":"Language","tags_index":"C/C++","author_index":"Miraggio"},{"id":"2e64fdde2898213a1b1e2c6c7baa0826","title":"C++ 类和对象（上）","content":"1.对象C++面向对象的三大特性为：封装、继承、多态\nC++认为万事万物都皆为对象，对象上有其属性和行为\n示例：\n 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…\n 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…\n 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类\n2.构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题\n 一个对象或者变量没有初始状态，对其使用后果是未知\n 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\nc++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供\n编译器提供的构造函数和析构函数是空实现。\n\n构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\n析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。\n\n\n构造函数语法：类名()&#123;&#125;\n\n构造函数，没有返回值也不写void\n\n函数名称与类名相同\n\n构造函数可以有参数，因此可以发生重载\n\n\n程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次\n析构函数语法： ~类名()&#123;&#125;\n\n析构函数，没有返回值也不写void\n\n函数名称与类名相同,在名称前加上符号 ~\n\n析构函数不可以有参数，因此不可以发生重载\n\n程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次\n\n\n\n示例：\nclass Person\n&#123;\npublic:\n\t&#x2F;&#x2F;构造函数\n\tPerson()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;析构函数\n\t~Person()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson p;\n&#125;\n\nint main() &#123;\n\t\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n3.构造函数的分类及调用两种分类方式：\n 按参数分为： 有参构造和无参构造\n 按类型分为： 普通构造和拷贝构造\n\n有参构造和无参构造\nclass Person\n&#123;\npublic:\nint Age;\n\n\tPerson()\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用无参构造函数&quot; &lt;&lt; endl;\n\t&#125;\n\n\tPerson(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用有参构造函数&quot; &lt;&lt; endl;\n\t\tAge &#x3D; a;\n\t&#125;\n&#125;;\n\n\n\n\n普通构造和拷贝构造\nclass Person\n&#123;\npublic:\n\tint Age;\n\n\tPerson(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用有参构造函数&quot; &lt;&lt; endl;\n\t\tAge &#x3D; a;\n\t&#125;\n\n\tPerson(const Person &amp;p)\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl;\n\t\tAge &#x3D; p.Age;\n\t&#125;\n\n&#125;;\n\n\n\n\n三种调用方式：\n\n1. 括号法\nPerson p(50); &#x2F;&#x2F;调用有参构造函数\nPerson p1(p); &#x2F;&#x2F;调用拷贝构造函数\n\n\n\n\n2. 显示法\nPerson p2 &#x3D; Person(60); &#x2F;&#x2F;调用有参构造函数\nPerson p3 &#x3D; Person(p2); &#x2F;&#x2F;调用拷贝构造函数\n\n\n\n\n3. 隐式转换法\nPerson p4 &#x3D; 70;\nPerson p5 &#x3D; p4;\n\n\n\n\n注意事项：\n无参构造函数不能加括号 &#x2F;&#x2F;注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n&#x2F;&#x2F;Person p2();\n\n创建匿名对象 特点：当前行执行结束后，系统会立刻回收掉匿名对象 Person(60);\ncout &lt;&lt; &quot;aaaaa&quot; &lt;&lt; endl;\n 编译后结果：可以看见与正常创建对象不一样，正常创建对象调用析构函数是在函数结束是才会调用，但是创建匿名对象调用完构造函数就马上调用析构函数了 \n拷贝构造函数 &#x2F;&#x2F;注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明:Person (p4) &#x3D;&#x3D;&#x3D; Person p4;\n&#x2F;&#x2F;Person(p4);\n\n\n\n\n4.拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况\n\n使用一个已经创建完毕的对象来初始化一个新对象\n Person p(50); &#x2F;&#x2F;调用有参构造函数\nPerson p1(p); &#x2F;&#x2F;调用拷贝构造函数\n\n值传递的方式给函数参数传值\n void test01(Person p)\n&#123;\n\tcout &lt;&lt; &quot;aaaaaa&quot; &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n\tPerson p;\n\ttest01(p);\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n 运行后结果如下：\n\n首先执行创建 Person p，就会调用构造函数\n接着进入值传递函数里，会自动执行拷贝函数，也就是说 test01() 中对形参 p 进行修改对实际传入的对象成员不会有影响\n第一次调用析构函数是 test01() 函数结束而调用，第二次是在main函数里创建的对象调用\n\n \n\n以值方式返回局部对象（与编译器有关，不绝对）\n在教程里，当函数的返回值为类类型时，return 语句会返回一个对象，不过为了防止局部对象被销毁，也为了防止通过返回值修改原来的局部对象，编译器并不会直接返回这个对象，而是根据这个对象先创建出一个临时对象（匿名对象），再将这个临时对象返回。\n\n而创建临时对象的过程，就是以拷贝的方式进行的，会调用拷贝构造函数。\n\n\n但是我的编译器不会调用拷贝函数来创建匿名对象，而是直接把局部创建对象返回\n\n\n\n\n\n5.构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数\n1．默认构造函数(无参，函数体为空)\n2．默认析构函数(无参，函数体为空)\n3．默认拷贝构造函数，对属性进行值拷贝\n构造函数调用规则如下：\n\n如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n快速记忆：有高级的就不会提供低级：  \n  💡 拷贝构造函数→有参构造函数→无参/默认构造函数\n  \n  \n  \n\n6.深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑\n6.1.浅拷贝\n简单的赋值拷贝操作\n使用系统默认拷贝构造函数时，它是将一个对象上的内容原封不动的拷贝到另一个对象上。\n\nclass Person\n&#123;\npublic:\n\tPerson()\n\t&#123;\n\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; 0;\n\t&#125;\n\tPerson(int age, int hight)\n\t&#123;\n\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; age;\n\t\tm_Hight &#x3D; new int(hight);\n\t&#125;\n\n\t~Person()\n\t&#123;\n\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n\t&#125;\n\npublic:\n\tint mAge;\n\tint *m_Hight;\n&#125;;\n\n\n在 main 函数上执行拷贝并打印 m_Hight 地址\n\nPerson p(10, 160);\nPerson p1(p);\n\ncout &lt;&lt; p1.m_Hight &lt;&lt; endl;\ncout &lt;&lt; p.m_Hight &lt;&lt; endl;\n\n\n\n\n运行结果：可以发现地址是一样的，那是因为在创建对象 p 时，进行的是用户在堆区申请内存空间操作，这时候 m_Hight 地址是指向堆区那个内存，接着进行拷贝时，p1 的 m_Hight 也是完全拷贝 p 的 m_Hight，于是地址都是一致，都是指向同一个内存，这种叫浅拷贝。\n\n6.2深拷贝\n在堆区重新申请空间，进行拷贝操作\n在上诉的类里添加用户自定义拷贝构造函数\n\nPerson(const Person &amp;p)\n\t&#123;\n\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; p.mAge;\n\t\tm_Hight &#x3D; new int(*p.m_Hight);\n\t&#125;\n\n\n在 main 函数上执行拷贝并打印 m_Hight 地址\n\nPerson p(10, 160);\nPerson p1(p);\n\ncout &lt;&lt; p1.m_Hight &lt;&lt; endl;\ncout &lt;&lt; p.m_Hight &lt;&lt; endl;\n\n\n\n\n运行结果：可以发现地址不一样了，因为执行了我们定义的拷贝构造函数，给 p1 也申请了一个内存，于是就没有指向同一个内存了，这种叫深拷贝。\n\n6.3.总结如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n7.初始化列表作用：C++提供了初始化列表语法，用来初始化属性\n\n语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125;\nclass Person\n&#123;\npublic:\n\tPerson(int a, int b, int c) : mAge(a), m_Hight(b), llll(c)\n  &#123;\n     cout &lt;&lt; &quot;Person属性初始化成功&quot; &lt;&lt; endl;\n  &#125;\n\npublic:\n\tconst int mAge;\n\tint m_Hight;\n\tint llll;\n&#125;;\n\nint main()\n&#123;\n\tPerson p(10,20,30);\n\n\tcout &lt;&lt; p.mAge &lt;&lt; endl;\n\tcout &lt;&lt; p.m_Hight &lt;&lt; endl;\n\tcout &lt;&lt; p.llll &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n这种方式也可以初始化常量的属性\n\n\n我的编译器还支持一种方法\nclass Person\n&#123;\npublic:\n\t&#x2F;&#x2F; Person(int a, int b, int c) : mAge(a), m_Hight(b), llll(c)&#123;&#125;\n\npublic:\n\tconst int mAge;\n\tint m_Hight;\n\tint llll;\n&#125;;\n\nint main()\n&#123;\n\tPerson p(&#123;10,20,30&#125;);\n\n\tcout &lt;&lt; p.mAge &lt;&lt; endl;\n\tcout &lt;&lt; p.m_Hight &lt;&lt; endl;\n\tcout &lt;&lt; p.llll &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n这种方法也可以对常量进行初始化\n8.类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员\nclass A &#123;&#125;\nclass B\n&#123;\n    A a；\n&#125;\n\n在这种情况下，构造对象时会先构造 A类对象，之后在构造 B类对象；而析构时先析构 B类对象，之后在析构 A类对象。\n参考与致谢\nC++类和对象的概念\n\nC++拷贝构造函数的调用时机\n\n\n","slug":"C-C++/C-C++_AllObject/C-C++_Object","date":"2022-01-24T10:49:36.000Z","categories_index":"Language","tags_index":"C/C++","author_index":"Miraggio"},{"id":"bf1ca1b83272793e4c3d135bd1c7f7c7","title":"C++ 友元与运算符","content":"1.友元生活中你的家有客厅(Public)，有你的卧室(Private)\n客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去\n但是呢，你也可以允许你的好闺蜜好基友进去。\n在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\n友元的关键字为 friend\n友元的三种实现\n\n全局函数做友元\n类做友元\n成员函数做友元\n\n1.1.全局函数做友元\n若成员属于私人空间，但想被某个全局函数调用，可以在类里加上 friend 函数\nclass Person\n&#123;\n\tfriend void test01(void);\npublic:\n\tPerson() : m_age(0) &#123;&#125;\n\nprivate:\n\tint m_age;\n\n\tvoid Showlll(void)\n\t&#123;\n\t\tcout &lt;&lt; &quot;fdsfsadfa&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nvoid test01(void)\n&#123;\n\tPerson p;\n\tp.m_age &#x3D; 10;\n\tcout &lt;&lt; p.m_age &lt;&lt; endl;\n\tp.Showlll();\n&#125;\n\n\n\n\n运行结果：  \n\n1.2.类做友元\n在 A 类里添加 B 类并要访问其私人空间成员，可以在 B 类里添加 friend class 类名\nclass Room;\nclass Building\n&#123;\npublic:\n\tBuilding();\n\tvoid Showroom(void);\n\nprivate:\n\tRoom *room;\n&#125;;\n&#x2F;************************************&#x2F;\nclass Room\n&#123;\n\tfriend class Building;\npublic:\n\tRoom();\n\nprivate:\n\tint m_a;\n\tint m_b;\n\tvoid Showlll(void)\n\t&#123;\n\t\tcout &lt;&lt; &quot;fdsfsadfa&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n&#x2F;************************************&#x2F;\n&#x2F;&#x2F;创建 Room 对象时初始化成员\nRoom ::Room()\n&#123;\n\tm_a &#x3D; 50;\n\tm_b &#x3D; 100;\n&#125;\n&#x2F;&#x2F;在 Building 初始化构造函数里创建 Room 类型对象\nBuilding ::Building()\n&#123;\n\troom &#x3D; new Room;\n&#125;\n&#x2F;&#x2F;可以在类内访问私人空间成员\nvoid Building::Showroom(void)\n&#123;\n\tcout &lt;&lt; room-&gt;m_a &lt;&lt; endl;\n\tcout &lt;&lt; room-&gt;m_b &lt;&lt; endl;\n\troom-&gt;Showlll();\n&#125;\n\ntest01(void)\n&#123;\n\tBuilding building;\n\tbuilding.Showroom();\n&#125;\n\nint main()\n&#123;\n\ttest01();\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n1.3.成员函数做友元\n与类做友元原理一致，只是换成该类作用域下某个成员函数。friend 返回值 作用域::成员函数\nclass Room;\nclass Building\n&#123;\npublic:\n\tBuilding();\n\tvoid Showroom(void);\n\nprivate:\n\tRoom *room;\n&#125;;\n\nclass Room\n&#123;\n\tfriend void Building::Showroom(void);\n\npublic:\n\tRoom();\n\nprivate:\n\tint m_a;\n\tint m_b;\n\tvoid Showlll(void)\n\t&#123;\n\t\tcout &lt;&lt; &quot;fdsfsadfa&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;创建 Room 对象时初始化成员\nRoom ::Room()\n&#123;\n\tm_a &#x3D; 50;\n\tm_b &#x3D; 100;\n&#125;\n&#x2F;&#x2F;在 Building 初始化构造函数里创建 Room 类型对象\nBuilding ::Building()\n&#123;\n\troom &#x3D; new Room;\n&#125;\n&#x2F;&#x2F;可以在类内访问私人空间成员\nvoid Building::Showroom(void)\n&#123;\n\tcout &lt;&lt; room-&gt;m_a &lt;&lt; endl;\n\tcout &lt;&lt; room-&gt;m_b &lt;&lt; endl;\n\troom-&gt;Showlll();\n&#125;\n\ntest01(void)\n&#123;\n\tBuilding building;\n\tbuilding.Showroom();\n&#125;\n\nint main()\n&#123;\n\ttest01();\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n2.运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n2.1.加号运算符重载作用：实现两个自定义数据类型相加的运算\n\n用系统带的operator+进行重载\nclass Person\n&#123;\npublic:\n\tint m_a;\n\tint m_b;\n\n\tPerson() : m_a(60), m_b(20) &#123;&#125;\n\n\t&#x2F;&#x2F;成员函数重载加号运算符\n\tPerson operator+(const Person &amp;p2)\n\t&#123;\n\t\tPerson temp;\n\t\ttemp.m_a &#x3D; this-&gt;m_a + p2.m_a;\n\t\ttemp.m_b &#x3D; this-&gt;m_b + p2.m_b;\n\t\treturn temp;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;全局函数重载加号运算符\n&#x2F;&#x2F; Person operator+(Person p1, Person p2)\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F; \tPerson temp;\n&#x2F;&#x2F; \ttemp.m_a &#x3D; p1.m_a + p2.m_a;\n&#x2F;&#x2F; \ttemp.m_b &#x3D; p1.m_b + p2.m_b;\n&#x2F;&#x2F; \treturn temp;\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F;运算符重载也可以发生函数重载\nPerson operator+(Person p1, int num)\n&#123;\n\tPerson temp;\n\ttemp.m_a &#x3D; p1.m_a + num;\n\ttemp.m_b &#x3D; p1.m_b + num;\n\treturn temp;\n&#125;\n\ntest01(void)\n&#123;\n\tPerson p1;\n\tPerson p2;\n\n\t&#x2F;&#x2F;成员函数方式：相当于 p1.operaor+(p2)\n\t&#x2F;&#x2F;全局函数方式：相当于 operator+(p1,p2)\n\tPerson p3 &#x3D; p1 + p2;\n\tPerson p4 &#x3D; p3 + 50;\n\n\t&#x2F;&#x2F;重载后不影响本来的运算符\n\tint i &#x3D; 0;\n\ti &#x3D; 50 + 60;\n\tcout &lt;&lt; &quot;i &#x3D; &quot; &lt;&lt; i &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;p3.m_a &#x3D; &quot; &lt;&lt; p3.m_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;p3.m_b &#x3D; &quot; &lt;&lt; p3.m_b &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;p4.m_a &#x3D; &quot; &lt;&lt; p4.m_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;p4.m_b &#x3D; &quot; &lt;&lt; p4.m_b &lt;&lt; endl;\n\n&#125;\n\nint main()\n&#123;\n\ttest01();\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n运行结果：\n  \n\n\n\n\n\n\n\n\n\n总结1：对于内置的数据类型的表达式的的运算符是不可能改变的\n\n\n\n\n\n\n\n\n\n总结2：不要滥用运算符重载\n\n\n2.2.左移运算符重载作用：可以输出自定义数据类型\n\n用系统带的operator&lt;&lt;进行重载\nclass Person &#123;\n\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);\n\npublic:\n\n\tPerson(int a, int b)\n\t&#123;\n\t\tthis-&gt;m_A &#x3D; a;\n\t\tthis-&gt;m_B &#x3D; b;\n\t&#125;\n\n\t&#x2F;&#x2F;成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果\n\t&#x2F;&#x2F;void operator&lt;&lt;(Person&amp; p)&#123;\n\t&#x2F;&#x2F;&#125;\n\nprivate:\n\tint m_A;\n\tint m_B;\n&#125;;\n\n&#x2F;&#x2F;全局函数实现左移重载\n&#x2F;&#x2F;ostream对象只能有一个\nostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;\n\tout &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;\n\treturn out;\n&#125;\n\nvoid test() &#123;\n\n\tPerson p1(10, 20);\n\n\tcout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#x2F;&#x2F;链式编程\n&#125;\n\nint main() &#123;\n\n\ttest();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n&gt; 总结：重载左移运算符配合友元可以实现输出自定义数据类型\n\n","slug":"C-C++/C-C++_AllFriend/C-C++_Friend","date":"2022-01-24T10:49:36.000Z","categories_index":"Language","tags_index":"C/C++","author_index":"Miraggio"},{"id":"930e385e7065f8662e317e6f8991f017","title":"C++ 类和对象（下）","content":"9.静态对象9.1.静态成员变量\n类中静态成员变量对同一个类不同对象都是共用的，而且只能通过类外这种方法进行初始化\nclass Person\n&#123;\n\t&#x2F;&#x2F;静态成员变量特点：\n\t&#x2F;&#x2F;1 在编译阶段分配内存\n\t&#x2F;&#x2F;2 类内声明，类外初始化\n\t&#x2F;&#x2F;3 所有对象共享同一份数据\n\npublic:\n\tstatic int a;\n  &#x2F;&#x2F;初始化也不行\n\t&#x2F;&#x2F; Person() : a(10) &#123;&#125;  \n&#125;;\n\nint Person ::a &#x3D; 10;\n\n\n\n\n通过对象访问静态变量（必须先对其类外初始化才可以尽享访问）\n\n先创建一个对象，之后在对其赋值。\n\n但是由于静态成员变量是所有对象共享同一份数据，因此创建另一个对象在修改变量，会影响其他对象的变量。\n  int main()\n&#123;\n\t&#x2F;&#x2F;创建一个对象 p\n\tPerson p;\n\t&#x2F;&#x2F;对其静态成员变量进行赋值\n\tp.a &#x3D; 100;\n\t&#x2F;&#x2F;打印静态成员变量\n\tcout &lt;&lt; p.a &lt;&lt; endl;\n\n\t&#x2F;&#x2F;创建一个对象 p1\n\tPerson p1;\n\t&#x2F;&#x2F;对其静态成员变量进行赋值\n\tp1.a &#x3D; 1000;\n\t&#x2F;&#x2F;打印静态成员变量\n\tcout &lt;&lt; p.a &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n运行结果：\n \n\n\n\n通过类名访问静态变量（必须先对其类外初始化才可以尽享访问）\n\n在静态成员变量初始化后，可以不创建对象，直接通过类名来访问到变量，但是不能进行赋值操作。  int main()\n&#123;\n\t\n\tcout &lt;&lt; Person ::a &lt;&lt; endl;\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n运行结果（我初始化给了10）： \n\n\n静态成员变量也可以有私有权限\n\n若静态成员变量为私有权限，则外部一样没有访问权限，只有类外初始化能运行。于是想赋值和打印只能通过自定义函数再由外部调用。  class Person\n&#123;\n\t&#x2F;&#x2F;静态成员变量特点：\n\t&#x2F;&#x2F;1 在编译阶段分配内存\n\t&#x2F;&#x2F;2 类内声明，类外初始化\n\t&#x2F;&#x2F;3 所有对象共享同一份数据\n\npublic:\n\tvoid lll(int Get_a)\n\t&#123;\n\t\ta &#x3D; Get_a;           &#x2F;&#x2F;赋值操作\n\t\tcout &lt;&lt; a &lt;&lt; endl;   &#x2F;&#x2F;打印变量\n\t&#125;\n\nprivate:\n\tstatic int a;\n&#125;;\n\nint Person ::a &#x3D; 10;  &#x2F;&#x2F;必须初始化操作！！！！！\n\nint main()\n&#123;\n\tPerson p;\n\tp.lll(100);\n\n\tPerson p1;\n\tp1.lll(1000);\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n运行结果： \n\n\n\n9.2.静态成员函数\n与静态成员变量有点类似，程序共享一个函数，而且函数内只能访问静态变量\nclass Person\n&#123;\n\t&#x2F;&#x2F;静态成员函数特点：\n\t&#x2F;&#x2F;1 程序共享一个函数\n\t&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量\n\npublic:\n\tstatic void fun()\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用fun&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\n\n\n\n通过对象访问静态函数\n\n创建一个对象，直接调用。  int main()\n&#123;\n\tPerson p;\n\tp.fun();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n运行结果： \n\n\n通过类名访问静态函数\n\n从这里可以验证程序共享一个函数的特点  int main()\n&#123;\n\tPerson::fun();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n运行结果： \n\n\n函数内只能访问静态变量\n\n上诉说了，静态函数有程序共享一个函数的特点。假如要访问非静态变量，它无法知道该变量具体在哪个对象里。  class Person\n&#123;\n\t&#x2F;&#x2F;静态成员函数特点：\n\t&#x2F;&#x2F;1 程序共享一个函数\n\t&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量\n\npublic:\n\tstatic void fun()\n\t&#123;\n\t\tcout &lt;&lt; a &lt;&lt; endl;\n\t\t&#x2F;&#x2F;无法知道 b 属于什么对象\n\t\t&#x2F;&#x2F; cout &lt;&lt; b &lt;&lt; endl;\n\t\tcout &lt;&lt; &quot;调用fun&quot; &lt;&lt; endl;\n\t&#125;\n\nprivate:\n\tstatic int a;\n\tint b;\n&#125;;\n\nint Person ::a &#x3D; 10;\n\nint main()\n&#123;\n\tPerson::fun();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n静态成员函数也可以有私有权限\n\n若静态成员函数为私有权限，则外部一样没有访问权限。  class Person\n&#123;\n\t&#x2F;&#x2F;静态成员函数特点：\n\t&#x2F;&#x2F;1 程序共享一个函数\n\t&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量\n\nprivate:\n\tstatic void fun()\n\t&#123;\n\t\tcout &lt;&lt; &quot;调用fun&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\nint main()\n&#123;\n\t&#x2F;&#x2F;访问不到\n\t&#x2F;&#x2F;Person::fun();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n10.成员变量和成员函数分开存储\n在C++中，类内的成员变量和成员函数分开存储\n只有非静态成员变量才属于类的对象上\n\n\n示例：\nclass Person &#123;\npublic:\n\tPerson() &#123;\n\t\tmA &#x3D; 0;\n\t&#125;\n\t&#x2F;&#x2F;非静态成员变量占对象空间\n\tint mA;\n\t&#x2F;&#x2F;静态成员变量不占对象空间\n\tstatic int mB; \n\t&#x2F;&#x2F;函数也不占对象空间，所有函数共享一个函数实例\n\tvoid func() &#123;\n\t&#125;\n\t&#x2F;&#x2F;静态成员函数也不占对象空间\n\tstatic void sfunc() &#123;\n\t&#125;\n&#125;;\n\nint main() &#123;\n\n\tcout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n运行结果：  \n\n\n需要特别注意的是：C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置。每个空对象也应该有一个独一无二的内存地址。\nclass Person &#123;\n\n&#125;;\n\nint main() &#123;\n\n\tcout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n运行结果：  \n\n11.this指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\nc++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象\n\n\nthis指针是隐含每一个非静态成员函数内的一种指针\nthis指针不需要定义，直接使用即可\nthis指针的本质是指针常量，指针的指向是不可修改的\n\nthis指针的用途：\n\n当形参和成员变量同名时，可用this指针来区分\n\n\n示例：\nclass Person\n&#123;\npublic:\n\tint Age;\n  \n  &#x2F;&#x2F;此时形参名与变量名重名了，不用 this 指针编译器无法区分\n\tvoid GetData(int Age)\n\t&#123;\n\t\tthis-&gt;Age &#x3D; Age;\n\t&#125;\n\n&#125;;\n\nint main()\n&#123;\n\tPerson p1;\n\n\tp1.GetData(10);\n\n\tcout &lt;&lt; p1.m_Age &lt;&lt; endl;\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n在类的非静态成员函数中返回对象本身，可使用return *this\n\n\n示例：\nclass Person\n&#123;\npublic:\n\tint Age;\n\n\tvoid GetData(int Age)\n\t&#123;\n\t\tthis-&gt;Age &#x3D; Age;\n\t&#125;\n\n  &#x2F;&#x2F;这里返回值用到了引用语法\n\tPerson &amp;PersonAddData(int Data)\n\t&#123;\n\t\tm_Age +&#x3D; Data;\n\t\treturn *this;  &#x2F;&#x2F;实际返回的是当前对象\n\t&#125;\n&#125;;\n\nint main()\n&#123;\n\tPerson p2;\n\n\tp2.GetData(10);\n\n\tp2.PersonAddData(10).PersonAddData(10).PersonAddData(10);\n\n\tcout &lt;&lt; p2.m_Age &lt;&lt; endl;\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n如果返回值也可以写成下面这种形式：\nPerson PersonAddData(int Data)\n\t&#123;\n\t\tm_Age +&#x3D; Data;\n\t\treturn *this;\n\t&#125;\n\n\n\n\n运行的结果:  \n\n正常运行结果应该是40，在这里只有20。原因是没有了引用，编译器会在下一次调用的时候创建一个新的对象，而不是返回我们要的对象\n&#x2F;&#x2F;这里其实只调用过一次 p2，后面两次都是创建了新的对象 \np2.PersonAddData(10).PersonAddData(10).PersonAddData(10);\n\n12.空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n\n如果用到this指针，需要加以判断保证代码的健壮性\n&#x2F;&#x2F;空指针访问成员函数\nclass Person\n&#123;\npublic:\n\tvoid ShowClassName()\n\t&#123;\n\t\tcout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid ShowPerson()\n\t&#123;\n\t\tif (this &#x3D;&#x3D; NULL) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tcout &lt;&lt; mAge &lt;&lt; endl;\n\t&#125;\n\npublic:\n\tint mAge;\n&#125;;\n\nint main()\n&#123;\n\tPerson *p1 &#x3D; NULL;\n\n  p1-&gt;ShowClassName(); &#x2F;&#x2F;空指针，可以调用成员函数\n\tp1-&gt;ShowPerson();  &#x2F;&#x2F;但是如果成员函数中用到了this指针，就不可以了\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n运行结果：  \n\n可以看到字符串可以被打印出来，但是由于是空指针，成员变量为空。\n13.const修饰成员函数13.1.常函数：\n成员函数后加const后我们称为这个函数为常函数\n常函数内不可以修改成员属性\n成员属性声明时加关键字mutable后，在常函数中依然可以修改\n\n\n示例：\nclass Person\n&#123;\npublic:\n\tint m_age;\n\tmutable int m_b;\n\n\tvoid ShowDataConst() const\n\t&#123;\n\t\t&#x2F;&#x2F;m_age 在常函数里无法被修改，但是能被访问\n\t\t&#x2F;&#x2F; m_age &#x3D; 10;\n\n\t\t&#x2F;&#x2F;m_b 加上了 mutable 关键字，在常函数里可以被修改\n\t\tm_b &#x3D; 5;\n\t\tcout &lt;&lt; m_age &lt;&lt; endl;\n\t\tcout &lt;&lt; m_b &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nint main()\n&#123;\n\tPerson p;\n\n\tp.ShowData();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n运行结果（m_age 没有进行赋值，默认是16）：  \n\n13.2.常对象：\n声明对象前加const称该对象为常对象\n常对象只能调用常函数\n若类里有成员变量，则需要构造函数初始化才不会报错\n\n\n示例：\nclass Person\n&#123;\npublic:\n\t&#x2F;&#x2F;m_age只能在常函数里访问,不能被修改\n\tint m_age;\n\tmutable int m_b;\n\n\t&#x2F;&#x2F;成员变量必须使用构造函数初始化，否则会报错\n\tPerson()\n\t&#123;\n\t\tm_age &#x3D; 0;\n\t\tm_b &#x3D; 0;\n\t&#125;\n\n\tvoid ShowDataConst() const\n\t&#123;\n\t\tcout &lt;&lt; &quot;nfujksdgbhjk,s&quot; &lt;&lt; endl;\n\t\tcout &lt;&lt; m_age &lt;&lt; endl;\n\n\t&#125;\n\n\t&#x2F;&#x2F;在常对象里无法被调用\n\tvoid ShowData()\n\t&#123;\n\t\tcout &lt;&lt; &quot;nfujksdg&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nint main()\n&#123;\n\tconst Person p;\n\n\tp.ShowDataConst();\n\t&#x2F;&#x2F;无法调用\n\t&#x2F;&#x2F; p.ShowData();\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n运行结果：  \n\n","slug":"C-C++/C-C++_AllObject_2/C-C++_Object_2","date":"2022-01-24T10:49:36.000Z","categories_index":"Language","tags_index":"C/C++","author_index":"Miraggio"}]